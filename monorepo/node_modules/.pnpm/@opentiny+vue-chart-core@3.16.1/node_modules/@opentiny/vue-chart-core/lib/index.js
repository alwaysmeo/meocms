var _color, _aliasTokenMap, _HashMap$;
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf(o, p);
}
function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it)
    return (it = it.call(o)).next.bind(it);
  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it)
      o = it;
    var i = 0;
    return function() {
      if (i >= o.length)
        return { done: true };
      return { done: false, value: o[i++] };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
import * as echarts from "echarts";
import "echarts/extension/bmap/bmap";
import * as echarts$1 from "echarts/lib/echarts";
import "@opentiny/vue-theme/chart-core/index.css";
var toString = Object.prototype.toString;
var hasOwn = Object.prototype.hasOwnProperty;
var getProto = Object.getPrototypeOf;
var fnToString = hasOwn.toString;
var ObjectFunctionString = fnToString.call(Object);
var class2type = {
  "[object Error]": "error",
  "[object Object]": "object",
  "[object RegExp]": "regExp",
  "[object Date]": "date",
  "[object Array]": "array",
  "[object Function]": "function",
  "[object String]": "string",
  "[object Number]": "number",
  "[object Boolean]": "boolean"
};
var isNull = function isNull2(x) {
  return x === null || x === void 0 || x === "undefined";
};
var typeOf$1 = function typeOf$12(obj2) {
  return isNull(obj2) ? String(obj2) : class2type[toString.call(obj2)] || "object";
};
var isObject$1 = function isObject$12(obj2) {
  return typeOf$1(obj2) === "object";
};
var isPlainObject = function isPlainObject2(obj2) {
  if (!obj2 || toString.call(obj2) !== "[object Object]") {
    return false;
  }
  var proto = getProto(obj2);
  if (!proto) {
    return true;
  }
  var Ctor = hasOwn.call(proto, "constructor") && proto.constructor;
  return typeof Ctor === "function" && fnToString.call(Ctor) === ObjectFunctionString;
};
var each = function each2(obj2, handle) {
  if (typeof handle !== "function") {
    return;
  }
  for (var _name in obj2) {
    if (hasOwn.call(obj2, _name)) {
      if (handle(_name, obj2[_name]) === false) {
        break;
      }
    }
  }
};
var extend$2;
var getObj = function getObj2(data3, names, isExceptRoot) {
  if (!data3 || !isPlainObject(data3) || !names || typeof names !== "string") {
    return;
  }
  names = names.split(".");
  var obj2 = data3;
  var len = names.length;
  if (len > 1) {
    var startIndex = isExceptRoot ? 1 : 0;
    for (var i = startIndex; i < len; i++) {
      obj2 = obj2[names[i]];
      if (isNull(obj2)) {
        return obj2;
      }
    }
    return obj2;
  } else {
    return obj2[names[0]];
  }
};
var setObj = function setObj2(data3, names, value, isMerge) {
  if (!data3 || !isPlainObject(data3) || !names || typeof names !== "string") {
    return data3;
  }
  names = names.split(".");
  var obj2 = data3;
  var len = names.length;
  var item = names[0];
  if (len > 1) {
    len--;
    var tmpl = obj2;
    var _name2, target;
    for (var i = 0; i < len; i++) {
      _name2 = names[i];
      target = tmpl[_name2];
      if (target === null || !isPlainObject(target)) {
        tmpl[_name2] = {};
        target = tmpl[_name2];
      }
      tmpl = target;
    }
    item = names[len];
    isMerge ? isPlainObject(tmpl[item]) ? extend$2(true, tmpl[item], value) : tmpl[item] = value : tmpl[item] = value;
  } else {
    isMerge ? isPlainObject(obj2[item]) ? extend$2(true, obj2[item], value) : obj2[item] = value : obj2[item] = value;
  }
  return obj2;
};
var copyField = function copyField2(data3, fields, isMerge, isExclude) {
  var setValue = function setValue2(obj2, result, name2, key, isMerge2) {
    var include = key.indexOf(name2) === 0;
    var keySplit = key.split(name2);
    var hasNextDot = keySplit[1] && keySplit[1].indexOf(".") === 0;
    if (name2 === key || include && hasNextDot) {
      if (name2 !== key) {
        each(getObj(obj2, name2), function(field) {
          setValue2(obj2, result, name2 + "." + field, key);
        });
      }
    } else {
      if (!fields.includes(name2)) {
        setObj(result, name2, getObj(obj2, name2), isMerge2);
      }
    }
  };
  var innerCopyFields = function innerCopyFields2(obj2, fields2, isMerge2, isExclude2) {
    var result = {};
    if (isExclude2) {
      each(obj2, function(name2) {
        return fields2.forEach(function(key) {
          return setValue(obj2, result, name2, key, isMerge2);
        });
      });
    } else {
      fields2.forEach(function(field) {
        return setObj(result, field, getObj(obj2, field), isMerge2);
      });
    }
    return result;
  };
  if (isPlainObject(data3)) {
    return Array.isArray(fields) ? innerCopyFields(data3, fields, isMerge, isExclude) : extend$2(isMerge !== false, {}, data3);
  }
  return data3;
};
var copyArray = function copyArray2(arr) {
  return Array.isArray(arr) ? arr.map(function(item) {
    return copyField(item);
  }) : arr;
};
var deepCopy$1 = function deepCopy$12(target, name2, deep, copy, src) {
  var copyIsArray;
  if (deep && copy && (isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {
    if (copyIsArray) {
      copyIsArray = false;
      target[name2] = copyArray(copy);
    } else {
      var clone = src && isPlainObject(src) ? src : {};
      target[name2] = extend$2(deep, clone, copy);
    }
  } else if (copy !== void 0) {
    try {
      target[name2] = copy;
    } catch (e) {
    }
  }
};
extend$2 = function extend$22() {
  var args = arguments;
  var length = args.length;
  var target = args[0] || {};
  var i = 1;
  var deep = false;
  if (typeOf$1(target) === "boolean") {
    deep = target;
    target = args[i] || {};
    i++;
  }
  if (!isObject$1(target) && typeOf$1(target) !== "function") {
    target = {};
  }
  if (i === length) {
    target = this;
    i--;
  }
  for (; i < length; i++) {
    var _options = args[i];
    if (_options !== null && isObject$1(_options)) {
      var names = Object.keys(_options);
      for (var _i = 0, _names = names; _i < _names.length; _i++) {
        var _name3 = _names[_i];
        var src = target[_name3];
        var copy = _options[_name3];
        if (target !== copy) {
          deepCopy$1(target, _name3, deep, copy, src);
        }
      }
    }
  }
  return target;
};
var ABBR = {
  th: 3,
  mi: 6,
  bi: 9,
  tr: 12
};
var abbrLabel = {
  th: "k",
  mi: "m",
  bi: "b",
  tr: "t"
};
var DEFAULT_OPTIONS = {
  zeroFormat: null,
  nullFormat: null,
  defaultFormat: "0,0",
  scalePercentBy100: true,
  abbrLabel
};
var TRILLION = 1e12, BILLION = 1e9, MILLION = 1e6, THOUSAND = 1e3;
var numIsNaN = function numIsNaN2(value) {
  return typeof value === "number" && isNaN(value);
};
var options = {};
var formats = {};
function getBoundedPrecision(value, maxDecimals, optionals) {
  var splitValue = value.toString().split("e-");
  var exponent = splitValue.length === 2 ? Number(splitValue[1]) : 0;
  splitValue = splitValue[0].split(".");
  exponent = splitValue.length === 2 ? splitValue[1].length + exponent : exponent;
  var minDecimals = maxDecimals - (optionals || 0);
  return Math.min(Math.max(exponent, minDecimals), maxDecimals);
}
function toFixed(value, maxDecimals, roundingFunction, optionals) {
  var boundedPrecision = getBoundedPrecision(value, maxDecimals, optionals);
  var power = Math.pow(10, boundedPrecision);
  var output = (roundingFunction(value * ("1e+" + boundedPrecision)) / power).toFixed(boundedPrecision);
  if (optionals > maxDecimals - boundedPrecision) {
    var optionalsRegExp = new RegExp("\\.?0{1," + (optionals - (maxDecimals - boundedPrecision)) + "}$");
    output = output.replace(optionalsRegExp, "");
  }
  return output;
}
function judgForFunc(num, abs, abbrForce) {
  var flag;
  if (num === 0) {
    flag = abs >= TRILLION && !abbrForce || abbrForce === "t";
  } else if (num === 1) {
    flag = abs < TRILLION && abs >= BILLION && !abbrForce || abbrForce === "b";
  } else if (num === 2) {
    flag = abs < BILLION && abs >= MILLION && !abbrForce || abbrForce === "m";
  } else if (num === 3) {
    flag = abs < MILLION && abs >= THOUSAND && !abbrForce || abbrForce === "k";
  }
  return flag;
}
var negativeSigned = function negativeSigned2(_ref) {
  var format3 = _ref.format, value = _ref.value;
  return ~format3.indexOf("+") ? format3.indexOf("+") : value < 0 ? format3.indexOf("-") : -1;
};
var updateAbbrV = function updateAbbrV2(params) {
  var abbr = params.abbr, abbrForce = params.abbrForce, format3 = params.format, value = params.value, abs = params.abs;
  abbrForce = format3.match(/a(k|m|b|t)?/);
  abbrForce = abbrForce ? abbrForce[1] : false;
  if (~format3.indexOf(" a")) {
    abbr = " ";
  }
  format3 = format3.replace(new RegExp(abbr + "a[kmbt]?"), "");
  if (judgForFunc(0, abs, abbrForce)) {
    abbr += options.abbrLabel.tr;
    value = value / TRILLION;
  } else if (judgForFunc(1, abs, abbrForce)) {
    abbr += options.abbrLabel.bi;
    value = value / BILLION;
  } else if (judgForFunc(2, abs, abbrForce)) {
    abbr += options.abbrLabel.mi;
    value = value / MILLION;
  } else if (judgForFunc(3, abs, abbrForce)) {
    abbr += options.abbrLabel.th;
    value = value / THOUSAND;
  }
  Object.assign(params, {
    abbr,
    abbrForce,
    format: format3,
    value,
    abs
  });
};
var handlePrecision = function handlePrecision2(params) {
  var roundingFunction = params.roundingFunction, value = params.value, format3 = params.format;
  var number = value.toString().split(".")[0];
  var precision = format3.split(".")[1];
  if (precision) {
    if (~precision.indexOf("[")) {
      precision = precision.replace("]", "");
      precision = precision.split("[");
      params.decimal = toFixed(value, precision[0].length + precision[1].length, roundingFunction, precision[1].length);
    } else {
      params.decimal = toFixed(value, precision.length, roundingFunction);
    }
    number = params.decimal.split(".")[0];
    params.decimal = ~params.decimal.indexOf(".") ? "." + params.decimal.split(".")[1] : "";
    if (params.optDec && Number(params.decimal.slice(1)) === 0) {
      params.decimal = "";
    }
  } else {
    number = toFixed(value, 0, roundingFunction);
  }
  return number;
};
function formatNumber(params) {
  var number = handlePrecision(params);
  var thousands = params.format.indexOf(",");
  var leadingCount = (params.format.split(".")[0].split(",")[0].match(/0/g) || []).length;
  if (params.abbr && !params.abbrForce && Number(number) >= 1e3 && params.abbr !== ABBR.trillion) {
    number = String(Number(number) / 1e3);
    params.abbr = ABBR.million;
  }
  if (~number.indexOf("-")) {
    number = number.slice(1);
    params.neg = true;
  }
  if (number.length < leadingCount) {
    for (var i = leadingCount - number.length; i > 0; i--) {
      number = "0" + number;
    }
  }
  if (thousands > -1) {
    number = number.toString().replace(/(\d)(?=(\d{3})+(?!\d))/g, "$1,");
  }
  if (!params.format.indexOf(".")) {
    number = "";
  }
  return number;
}
function getOutStr(_ref2, number) {
  var decimal = _ref2.decimal, negFlag = _ref2.negFlag, neg = _ref2.neg, signed = _ref2.signed, abbr = _ref2.abbr;
  var outStr = number + decimal + (abbr || "");
  if (negFlag) {
    outStr = negFlag && neg ? "(" + outStr + ")" : outStr;
  } else {
    if (signed >= 0) {
      var symbol = neg ? "-" : "+";
      outStr = signed === 0 ? symbol + outStr : outStr + symbol;
    } else if (neg) {
      outStr = "-" + outStr;
    }
  }
  return outStr;
}
function numberToFormat(options2, value, format3, roundingFunction) {
  var params = {
    abs: Math.abs(value),
    negFlag: false,
    optDec: false,
    abbr: "",
    decimal: "",
    neg: false,
    abbrForce: void 0,
    signed: void 0,
    format: format3 || "",
    value: value || 0,
    roundingFunction
  };
  if (~format3.indexOf("(")) {
    params.negFlag = true;
    params.format = format3.replace(/[(|)]/g, "");
  } else if (~params.format.indexOf("+") || ~params.format.indexOf("-")) {
    params.signed = negativeSigned(params);
    params.format = format3.replace(/[+|-]/g, "");
  }
  if (~params.format.indexOf("a")) {
    updateAbbrV(params);
  }
  if (~params.format.indexOf("[.]")) {
    params.optDec = true;
    params.format = format3.replace("[.]", ".");
  }
  var number = formatNumber(params);
  return getOutStr(params, number);
}
function extend$1(target, sub) {
  Object.keys(sub).forEach(function(key) {
    target[key] = sub[key];
  });
}
var numerifyPercent = {
  regexp: /%/,
  format: function format(value, formatType, roundingFunction, numerify22) {
    var space2 = ~formatType.indexOf(" %") ? " " : "";
    var outStr = void 0;
    if (numerify22.options.scalePercentBy100) {
      value = value * 100;
    }
    formatType = formatType.replace(/\s?%/, "");
    outStr = numerify22._numberToFormat(value, formatType, roundingFunction);
    if (~outStr.indexOf(")")) {
      outStr = outStr.split("");
      outStr.splice(-1, 0, space2 + "%");
      outStr = outStr.join("");
    } else {
      outStr = outStr + space2 + "%";
    }
    return outStr;
  }
};
extend$1(options, DEFAULT_OPTIONS);
var numerify;
function format2(value, formatType, roundingFunc) {
  var zeroFormat = options.zeroFormat, nullFormat = options.nullFormat, defaultFormat = options.defaultFormat;
  formatType = formatType || defaultFormat;
  roundingFunc = roundingFunc || Math.round;
  var _ref3 = {}, output = _ref3.output, fmtFunc = _ref3.fmtFunc;
  if (value === 0 && zeroFormat !== null) {
    output = zeroFormat;
  } else if (value === null && nullFormat !== null) {
    output = nullFormat;
  } else {
    for (var key in formats) {
      if (formats[key] && formatType.match(formats[key].regexp)) {
        fmtFunc = formats[key].format;
        break;
      }
    }
    fmtFunc = fmtFunc || numberToFormat.bind(null, options);
    output = fmtFunc(value, formatType, roundingFunc, numerify);
  }
  return output;
}
numerify = function numerify2(input, formatType, roundingFunc) {
  var zeroFormat = options.zeroFormat, nullFormat = options.nullFormat;
  var value = Number(input) || null;
  if (typeof input === "undefined" || input === 0) {
    value = 0;
  } else if (numIsNaN(input) || input === null) {
    value = null;
  } else if (typeof input === "string") {
    value = Number(input);
    if (input === zeroFormat && zeroFormat) {
      value = 0;
    } else if (input === nullFormat && nullFormat || !input.replace(/[^0-9]+/g, "").length) {
      value = null;
    }
  }
  return format2(value, formatType, roundingFunc);
};
var _register = function _register2(name2, format3) {
  formats[name2] = format3;
};
var _unregister = function _unregister2(name2) {
  formats[name2] = null;
};
var _setOptions = function _setOptions2(opts) {
  extend$1(options, opts);
};
var _reset = function _reset2() {
  extend$1(options, DEFAULT_OPTIONS);
};
numerify.options = options;
numerify._numberToFormat = numberToFormat.bind(null, options);
numerify.register = _register;
numerify.unregister = _unregister;
numerify.setOptions = _setOptions;
numerify.reset = _reset;
numerify.register("percentage", numerifyPercent);
var _numerify = numerify;
var matchHtmlRegExp$1 = /["'&<>/]/;
function escapeHtml$1(string) {
  var str = "" + string;
  var match = matchHtmlRegExp$1.exec(str);
  if (!match) {
    return str;
  }
  var escape;
  var html = "";
  var index;
  var lastIndex = 0;
  for (index = match.index; index < str.length; index++) {
    switch (str.charCodeAt(index)) {
      case 34:
        escape = "&quot;";
        break;
      case 38:
        escape = "&amp;";
        break;
      case 39:
        escape = "&#x27;";
        break;
      case 60:
        escape = "&lt;";
        break;
      case 62:
        escape = "&gt;";
        break;
      case 47:
        escape = "&#x2F;";
        break;
      default:
        continue;
    }
    if (lastIndex !== index) {
      html += str.substring(lastIndex, index);
    }
    lastIndex = index + 1;
    html += escape;
  }
  return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
}
var $prefix = "Tiny";
var getFormatted = function getFormatted2(value, type, digit, defaultVal) {
  if (defaultVal === void 0) {
    defaultVal = "-";
  }
  if (typeof value === "object") {
    value = value.value;
  }
  if (isNaN(value)) {
    return defaultVal;
  }
  if (!type) {
    return value;
  }
  if (typeOf$1(type) === "function") {
    return type(value, _numerify);
  }
  digit = !isNaN(digit) ? ++digit : 0;
  var digitStr = ".[" + new Array(digit).join(0) + "]";
  var formatter4 = type;
  if (type === "KMB") {
    formatter4 = digit ? "0,0" + digitStr + "a" : "0,0a";
  } else if (type === "normal") {
    formatter4 = digit ? "0,0" + digitStr : "0,0";
  } else if (type === "percent") {
    formatter4 = digit ? "0,0" + digitStr + "%" : "0,0.[00]%";
  }
  return _numerify(value, formatter4);
};
var cloneDeep$1 = function cloneDeep$12(data3) {
  if (isObject$1(data3)) {
    return extend(true, data3);
  }
  if (Array.isArray(data3)) {
    return copyArray(data3);
  }
  return data3;
};
var getStackMap = function getStackMap2(stack) {
  var result = {};
  Object.keys(stack).forEach(function(item) {
    stack[item].forEach(function(name2) {
      result[name2] = item;
    });
  });
  return result;
};
var merge$1 = function merge$12(source, other) {
  if (typeof source !== "object" || typeof other !== "object") {
    return other === void 0 ? source : other;
  }
  return Object.keys(_extends({}, source, other)).reduce(function(acc, key) {
    acc[key] = merge$12(source[key], other[key]);
    return acc;
  }, Array.isArray(source) ? [] : {});
};
var mapPromise = {};
var getMapJSON = function getMapJSON2(_ref4) {
  var position2 = _ref4.position, positionJsonLink = _ref4.positionJsonLink, beforeRegisterMapOnce = _ref4.beforeRegisterMapOnce, _ref4$mapURLProfix = _ref4.mapURLProfix, mapURLProfix = _ref4$mapURLProfix === void 0 ? "" : _ref4$mapURLProfix;
  var link = positionJsonLink || "" + mapURLProfix + position2 + ".json";
  if (!mapPromise[link]) {
    mapPromise[link] = $get(link).then(function(res) {
      if (beforeRegisterMapOnce) {
        res = beforeRegisterMapOnce(res);
      }
      return res;
    });
  }
  return mapPromise[link];
};
var htmlHandler = function htmlHandler2(data3) {
  if (!data3 || !Array.isArray(data3)) {
    return data3;
  }
  return cloneDeep$1(data3).map(function(item) {
    if (typeof item === "string" && /<[a-z]+/i.test(item)) {
      return escapeHtml$1(item);
    }
    if (typeof item === "object") {
      for (var key in item) {
        if (typeof item[key] === "string" && /<[a-z]+/i.test(item[key])) {
          item[key] = escapeHtml$1(item[key]);
        }
      }
      return item;
    }
    return item;
  });
};
function cloneDeep(obj2) {
  var objClone = Array.isArray(obj2) ? [] : {};
  if (obj2 && typeof obj2 === "object") {
    for (var key in obj2) {
      if (obj2[key] && typeof obj2[key] === "object") {
        objClone[key] = cloneDeep(obj2[key]);
      } else {
        objClone[key] = obj2[key];
      }
    }
  }
  return objClone;
}
var isArr = Array.isArray;
function removeNullKeys(obj2) {
  if (typeof obj2 !== "object" || obj2 === null) {
    return obj2;
  }
  for (var key in obj2) {
    if (obj2[key] === null) {
      delete obj2[key];
    } else {
      obj2[key] = removeNullKeys(obj2[key]);
      if (typeof obj2[key] === "object" && Object.keys(obj2[key]).length === 0) {
        obj2[key] = void 0;
      }
    }
  }
  return obj2;
}
var setExtend = function setExtend2(_ref5) {
  var option = _ref5.option, extend2 = _ref5.extend;
  var cloneOption = cloneDeep(option);
  var mergeOption = removeNullKeys(cloneOption);
  if (!extend2) {
    return;
  }
  Object.keys(extend2).forEach(function(key) {
    var value = extend2[key];
    if (~key.indexOf(".")) {
      setObj(mergeOption, key, value);
    } else if (typeof value === "function") {
      mergeOption[key] = value(mergeOption[key]);
    } else if (isArr(mergeOption[key]) && isArr(value)) {
      var attrList = ["series", "yAxis", "xAxis", "color", "dataZoom", "legend", "toolbox", "grid", "graphic", "timeline", "visualMap", "brush"];
      if (~attrList.indexOf(key)) {
        mergeOption[key] = merge$1(mergeOption[key], value);
      }
    } else {
      if (isArr(mergeOption[key]) && isObject$1(mergeOption[key][0])) {
        mergeOption[key].forEach(function(option2, i) {
          return mergeOption[key][i] = _extends({}, option2, value);
        });
      } else if (isObject$1(mergeOption[key])) {
        var optionBase = mergeOption[key];
        mergeOption[key] = _extends({}, optionBase, value);
      } else {
        mergeOption[key] = value;
      }
    }
  });
  var series = mergeOption.series;
  if (series) {
    if (Array.isArray(series)) {
      mergeOption.series = series.map(function(item) {
        if (getObj(item, "type") === "line" && getObj(item, "label.show")) {
          item.showSymbol = true;
        }
        return item;
      });
    } else {
      mergeOption.series.label = _extends({
        show: false
      }, mergeOption.series.label);
    }
  }
  return mergeOption;
};
var SF = function SF2() {
  return {
    show: false
  };
};
var DEFAULT_THEME = {
  categoryAxis: {
    axisLine: SF(),
    axisTick: SF(),
    splitLine: SF()
  },
  valueAxis: {
    axisLine: SF()
  },
  line: {
    smooth: true
  },
  grid: {
    containLabel: true,
    left: 10,
    right: 10
  }
};
var DEFAULT_COLORS = ["#19d4ae", "#5ab1ef", "#fa6e86", "#ffb980", "#0067a6", "#c4b4e4", "#d87a80", "#9cbbff", "#d9d0c7", "#87a997", "#d49ea2", "#5b4947", "#7ba3a8"];
var HEAT_MAP_COLOR = ["#5990FD", "#2DA769", "#EEBA18", "#F43146"];
var _SAAS_DEFAULT_COLORS1 = ["#2070F3", "#00A874", "#745EF7", "#8BC2FF", "#1B3F86", "#FDC000", "#00A2B5"];
var _SAAS_DEFAULT_COLORS2 = ["#FC916E", "#1F55B5", "#2D94FF", "#82DBB1", "#F36900", "#2A8290", "#EE8DDB"];
var _SAAS_DEFAULT_COLORS3 = ["#278661", "#4FA700", "#5CACFF", "#9185F0", "#B62BF7", "#26616B", "#F46465"];
var _SAAS_DEFAULT_COLORS4 = ["#5531EB", "#FCDBAA", "#112857", "#E61866", "#B98C1D", "#D41DBC", "#87D5E5"];
var SAAS_DEFAULT_COLORS = _SAAS_DEFAULT_COLORS1.concat(_SAAS_DEFAULT_COLORS2).concat(_SAAS_DEFAULT_COLORS3).concat(_SAAS_DEFAULT_COLORS4);
var SAAS_DEFAULT_SAME_COLORS = {
  blue: [{
    color: "#2E94FF",
    idx: 3
  }, {
    color: "#8BC3FF",
    idx: 5
  }, {
    color: "#1F55B5",
    idx: 1
  }, {
    color: "#2070F3",
    idx: 2
  }, {
    color: "#5CACFF",
    idx: 4
  }, {
    color: "#B9DBFF",
    idx: 6
  }, {
    color: "#1B3F86",
    idx: 0
  }],
  green: [{
    color: "#00A874",
    idx: 3
  }, {
    color: "#82DBB1",
    idx: 5
  }, {
    color: "#236549",
    idx: 1
  }, {
    color: "#278661",
    idx: 2
  }, {
    color: "#50C291",
    idx: 4
  }, {
    color: "#AFEDCE",
    idx: 6
  }, {
    color: "#1D4A37",
    idx: 0
  }]
};
var itemPoint = function itemPoint2(color3) {
  return ['<span style="', "background-color:" + color3 + ";", "display: inline-block;", "width: 6px;", "height: 6px;", "border-radius: 50%;", "margin-right:8px;", "vertical-align:middle;", '"></span>'].join("");
};
var itemLabel = function itemLabel2(seriesName, onlyLabel) {
  return ['<span style="', "display:inline-block;", "font-size:12px;", "color:#4E4E4E;", onlyLabel ? "" : "margin-right:25px;", '">' + seriesName + "</span>"].join("");
};
var itemContent = function itemContent2(content) {
  return ['<span style="', "float:right;", "font-size:14px;", "color:#191919;", '">' + content + "</span>"].join("");
};
var packageName = "HUI-Charts";
function warn(tip) {
  console.warn("[" + packageName + "] Warning: " + tip);
}
function error(tip) {
  console.error("[" + packageName + "] Error: " + tip);
}
var tips = {
  warn,
  error
};
function isArray(value) {
  return Object.prototype.toString.call(value) === "[object Array]";
}
var isObject = function isObject2(value) {
  return value !== null && typeof value === "object";
};
var isFunction = function isFunction2(value) {
  return typeof value === "function";
};
var isString = function isString2(value) {
  return typeof value === "string";
};
var isNumber = function isNumber2(value) {
  return typeof value === "number";
};
var isDOM = typeof HTMLElement === "object" ? function(dom) {
  return dom instanceof HTMLElement;
} : function(dom) {
  return dom && typeof obj === "object" && obj.nodeType === 1 && typeof obj.nodeName === "string";
};
var toArray = function toArray2(value) {
  if (!isArray(value)) {
    return [value];
  } else {
    return value;
  }
};
function merge(target, task) {
  if (!target) {
    target = task;
    return target;
  }
  if (isObject(task)) {
    for (var key in task) {
      if (target[key] === void 0 || target[key] === null) {
        target[key] = task[key];
      } else if (isObject(task[key]) && !isArray(task[key])) {
        merge(target[key], task[key]);
      } else {
        target[key] = task[key];
      }
    }
  }
  return target;
}
function mergeSeries(iChartOption, baseOption2) {
  var userSeries = iChartOption.series;
  var baseSeries = baseOption2.series;
  userSeries && userSeries.forEach(function(uitem) {
    var isNewSeries = true;
    baseSeries.forEach(function(bitem) {
      if (bitem.name === uitem.name) {
        isNewSeries = false;
        merge(bitem, uitem);
      }
    });
    if (isNewSeries) {
      baseSeries.push(uitem);
    }
  });
}
function mergeVisualMap(iChartOption, baseOption2) {
  var userVisualMap = iChartOption.visualMap;
  if (userVisualMap) {
    baseOption2.visualMap = userVisualMap;
  }
}
function mergeExtend(iChartOption, baseOption2) {
  if (!iChartOption)
    return;
  var extend2 = iChartOption.extend;
  if (!extend2)
    return;
  for (var key in extend2) {
    if (Object.hasOwnProperty.call(extend2, key)) {
      baseOption2[key] = extend2[key];
    }
  }
}
var THEMES = {
  DARK: "dark",
  LIGHT: "light",
  BPIT_LIGHT: "bpit-light",
  BPIT_DARK: "bpit-dark",
  CLOUD_DARK: "cloud-dark",
  CLOUD_LIGHT: "cloud-light",
  HDESIGN_LIGHT: "hdesign-light",
  HDESIGN_DARK: "hdesign-dark"
};
var CURRENT_THEME = Symbol("current_theme");
var TOKENCHARTNAMES = ["AssembleBubbleChart", "BarChart", "BoxplotChart", "BubbleChart", "CandlestickChart", "CircleProcessChart", "FunnelChart", "GaugeChart", "HeatMapChart", "HillChart", "JadeJueChart", "LineChart", "AreaChart", "LiquidfillChart", "PieChart", "PolarBarChart", "ProcessChart", "RadarChart", "RegionChart", "SankeyChart", "SunburstChart", "TreeChart", "WaveChart", "WordCloudChart"];
var DEFAULT_THEME_NAME = THEMES.CLOUD_LIGHT;
var THEME_ERROR_TIP_MESSAGE = "Theme must be one of " + Object.values(THEMES).join(",") + " or the theme name registered for calling HuiCharts.registerTheme()";
var rose$2 = {
  colorRose5: "#F9F2F3",
  colorRose10: "#F3DADE",
  colorRose20: "#EFBCC5",
  colorRose30: "#EF93A7",
  colorRose40: "#F46087",
  colorRose50: "#E61866",
  colorRose60: "#AD184D",
  colorRose70: "#811439",
  colorRose80: "#540D24",
  colorRose90: "#330614"
};
var red$2 = {
  colorRed5: "#F9F2F2",
  colorRed10: "#F3DADA",
  colorRed20: "#F0BDBD",
  colorRed30: "#F09596",
  colorRed40: "#F46465",
  colorRed50: "#EB171F",
  colorRed60: "#B2161B",
  colorRed70: "#841316",
  colorRed80: "#570C0D",
  colorRed90: "#350506"
};
var orange$2 = {
  colorOrange5: "#FDF1EF",
  colorOrange10: "#FCD8CE",
  colorOrange20: "#FABAAA",
  colorOrange30: "#FC916E",
  colorOrange40: "#F36900",
  colorOrange50: "#C45613",
  colorOrange60: "#944114",
  colorOrange70: "#6E3011",
  colorOrange80: "#471E0B",
  colorOrange90: "#2B1005"
};
var yellow$2 = {
  colorYellow5: "#FDF2E5",
  colorYellow10: "#FCDBAA",
  colorYellow20: "#FDC000",
  colorYellow30: "#DAA61B",
  colorYellow40: "#B98C1D",
  colorYellow50: "#96711B",
  colorYellow60: "#715516",
  colorYellow70: "#543F0F",
  colorYellow80: "#362807",
  colorYellow90: "#201603"
};
var green$2 = {
  colorGreen5: "#EEF6EB",
  colorGreen10: "#BCEDAC",
  colorGreen20: "#97DA7E",
  colorGreen30: "#71C14C",
  colorGreen40: "#4FA700",
  colorGreen50: "#478625",
  colorGreen60: "#376422",
  colorGreen70: "#2A4A1C",
  colorGreen80: "#1A2F12",
  colorGreen90: "#0F1B0A"
};
var mint$2 = {
  colorMint5: "#ECF6F1",
  colorMint10: "#AFEDCE",
  colorMint20: "#82DBB1",
  colorMint30: "#50C291",
  colorMint40: "#00A874",
  colorMint50: "#278661",
  colorMint60: "#236549",
  colorMint70: "#1D4A37",
  colorMint80: "#1B2B21",
  colorMint90: "#0B1B13"
};
var cyan$1 = {
  colorCyan5: "#EFF4F6",
  colorCyan10: "#C6E5EC",
  colorCyan20: "#87D5E5",
  colorCyan30: "#54BCCE",
  colorCyan40: "#00A2B5",
  colorCyan50: "#2A8290",
  colorCyan60: "#26616B",
  colorCyan70: "#1F484F",
  colorCyan80: "#152E32",
  colorCyan90: "#0C1A1C"
};
var blue$2 = {
  colorBlue5: "#F4F3F9",
  colorBlue10: "#DBDFF2",
  colorBlue20: "#BFC8EE",
  colorBlue30: "#99ABED",
  colorBlue40: "#6D8FF0",
  colorBlue50: "#2070F3",
  colorBlue60: "#1F55B5",
  colorBlue70: "#1B3F86",
  colorBlue80: "#112857",
  colorBlue90: "#081635"
};
var indigo$2 = {
  colorIndigo5: "#F3F3F9",
  colorIndigo10: "#DFDEF2",
  colorIndigo20: "#C9C5EE",
  colorIndigo30: "#ADA6ED",
  colorIndigo40: "#9185F0",
  colorIndigo50: "#745EF7",
  colorIndigo60: "#5531EB",
  colorIndigo70: "#3F21B5",
  colorIndigo80: "#281675",
  colorIndigo90: "#160B48"
};
var purple$2 = {
  colorPurple5: "#F6F2F9",
  colorPurple10: "#E7DBF2",
  colorPurple20: "#D8C0EE",
  colorPurple30: "#C99CED",
  colorPurple40: "#BD72F0",
  colorPurple50: "#B62BF7",
  colorPurple60: "#8A21BC",
  colorPurple70: "#651B8B",
  colorPurple80: "#41125A",
  colorPurple90: "#260937"
};
var pink$2 = {
  colorPink5: "#F9F1F7",
  colorPink10: "#F2D8EC",
  colorPink20: "#EFB9E3",
  colorPink30: "#EE8DDB",
  colorPink40: "#F14FD8",
  colorPink50: "#D41DBC",
  colorPink60: "#9F1C8D",
  colorPink70: "#751868",
  colorPink80: "#4C0F43",
  colorPink90: "#2E0728"
};
var gray$a = {
  colorGray0: "#FFFFFF",
  colorGray5: "#F5F5F5",
  colorGray10: "#EEEEEE",
  colorGray20: "#BBBBBB",
  colorGray30: "#939393",
  colorGray40: "#818181",
  colorGray50: "#676767",
  colorGray60: "#4E4E4E",
  colorGray70: "#393939",
  colorGray80: "#272727",
  colorGray90: "#191919",
  colorGray100: "#000000"
};
var transparent$2 = {
  colorTransparent: "transparent"
};
var board$4 = {
  red: red$2,
  rose: rose$2,
  mint: mint$2,
  cyan: cyan$1,
  blue: blue$2,
  pink: pink$2,
  gray: gray$a,
  green: green$2,
  orange: orange$2,
  yellow: yellow$2,
  indigo: indigo$2,
  purple: purple$2,
  transparent: transparent$2
};
var board$5 = board$4;
function getThemeColor(gray2, colorState2, colorGroup2) {
  return {
    grayScale: _extends({}, gray2),
    colorSet: {
      colorState: colorState2,
      colorGroup: colorGroup2
    }
  };
}
function getColorGroup(colorChart2) {
  return Object.values(colorChart2);
}
var gray$9 = _extends({}, board$5.gray, board$5.transparent);
var colorState$7 = {
  // 紧急色
  colorError: "#F43146",
  // 重要告警色
  colorAlert: "#EC6F1A",
  // 次要告警色
  colorWarning: "#EEBA18",
  // 成功色
  colorSuccess: "#2DA769",
  // 提示色
  colorInfo: "#5990FD",
  // 失效
  colorNone: board$5.gray.colorGray30
};
var colorChart$7 = {
  colorChart1: board$5.blue.colorBlue40,
  colorChart2: board$5.mint.colorMint40,
  colorChart3: board$5.purple.colorPurple40,
  colorChart4: board$5.cyan.colorCyan30,
  colorChart5: board$5.yellow.colorYellow20,
  colorChart6: board$5.indigo.colorIndigo40,
  colorChart7: board$5.cyan.colorCyan40
};
var colorGroup$7 = getColorGroup(colorChart$7);
var light$6 = getThemeColor(gray$9, colorState$7, colorGroup$7);
var light$7 = light$6;
var gray$8 = _extends({}, board$5.gray, board$5.transparent);
var colorState$6 = {
  // 紧急色
  colorError: "#F43146",
  // 重要告警色
  colorAlert: "#EC6F1A",
  // 次要告警色
  colorWarning: "#EEBA18",
  // 成功色
  colorSuccess: "#0D9458",
  // 提示色
  colorInfo: "#5990FD",
  // 失效
  colorNone: "#818181"
};
var colorChart$6 = {
  colorChart1: board$5.blue.colorBlue60,
  colorChart2: board$5.mint.colorMint50,
  colorChart3: board$5.purple.colorPurple60,
  colorChart4: board$5.cyan.colorCyan60,
  colorChart5: board$5.yellow.colorYellow40,
  colorChart6: board$5.indigo.colorIndigo50,
  colorChart7: board$5.cyan.colorCyan50
};
var colorGroup$6 = getColorGroup(colorChart$6);
var dark$6 = getThemeColor(gray$8, colorState$6, colorGroup$6);
var dark$7 = dark$6;
var ict = {
  light: light$7,
  dark: dark$7
};
var ict$1 = ict;
var rose$1 = {
  colorRose5: "#FEE5F2",
  colorRose10: "#FCC3E0",
  colorRose20: "#F99AC7",
  colorRose30: "#F470AB",
  colorRose40: "#ED448A",
  colorRose50: "#E61866",
  colorRose60: "#C40054",
  colorRose70: "#811439",
  colorRose80: "#540D24",
  colorRose90: "#330614"
};
var red$1 = {
  colorRed5: "#FEE7E8",
  colorRed10: "#FABDC1",
  colorRed20: "#F59297",
  colorRed30: "#EE696F",
  colorRed40: "#E7434A",
  colorRed50: "#E02128",
  colorRed60: "#C7000B",
  colorRed70: "#850F12",
  colorRed80: "#59080A",
  colorRed90: "#350305"
};
var orange$1 = {
  colorOrange5: "#FEF5E8",
  colorOrange10: "#FDE2BD",
  colorOrange20: "#FCCE92",
  colorOrange30: "#F9B766",
  colorOrange40: "#F69E39",
  colorOrange50: "#F4840C",
  colorOrange60: "#C76207",
  colorOrange70: "#954304",
  colorOrange80: "#642802",
  colorOrange90: "#3D1601"
};
var yellow$1 = {
  colorYellow5: "#FEFCE0",
  colorYellow10: "#FEF8B8",
  colorYellow20: "#FEF08A",
  colorYellow30: "#FDE55C",
  colorYellow40: "#FCD72E",
  colorYellow50: "#FCC800",
  colorYellow60: "#D19F00",
  colorYellow70: "#9E7400",
  colorYellow80: "#614500",
  colorYellow90: "#2E1F00"
};
var green$1 = {
  colorGreen5: "#F2FBE9",
  colorGreen10: "#DFF4CC",
  colorGreen20: "#C6E9A8",
  colorGreen30: "#A8DB81",
  colorGreen40: "#87C859",
  colorGreen50: "#62B42E",
  colorGreen60: "#488E20",
  colorGreen70: "#316614",
  colorGreen80: "#1B3E0A",
  colorGreen90: "#0C2004"
};
var mint$1 = {
  colorMint5: "#E7FBF2",
  colorMint10: "#BCF2DB",
  colorMint20: "#8FE5C2",
  colorMint30: "#63D5A8",
  colorMint40: "#36C18D",
  colorMint50: "#09AA71",
  colorMint60: "#058358",
  colorMint70: "#036142",
  colorMint80: "#02422E",
  colorMint90: "#00291D"
};
var cyan = {
  colorCyan5: "#E8FCFD",
  colorCyan10: "#C9F6F9",
  colorCyan20: "#A4ECF1",
  colorCyan30: "#7DDFE7",
  colorCyan40: "#55CCD9",
  colorCyan50: "#2CB8C9",
  colorCyan60: "#1C94A4",
  colorCyan70: "#127180",
  colorCyan80: "#094C57",
  colorCyan90: "#04282F"
};
var blue$1 = {
  colorBlue5: "#EEF3FE",
  colorBlue10: "#D0D8FD",
  colorBlue20: "#B0BFFD",
  colorBlue30: "#8CA3FA",
  colorBlue40: "#668CF7",
  colorBlue50: "#2070F3",
  colorBlue60: "#1F55B5",
  colorBlue70: "#1B3F86",
  colorBlue80: "#112857",
  colorBlue90: "#081635"
};
var indigo$1 = {
  colorIndigo5: "#EEEEFE",
  colorIndigo10: "#D5D3FD",
  colorIndigo20: "#BFB9FA",
  colorIndigo30: "#A89FF9",
  colorIndigo40: "#8E81F4",
  colorIndigo50: "#715AFB",
  colorIndigo60: "#5531EB",
  colorIndigo70: "#3F21B5",
  colorIndigo80: "#281675",
  colorIndigo90: "#160B48"
};
var purple$1 = {
  colorPurple5: "#F7EDFE",
  colorPurple10: "#E8CFFE",
  colorPurple20: "#D9B1FD",
  colorPurple30: "#CB8EFB",
  colorPurple40: "#BF68FA",
  colorPurple50: "#B62BF7",
  colorPurple60: "#8A21BC",
  colorPurple70: "#651B8B",
  colorPurple80: "#41125A",
  colorPurple90: "#260937"
};
var pink$1 = {
  colorPink5: "#FDE6FC",
  colorPink10: "#F9C5F6",
  colorPink20: "#F39DEC",
  colorPink30: "#EB74DF",
  colorPink40: "#E049CE",
  colorPink50: "#D41DBC",
  colorPink60: "#9F1C8D",
  colorPink70: "#751868",
  colorPink80: "#4C0F43",
  colorPink90: "#2E0728"
};
var brand = {
  colorBrand5: "#E6F2FD",
  colorBrand10: "#B8D9F9",
  colorBrand20: "#8ABEF3",
  colorBrand30: "#5CA2E9",
  colorBrand40: "#2E86DE",
  colorBrand50: "#0067D1",
  colorBrand60: "#004EA8",
  colorBrand70: "#003D83",
  colorBrand80: "#002E6A",
  colorBrand90: "#00214B"
};
var gray$7 = {
  colorGray0: "#FFFFFF",
  colorGray5: "#F3F3F3",
  colorGray10: "#DFDFDF",
  colorGray20: "#C9C9C9",
  colorGray30: "#AEAEAE",
  colorGray40: "#939393",
  colorGray50: "#777777",
  colorGray60: "#595959",
  colorGray70: "#393939",
  colorGray80: "#2A2A2A",
  colorGray90: "#191919",
  colorGray100: "#000000"
};
var transparent$1 = {
  colorTransparent: "transparent"
};
var board$2 = {
  red: red$1,
  rose: rose$1,
  mint: mint$1,
  cyan,
  blue: blue$1,
  pink: pink$1,
  gray: gray$7,
  green: green$1,
  brand,
  orange: orange$1,
  yellow: yellow$1,
  indigo: indigo$1,
  purple: purple$1,
  transparent: transparent$1
};
var board$3 = board$2;
var gray$6 = _extends({}, board$3.gray, board$3.transparent);
var colorState$5 = {
  // 错误色
  colorError: board$3.red.colorRed50,
  // 告警色
  colorAlert: board$3.orange.colorOrange50,
  // 提醒色
  colorWarning: board$3.yellow.colorYellow50,
  // 成功色
  colorSuccess: board$3.mint.colorMint50,
  // 信息色
  colorInfo: board$3.blue.colorBlue50,
  // 失效色
  colorNone: board$3.gray.colorGray30
};
var colorChart$5 = {
  colorChart1: board$3.blue.colorBlue50,
  colorChart2: board$3.cyan.colorCyan40,
  colorChart3: board$3.indigo.colorIndigo50,
  colorChart4: board$3.brand.colorBrand20,
  colorChart5: board$3.pink.colorPink30,
  colorChart6: board$3.green.colorGreen40,
  colorChart7: board$3.yellow.colorYellow60,
  colorChart8: board$3.mint.colorMint40,
  colorChart9: board$3.purple.colorPurple30,
  colorChart10: board$3.rose.colorRose40,
  colorChart11: board$3.orange.colorOrange30,
  colorChart12: board$3.red.colorRed40
};
var colorGroup$5 = getColorGroup(colorChart$5);
var light$4 = getThemeColor(gray$6, colorState$5, colorGroup$5);
var light$5 = light$4;
var gray$5 = _extends({}, board$3.gray, board$3.transparent);
var colorState$4 = {
  // 错误色
  colorError: board$3.red.colorRed40,
  // 告警色
  colorAlert: board$3.orange.colorOrange50,
  // 提醒色
  colorWarning: board$3.yellow.colorYellow40,
  // 成功色
  colorSuccess: board$3.mint.colorMint60,
  // 信息色
  colorInfo: board$3.blue.colorBlue50,
  // 失效色
  colorNone: board$3.gray.colorGray60
};
var colorChart$4 = {
  colorChart1: board$3.blue.colorBlue50,
  colorChart2: board$3.cyan.colorCyan40,
  colorChart3: board$3.indigo.colorIndigo50,
  colorChart4: board$3.brand.colorBrand30,
  colorChart5: board$3.pink.colorPink30,
  colorChart6: board$3.green.colorGreen40,
  colorChart7: board$3.yellow.colorYellow60,
  colorChart8: board$3.mint.colorMint40,
  colorChart9: board$3.purple.colorPurple40,
  colorChart10: board$3.rose.colorRose40,
  colorChart11: board$3.orange.colorOrange30,
  colorChart12: board$3.red.colorRed40
};
var colorGroup$4 = getColorGroup(colorChart$4);
var dark$4 = getThemeColor(gray$5, colorState$4, colorGroup$4);
var dark$5 = dark$4;
var bpit = {
  light: light$5,
  dark: dark$5
};
var bpit$1 = bpit;
var rose = {
  colorRose10: "#FFEBF3",
  colorRose20: "#FFD6E8",
  colorRose30: "#FAA0CB",
  colorRose40: "#F56EAD",
  colorRose50: "#F24998",
  colorRose60: "#E61C81",
  colorRose70: "#B50E65",
  colorRose80: "#940A54",
  colorRose90: "#70033F",
  colorRose100: "#4D002B",
  colorRose110: "#993D6E",
  colorRose120: "#CC7AA6",
  colorRose130: "#E6B8D2"
};
var red = {
  colorRed10: "#FFF1F0",
  colorRed20: "#FCE2E0",
  colorRed30: "#FAA7A3",
  colorRed40: "#FA8682",
  colorRed50: "#F76360",
  colorRed60: "#F23030",
  colorRed70: "#CC272A",
  colorRed80: "#A3171C",
  colorRed90: "#78080E",
  colorRed100: "#4D0005",
  colorRed110: "#A64242",
  colorRed120: "#D4827F",
  colorRed130: "#F2C5C2"
};
var orange = {
  colorOrange10: "#FFF4E8",
  colorOrange20: "#FFEBD1",
  colorOrange30: "#FCD5A4",
  colorOrange40: "#FCBC72",
  colorOrange50: "#FF9A2E",
  colorOrange60: "#FF8800",
  colorOrange70: "#D96900",
  colorOrange80: "#A64D00",
  colorOrange90: "#733400",
  colorOrange100: "#4D2201",
  colorOrange110: "#9E6D3F",
  colorOrange120: "#D6A981",
  colorOrange130: "#F2D8C2"
};
var yellow = {
  colorYellow10: "#FFFAE6",
  colorYellow20: "#FCF0C2",
  colorYellow30: "#FAE49D",
  colorYellow40: "#F7D56F",
  colorYellow50: "#FAC532",
  colorYellow60: "#FFB700",
  colorYellow70: "#E0A210",
  colorYellow80: "#A67711",
  colorYellow90: "#7A5202",
  colorYellow100: "#4D3200",
  colorYellow110: "#9E7E3F",
  colorYellow120: "#D4B57F",
  colorYellow130: "#E6D3B8"
};
var lemon = {
  colorLemon10: "#FFFFE6",
  colorLemon20: "#FCFCC2",
  colorLemon30: "#FAF78E",
  colorLemon40: "#FCF26A",
  colorLemon50: "#FAEE46",
  colorLemon60: "#F2E70C",
  colorLemon70: "#D9C816",
  colorLemon80: "#A38F08",
  colorLemon90: "#756202",
  colorLemon100: "#4D3C00",
  colorLemon110: "#9E8F46",
  colorLemon120: "#D6C581",
  colorLemon130: "#EDDFB2"
};
var lime = {
  colorLime10: "#FDFFE6",
  colorLime20: "#EFF5BF",
  colorLime30: "#E2ED8E",
  colorLime40: "#D5E667",
  colorLime50: "#C6DE3E",
  colorLime60: "#B2D119",
  colorLime70: "#95B312",
  colorLime80: "#728C0A",
  colorLime90: "#576E05",
  colorLime100: "#3B4D00",
  colorLime110: "#808C46",
  colorLime120: "#C1CC7A",
  colorLime130: "#3B4D00"
};
var kelly = {
  colorKelly10: "#EDF7DF",
  colorKelly20: "#DAF2BB",
  colorKelly30: "#B9E683",
  colorKelly40: "#9EDB58",
  colorKelly50: "#7DCC29",
  colorKelly60: "#5CB300",
  colorKelly70: "#4B9902",
  colorKelly80: "#3C8001",
  colorKelly90: "#2E6600",
  colorKelly100: "#1F4700",
  colorKelly110: "#628C38",
  colorKelly120: "#A2C777",
  colorKelly130: "#D2E6B8"
};
var green = {
  colorGreen10: "#E4F7E9",
  colorGreen20: "#D5F2DC",
  colorGreen30: "#92E0A5",
  colorGreen40: "#60D680",
  colorGreen50: "#25C251",
  colorGreen60: "#00B336",
  colorGreen70: "#029931",
  colorGreen80: "#01802B",
  colorGreen90: "#006624",
  colorGreen100: "#004A1B",
  colorGreen110: "#3D995C",
  colorGreen120: "#77C78F",
  colorGreen130: "#B8E6C7"
};
var mint = {
  colorMint10: "#E6FCFA",
  colorMint20: "#D0F5F1",
  colorMint30: "#97E8E1",
  colorMint40: "#64DED6",
  colorMint50: "#38D6CE",
  colorMint60: "#10C7C1",
  colorMint70: "#0BB8B2",
  colorMint80: "#048C8C",
  colorMint90: "#046466",
  colorMint100: "#004547",
  colorMint110: "#3D9996",
  colorMint120: "#77C7C2",
  colorMint130: "#B8E6E1"
};
var sky = {
  colorSky10: "#E8FAFF",
  colorSky20: "#D6F6FF",
  colorSky30: "#A5E6FA",
  colorSky40: "#79D8F7",
  colorSky50: "#58CBF5",
  colorSky60: "#33BCF2",
  colorSky70: "#1F9ACF",
  colorSky80: "#1075A3",
  colorSky90: "#065278",
  colorSky100: "#00304A",
  colorSky110: "#3D7F99",
  colorSky120: "#7AB8CC",
  colorSky130: "#B6E5F2"
};
var blue = {
  colorBlue10: "#F0F7FF",
  colorBlue20: "#DEECFF",
  colorBlue30: "#B3D6FF",
  colorBlue40: "#7EB7FC",
  colorBlue50: "#4191FA",
  colorBlue60: "#1476FF",
  colorBlue70: "#0F5ED4",
  colorBlue80: "#0845A6",
  colorBlue90: "#022E7A",
  colorBlue100: "#001A4A",
  colorBlue110: "#3D6899",
  colorBlue120: "#7FA6D4",
  colorBlue130: "#B6D4F2"
};
var indigo = {
  colorIndigo10: "#F0EBFF",
  colorIndigo20: "#E2D9FC",
  colorIndigo30: "#B9A6F7",
  colorIndigo40: "#9479F2",
  colorIndigo50: "#6E51E0",
  colorIndigo60: "#512FD6",
  colorIndigo70: "#391EB0",
  colorIndigo80: "#27108F",
  colorIndigo90: "#19056E",
  colorIndigo100: "#0E004D",
  colorIndigo110: "#584D99",
  colorIndigo120: "#847ACC",
  colorIndigo130: "#BBB8E6"
};
var purple = {
  colorPurple10: "#F9EBFF",
  colorPurple20: "#F4E0FC",
  colorPurple30: "#DEA3F7",
  colorPurple40: "#CC78F0",
  colorPurple50: "#BA53E6",
  colorPurple60: "#A42FD6",
  colorPurple70: "#841EB0",
  colorPurple80: "#6B1091",
  colorPurple90: "#520673",
  colorPurple100: "#36004D",
  colorPurple110: "#7D3D99",
  colorPurple120: "#B47ACC",
  colorPurple130: "#D8B8E6"
};
var pink = {
  colorPink10: "#FCE8FB",
  colorPink20: "#FCD4FA",
  colorPink30: "#F7A1F3",
  colorPink40: "#EB75E7",
  colorPink50: "#E841E5",
  colorPink60: "#D91AD9",
  colorPink70: "#B50FB8",
  colorPink80: "#8F0A94",
  colorPink90: "#6B0370",
  colorPink100: "#47004D",
  colorPink110: "#993D99",
  colorPink120: "#C97ACC",
  colorPink130: "#E2B8E6"
};
var gray$4 = {
  colorGray0: "#FFFFFF",
  colorGray5: "#FAFAFA",
  colorGray10: "#F5F5F5",
  colorGray20: "#F0F0F0",
  colorGray30: "#E6E6E6",
  colorGray40: "#DBDBDB",
  colorGray50: "#C2C2C2",
  colorGray60: "#808080",
  colorGray70: "#595959",
  colorGray80: "#333333",
  colorGray90: "#191919",
  colorGray100: "#000000"
};
var transparent = {
  colorTransparent: "transparent"
};
var board = {
  red,
  sky,
  lime,
  rose,
  mint,
  blue,
  pink,
  gray: gray$4,
  kelly,
  lemon,
  green,
  orange,
  yellow,
  indigo,
  purple,
  transparent
};
var board$1 = board;
var gray$3 = _extends({}, board$1.gray, board$1.transparent);
var colorState$3 = {
  // 紧急色
  colorError: board$1.red.colorRed60,
  // 重要告警色
  colorAlert: board$1.orange.colorOrange60,
  // 次要告警色
  colorWarning: board$1.yellow.colorYellow60,
  // 成功色
  colorSuccess: board$1.kelly.colorKelly60,
  // 提示色
  colorInfo: board$1.blue.colorBlue60,
  // 失效
  colorNone: board$1.gray.colorGray50
};
var colorChart$3 = {
  colorChart1: board$1.blue.colorBlue60,
  colorChart2: board$1.mint.colorMint70,
  colorChart3: board$1.indigo.colorIndigo50,
  colorChart4: board$1.kelly.colorKelly60,
  colorChart5: board$1.yellow.colorYellow60,
  colorChart6: board$1.sky.colorSky60,
  colorChart7: board$1.purple.colorPurple50,
  colorChart8: board$1.rose.colorRose50
  // (原色 '#EB4696')
};
var colorGroup$3 = getColorGroup(colorChart$3);
var light$2 = getThemeColor(gray$3, colorState$3, colorGroup$3);
var light$3 = light$2;
var gray$2 = _extends({}, board$1.gray, board$1.transparent);
var colorState$2 = {
  // 紧急色
  colorError: board$1.red.colorRed60,
  // 重要告警色
  colorAlert: board$1.orange.colorOrange60,
  // 次要告警色
  colorWarning: board$1.yellow.colorYellow60,
  // 成功色
  colorSuccess: board$1.kelly.colorKelly60,
  // 提示色
  colorInfo: board$1.blue.colorBlue60,
  // 失效
  colorNone: board$1.gray.colorGray50
};
var colorChart$2 = {
  colorChart1: board$1.blue.colorBlue60,
  colorChart2: board$1.mint.colorMint70,
  colorChart3: board$1.indigo.colorIndigo50,
  colorChart4: board$1.kelly.colorKelly60,
  colorChart5: board$1.yellow.colorYellow60,
  colorChart6: board$1.sky.colorSky60,
  colorChart7: board$1.purple.colorPurple50,
  colorChart8: board$1.rose.colorRose50
  // (原色 '#EB4696')
};
var colorGroup$2 = getColorGroup(colorChart$2);
var dark$2 = getThemeColor(gray$2, colorState$2, colorGroup$2);
var dark$3 = dark$2;
var cloud = {
  light: light$3,
  dark: dark$3
};
var cloud$1 = cloud;
var gray$1 = _extends({}, board$3.gray, board$3.transparent);
var colorState$1 = {
  // 错误色
  colorError: board$3.red.colorRed50,
  // 告警色
  colorAlert: board$3.orange.colorOrange50,
  // 提醒色
  colorWarning: board$3.yellow.colorYellow50,
  // 成功色
  colorSuccess: board$3.mint.colorMint50,
  // 信息色
  colorInfo: board$3.blue.colorBlue50,
  // 失效色
  colorNone: board$3.gray.colorGray30
};
var colorChart$1 = {
  colorChart1: board$3.blue.colorBlue50,
  colorChart2: board$3.green.colorGreen40,
  colorChart3: board$3.indigo.colorIndigo50,
  colorChart4: board$3.mint.colorMint40,
  colorChart5: board$3.brand.colorBrand50,
  colorChart6: board$3.pink.colorPink40,
  colorChart7: board$3.cyan.colorCyan50,
  colorChart8: board$3.orange.colorOrange40,
  colorChart9: board$3.rose.colorRose50,
  colorChart10: board$3.yellow.colorYellow40,
  colorChart11: board$3.purple.colorPurple50
};
var colorGroup$1 = getColorGroup(colorChart$1);
var light = getThemeColor(gray$1, colorState$1, colorGroup$1);
var light$1 = light;
var gray = _extends({}, board$3.gray, board$3.transparent);
var colorState = {
  // 错误色
  colorError: board$3.red.colorRed40,
  // 告警色
  colorAlert: board$3.orange.colorOrange50,
  // 提醒色
  colorWarning: board$3.yellow.colorYellow40,
  // 成功色
  colorSuccess: board$3.mint.colorMint60,
  // 信息色
  colorInfo: board$3.blue.colorBlue50,
  // 失效色
  colorNone: board$3.gray.colorGray60
};
var colorChart = {
  colorChart1: board$3.blue.colorBlue50,
  colorChart2: board$3.green.colorGreen50,
  colorChart3: board$3.indigo.colorIndigo50,
  colorChart4: board$3.mint.colorMint50,
  colorChart5: board$3.brand.colorBrand50,
  colorChart6: board$3.pink.colorPink50,
  colorChart7: board$3.cyan.colorCyan50,
  colorChart8: board$3.orange.colorOrange50,
  colorChart9: board$3.rose.colorRose50,
  colorChart10: board$3.yellow.colorYellow50,
  colorChart11: board$3.purple.colorPurple50
};
var colorGroup = getColorGroup(colorChart);
var dark = getThemeColor(gray, colorState, colorGroup);
var dark$1 = dark;
var hdesign = {
  light: light$1,
  dark: dark$1
};
var hdesign$1 = hdesign;
var color = (_color = {}, _color[THEMES.LIGHT] = ict$1.light, _color[THEMES.DARK] = ict$1.dark, _color[THEMES.BPIT_LIGHT] = bpit$1.light, _color[THEMES.BPIT_DARK] = bpit$1.dark, _color[THEMES.CLOUD_LIGHT] = cloud$1.light, _color[THEMES.CLOUD_DARK] = cloud$1.dark, _color[THEMES.HDESIGN_LIGHT] = hdesign$1.light, _color[THEMES.HDESIGN_DARK] = hdesign$1.dark, _color);
var color$1 = color;
var font = {
  fontSizeBase: 12,
  fontSizeMd: 14,
  fontSizeLg: 16,
  fontSizeXl: 18,
  fontSize2xl: 20,
  fontSize3xl: 24,
  fontSize4xl: 28,
  fontSize5xl: 30,
  fontSize6xl: 32,
  fontSize7xl: 36,
  fontSize8xl: 40
};
var font$1 = font;
var lineType = {
  lineTypeSolid: "solid",
  lineTypeDashed: "dashed",
  lineTypeDashedLG: [4, 4]
};
var lineType$1 = lineType;
var space = {
  // 图表特别配置
  spaceNone: 0,
  space05x: 2,
  spaceBase: 4,
  space2x: 8,
  space3x: 12,
  space4x: 16,
  space5x: 20,
  space6x: 24,
  space7x: 28,
  space8x: 32
};
var space$1 = space;
var border = {
  // 针对图表特别设立出来的token
  borderNone: 0,
  border05x: 0.5,
  borderBase: 1,
  border2x: 2,
  border4x: 4,
  border8x: 8
};
var border$1 = border;
var size$1 = {
  size05x: 2,
  sizeBase: 4,
  size2x: 8,
  size3x: 12,
  size4x: 16,
  size5x: 20,
  size6x: 24
};
var size$2 = size$1;
var borderRadius = {
  borderRadiusNone: 0,
  borderRadiusXs: 2,
  borderRadiusBase: 4,
  borderRadiusMd: 6,
  borderRadiusLg: 8,
  borderRadiusXl: 12,
  borderRadiusFull: 9999
};
var borderRadius$1 = borderRadius;
var globalToken = _extends({}, font$1, lineType$1, space$1, border$1, size$2, borderRadius$1);
var globalToken$1 = globalToken;
function getGlobalToken(themeName) {
  return _extends({}, globalToken$1, color$1[themeName].grayScale);
}
function getColor(colors, index) {
  return colors[index % colors.length];
}
function codeToRGB(code, opacity) {
  if (code === void 0) {
    return void 0;
  }
  var result = [];
  result.push(parseInt(code.substring(1, 3), 16));
  result.push(parseInt(code.substring(3, 5), 16));
  result.push(parseInt(code.substring(5), 16));
  return "rgba(" + result.join(",") + "," + opacity + ")";
}
function codeToHex(color3) {
  switch (color3) {
    case "red":
      return "#ff0000";
    case "blue":
      return "#0000ff";
    case "green":
      return "#00ff00";
    case "pink":
      return "#FFC0CB";
    case "yellow":
      return "#FFFF00";
    case "orange":
      return "#FFA500";
    case "black":
      return "#000000";
    case "white":
      return "#ffffff";
    case "gray":
      return "#808080";
    case "purple":
      return "#800080";
  }
  if (color3.includes("#")) {
    if (color3.length === 7) {
      return color3;
    } else if (color3.length === 4) {
      return color3[0] + color3[1] + color3[1] + color3[2] + color3[2] + color3[3] + color3[3];
    }
  }
  var values = color3.replace(/rgba?\(/, "").replace(/\)/, "").replace(/[\s+]/g, "").split(",");
  var a = parseFloat(values[3] || 1);
  var r = Math.floor(a * parseInt(values[0]) + (1 - a) * 255);
  var g = Math.floor(a * parseInt(values[1]) + (1 - a) * 255);
  var b = Math.floor(a * parseInt(values[2]) + (1 - a) * 255);
  return "#" + ("0" + r.toString(16)).slice(-2) + ("0" + g.toString(16)).slice(-2) + ("0" + b.toString(16)).slice(-2);
}
function changeRgbaOpacity(rgba, opacity) {
  var _rgba$match = rgba.match(/\d+(\.\d+)?/g), r = _rgba$match[0], g = _rgba$match[1], b = _rgba$match[2];
  return "rgba(" + r + "," + g + "," + b + "," + opacity + ")";
}
function getAliasToken$3(globalToken2, light2) {
  if (light2 === void 0) {
    light2 = true;
  }
  var colorGray0 = globalToken2.colorGray0, colorGray5 = globalToken2.colorGray5, colorGray10 = globalToken2.colorGray10, colorGray20 = globalToken2.colorGray20, colorGray50 = globalToken2.colorGray50, colorGray60 = globalToken2.colorGray60, colorGray70 = globalToken2.colorGray70, colorGray90 = globalToken2.colorGray90, colorGray100 = globalToken2.colorGray100, fontSizeBase = globalToken2.fontSizeBase, fontSizeMd = globalToken2.fontSizeMd, space2x = globalToken2.space2x, spaceBase = globalToken2.spaceBase, lineTypeSolid = globalToken2.lineTypeSolid, colorTransparent = globalToken2.colorTransparent, borderNone = globalToken2.borderNone, borderBase = globalToken2.borderBase, borderRadiusBase = globalToken2.borderRadiusBase, border2x = globalToken2.border2x, fontSizeLg = globalToken2.fontSizeLg, borderRadiusNone = globalToken2.borderRadiusNone, fontSize4xl = globalToken2.fontSize4xl, space6x = globalToken2.space6x, size3x = globalToken2.size3x, size2x = globalToken2.size2x, spaceNone = globalToken2.spaceNone, space8x = globalToken2.space8x, space4x = globalToken2.space4x, size6x = globalToken2.size6x, size5x = globalToken2.size5x;
  return {
    //  初级底色 图表背景
    colorBgPrimary: light2 ? colorGray0 : colorGray90,
    // 确定
    // 次级背景色 tip背景
    colorBgSecondary: light2 ? colorGray0 : colorGray70,
    // 主要文本色
    colorTextPrimary: light2 ? colorGray90 : colorGray5,
    // 确定
    // 次级文本色
    colorTextSecondary: light2 ? colorGray60 : colorGray20,
    // 确定
    // 禁用文本色
    colorTextDisabled: light2 ? codeToRGB(colorGray90, 0.3) : codeToRGB(colorGray10, 0.3),
    // 确定
    // 图标激活色（legend翻页的颜色）
    colorIconPrimary: light2 ? colorGray90 : colorGray10,
    // 确定
    // 控件失效色（legend失效的颜色）
    colorInactive: light2 ? colorGray20 : colorGray50,
    // 确定
    // 图标禁用色（legend翻页图标禁用的颜色）
    colorIconDisabled: light2 ? codeToRGB(colorGray90, 0.3) : codeToRGB(colorGray10, 0.3),
    // 确定
    // 坐标轴线颜色
    colorAxisLine: light2 ? colorGray10 : codeToRGB(colorGray10, 0.1),
    // 确定
    // 刻度线颜色
    colorAxisTickLine: light2 ? colorGray10 : codeToRGB(colorGray10, 0.1),
    // 确定
    // 分隔线颜色
    colorAxisSplitLine: light2 ? codeToRGB(colorGray90, 0.1) : codeToRGB(colorGray10, 0.1),
    // 确定
    // 坐标轴指示器悬浮线
    colorAxisPointerLine: light2 ? colorGray20 : colorGray50,
    // 确定
    // 透明边框色
    colorBorderTransparent: colorTransparent,
    // 文本透明
    colorTextTransparent: colorTransparent,
    // 指示器阴影
    colorAxisPointerShadow: light2 ? codeToRGB(colorGray90, 0.05) : codeToRGB(colorGray10, 0.08),
    // tip阴影
    colorShadow: light2 ? codeToRGB(colorGray100, 0.16) : codeToRGB(colorGray100, 0.5),
    // 边框颜色
    colorBorder: light2 ? colorGray0 : colorGray90,
    // 禁用边框颜色和图表colorBgPrimary保持一致（聚合气泡图用todo）
    colorBorderDisabled: light2 ? colorGray0 : colorGray90,
    // 确定
    // label颜色
    colorLabel: light2 ? colorGray90 : colorGray5,
    // label禁用颜色（和文本禁用色保持一致）
    colorLabelDisabled: light2 ? codeToRGB(colorGray90, 0.3) : codeToRGB(colorGray10, 0.3),
    // 确定
    // 虚线的颜色
    colorDash: light2 ? colorGray0 : colorGray90,
    // 背景透明
    colorBgTransparent: colorTransparent,
    // 无数据占位背景
    colorBgEmpty: light2 ? colorGray10 : codeToRGB(colorGray10, 0.1),
    // 确定
    // labelLine颜色
    colorLabelLine: light2 ? colorGray90 : colorGray5,
    // 确定
    // 线透明
    colorLineTransparent: colorTransparent,
    // tip阴影垂直偏移
    shadowOffsetY: space2x,
    // tip阴影模糊
    shadowBlur: space6x,
    // 主文本字号
    textFontSize: fontSizeMd,
    // 确定
    // 次级文本字号
    subtextFontSize: fontSizeBase,
    // 确定
    // 标题文本字号
    titleFontSize: fontSize4xl,
    // 副标题文本字号
    subtitleFontSize: fontSizeLg,
    // 坐标轴线宽 2
    axisLineWidth: border2x,
    // 确定
    // 刻度线线宽 2
    axisTickLineWidth: border2x,
    // 确定
    // 分隔线线宽 1
    axisSplitLineWidth: borderBase,
    // 确定
    // 坐标轴指示器的标线线宽 1
    axisPointerLineWidth: borderBase,
    // 坐标轴类型
    axisLineType: lineTypeSolid,
    // 刻度线类型
    axisTickLineType: lineTypeSolid,
    // 直角坐标系分隔线类型
    axisSplitLineType: lineTypeSolid,
    // 极坐标系分隔线类型
    polarAxisSplitLineType: lineTypeSolid,
    // 坐标轴指示器标线类型
    axisPointerLineType: lineTypeSolid,
    // 坐标轴名称间距
    axisNameSpace: space2x,
    // 坐标轴文本间距
    axisLabelSpace: spaceBase,
    // 标识线宽度
    markLineWidth: borderBase,
    // 标识线高亮宽度
    markLineEmphasisWidth: borderBase,
    //  border 0
    borderWidthNone: borderNone,
    // 标题文本间距
    titleSpace: space2x,
    // 容器的间距
    containerGap: space2x,
    // 容器的圆角
    containerBoderRadius: borderRadiusBase,
    // 图元
    symbolSizeLG: size3x,
    // 图元 雷达图用
    symbolSize: size3x,
    // 图元 超大
    symbolSizeSM: size2x,
    // 图元的边框
    symbolBorderWidth: border2x,
    // 图元的边框 雷达图专用
    symbolBorderWidthSM: border2x,
    // 柱条的宽度
    barWidth: size2x,
    // 堆叠进度图宽度 20
    barWidthLG: size5x,
    // label字号
    labelFontSize: fontSizeBase,
    // labelLine的长度
    labelLineLength: size6x,
    // 边框 细
    borderWidth: borderBase,
    // 边框
    borderWidthLG: border2x,
    // 圆角 0
    borderRadiusNone,
    // 圆角 小
    borderRadius: borderRadiusBase,
    // series.lineStyle
    lineWidth: border2x,
    // series.lineStyle 0
    lineWidthNone: borderNone,
    // 图例单元尺寸
    legendItemSize: 2,
    // 图例圆形单元尺寸
    legendCircleItemSize: 12,
    // 图例的间距
    legendSpace: space8x,
    // 无padding
    paddingNone: spaceNone,
    paddingSM: spaceBase,
    padding: space2x,
    paddingLG: space4x
  };
}
function getAliasToken$2(globalToken2, light2) {
  if (light2 === void 0) {
    light2 = true;
  }
  var colorGray0 = globalToken2.colorGray0, colorGray30 = globalToken2.colorGray30, colorGray40 = globalToken2.colorGray40, colorGray50 = globalToken2.colorGray50, colorGray60 = globalToken2.colorGray60, colorGray80 = globalToken2.colorGray80, colorGray70 = globalToken2.colorGray70, colorGray90 = globalToken2.colorGray90, colorTransparent = globalToken2.colorTransparent, fontSizeBase = globalToken2.fontSizeBase, fontSizeMd = globalToken2.fontSizeMd, space2x = globalToken2.space2x, spaceBase = globalToken2.spaceBase, lineTypeSolid = globalToken2.lineTypeSolid, lineTypeDashedLG = globalToken2.lineTypeDashedLG, borderNone = globalToken2.borderNone, borderBase = globalToken2.borderBase, borderRadiusBase = globalToken2.borderRadiusBase, border2x = globalToken2.border2x, borderRadiusNone = globalToken2.borderRadiusNone, fontSizeLg = globalToken2.fontSizeLg, fontSize4xl = globalToken2.fontSize4xl, space6x = globalToken2.space6x, size3x = globalToken2.size3x, size2x = globalToken2.size2x, spaceNone = globalToken2.spaceNone, space8x = globalToken2.space8x, space4x = globalToken2.space4x, size6x = globalToken2.size6x, size5x = globalToken2.size5x;
  return {
    //  初级底色 图表背景
    colorBgPrimary: light2 ? colorGray0 : colorGray90,
    // 确定
    // 次级背景色 tip背景
    colorBgSecondary: light2 ? colorGray0 : colorGray80,
    // 确定
    // 主要文本色
    colorTextPrimary: light2 ? colorGray90 : colorGray40,
    // 确定
    // 次级文本色
    colorTextSecondary: light2 ? colorGray60 : colorGray50,
    // 确定
    // 禁用文本色
    colorTextDisabled: light2 ? colorGray50 : colorGray60,
    // 确定
    // 图标激活色（legend翻页的颜色）
    colorIconPrimary: light2 ? colorGray60 : colorGray60,
    // 确定
    // 控件失效色（legend失效的颜色）
    colorInactive: light2 ? colorGray50 : colorGray80,
    // 确定
    // 图标禁用色（legend翻页图标禁用的颜色）
    colorIconDisabled: light2 ? colorGray50 : colorGray80,
    // 确定
    // 坐标轴线颜色
    colorAxisLine: light2 ? colorGray30 : colorGray80,
    // 确定
    // 刻度线颜色
    colorAxisTickLine: light2 ? colorGray30 : colorGray80,
    // 确定
    // 分隔线颜色
    colorAxisSplitLine: light2 ? colorGray30 : colorGray80,
    // 确定
    // 坐标轴指示器悬浮线
    colorAxisPointerLine: light2 ? colorGray60 : colorGray70,
    // 确定
    // 透明边框色
    colorBorderTransparent: colorTransparent,
    // 文本透明
    colorTextTransparent: colorTransparent,
    // 指示器阴影
    colorAxisPointerShadow: light2 ? codeToRGB(colorGray90, 0.08) : codeToRGB(colorGray90, 0.08),
    //
    // tip阴影
    colorShadow: light2 ? codeToRGB(colorGray90, 0.08) : codeToRGB(colorGray90, 0.08),
    //
    // 边框颜色
    colorBorder: light2 ? colorGray0 : colorGray90,
    // 确定
    // 禁用边框颜色和图表colorBgPrimary保持一致（聚合气泡图用todo）
    colorBorderDisabled: light2 ? colorGray0 : colorGray90,
    // 确定
    // label颜色
    colorLabel: light2 ? colorGray90 : colorGray40,
    // 确定
    // label禁用颜色（和文本禁用色保持一致）
    colorLabelDisabled: light2 ? colorGray50 : colorGray60,
    // 确定
    // 虚线的颜色
    colorDash: light2 ? colorGray0 : colorGray90,
    // 背景透明
    colorBgTransparent: colorTransparent,
    // 无数据占位背景
    colorBgEmpty: light2 ? colorGray30 : colorGray80,
    // 确定
    // labelLine颜色
    colorLabelLine: light2 ? colorGray90 : colorGray40,
    // 确定
    // 线透明
    colorLineTransparent: colorTransparent,
    // tip阴影垂直偏移
    shadowOffsetY: space2x,
    // tip阴影模糊
    shadowBlur: space6x,
    // 主文本字号
    textFontSize: fontSizeMd,
    // 确定
    // 次级文本字号
    subtextFontSize: fontSizeBase,
    // 确定
    // 标题文本字号
    titleFontSize: fontSize4xl,
    // 副标题文本字号
    subtitleFontSize: fontSizeLg,
    // 坐标轴 1
    axisLineWidth: borderBase,
    //   刻度线  1
    axisTickLineWidth: borderBase,
    // 分隔线线宽 1
    axisSplitLineWidth: borderBase,
    // 坐标轴指示器的标线线宽 1
    axisPointerLineWidth: borderBase,
    // 坐标轴类型
    axisLineType: lineTypeSolid,
    // 刻度线类型
    axisTickLineType: lineTypeSolid,
    // 直角坐标系分隔线类型
    axisSplitLineType: lineTypeDashedLG,
    // 极坐标系分隔线类型
    polarAxisSplitLineType: lineTypeSolid,
    // 坐标轴指示器标线类型
    axisPointerLineType: lineTypeSolid,
    // 坐标轴名称间距
    axisNameSpace: space2x,
    // 坐标轴文本间距
    axisLabelSpace: spaceBase,
    // 标识线宽度
    markLineWidth: borderBase,
    // 标识线高亮宽度
    markLineEmphasisWidth: borderBase,
    //  border 0
    borderWidthNone: borderNone,
    // 标题文本间距
    titleSpace: space2x,
    // 容器的间距
    containerGap: space2x,
    // 容器的圆角
    containerBoderRadius: borderRadiusBase,
    // 图元
    symbolSizeLG: size3x,
    // 图元 雷达图用
    symbolSize: size2x,
    // 图元 超大
    symbolSizeSM: size2x,
    // 图元的边框
    symbolBorderWidth: border2x,
    // 图元的边框 雷达图专用
    symbolBorderWidthSM: borderBase,
    // 柱条的宽度
    barWidth: size2x,
    // 堆叠进度图宽度 20
    barWidthLG: size5x,
    // label字号
    labelFontSize: fontSizeBase,
    // labelLine的长度
    labelLineLength: size6x,
    // 边框 细
    borderWidth: borderBase,
    // 边框
    borderWidthLG: border2x,
    // 圆角 0
    borderRadiusNone,
    // 圆角 小
    borderRadius: borderRadiusBase,
    // series.lineStyle
    lineWidth: border2x,
    // series.lineStyle 0
    lineWidthNone: borderNone,
    // 图例单元尺寸
    legendItemSize: 2,
    // 图例圆形单元尺寸
    legendCircleItemSize: 6,
    // 图例的间距
    legendSpace: space8x,
    // 无padding
    paddingNone: spaceNone,
    paddingSM: spaceBase,
    padding: space2x,
    paddingLG: space4x
  };
}
function getAliasToken$1(globalToken2, light2) {
  if (light2 === void 0) {
    light2 = true;
  }
  var colorGray0 = globalToken2.colorGray0, colorGray5 = globalToken2.colorGray5, colorGray10 = globalToken2.colorGray10, colorGray20 = globalToken2.colorGray20, colorGray50 = globalToken2.colorGray50, colorGray60 = globalToken2.colorGray60, colorGray70 = globalToken2.colorGray70, colorGray80 = globalToken2.colorGray80, colorGray90 = globalToken2.colorGray90, colorGray100 = globalToken2.colorGray100, fontSizeBase = globalToken2.fontSizeBase, fontSizeMd = globalToken2.fontSizeMd, space2x = globalToken2.space2x, spaceBase = globalToken2.spaceBase, lineTypeSolid = globalToken2.lineTypeSolid, colorTransparent = globalToken2.colorTransparent, borderNone = globalToken2.borderNone, borderBase = globalToken2.borderBase, borderRadiusBase = globalToken2.borderRadiusBase, border2x = globalToken2.border2x, fontSizeLg = globalToken2.fontSizeLg, borderRadiusNone = globalToken2.borderRadiusNone, fontSize4xl = globalToken2.fontSize4xl, space6x = globalToken2.space6x, size3x = globalToken2.size3x, size2x = globalToken2.size2x, size4x = globalToken2.size4x, spaceNone = globalToken2.spaceNone, space8x = globalToken2.space8x, space4x = globalToken2.space4x, size6x = globalToken2.size6x, size5x = globalToken2.size5x, borderRadiusLg = globalToken2.borderRadiusLg;
  return {
    //  初级底色  图表背景
    colorBgPrimary: light2 ? colorGray0 : codeToRGB(colorGray5, 0.1),
    // 确定
    // 次级背景色  tip背景
    colorBgSecondary: light2 ? colorGray0 : colorGray70,
    // 确定
    // 主要文本色
    colorTextPrimary: light2 ? colorGray90 : colorGray0,
    // 确定
    // 次级文本色
    colorTextSecondary: light2 ? colorGray50 : colorGray20,
    // 确定
    // 禁用文本色
    colorTextDisabled: light2 ? colorGray20 : colorGray60,
    // 确定
    // 图标激活色（legend翻页的颜色）
    colorIconPrimary: light2 ? colorGray70 : colorGray20,
    // 确定
    // 控件失效色（legend失效的颜色）
    colorInactive: light2 ? colorGray10 : colorGray80,
    // 确定
    // 图标禁用色（legend翻页图标禁用的颜色）
    colorIconDisabled: light2 ? colorGray10 : colorGray80,
    // 确定
    // 坐标轴线颜色
    colorAxisLine: light2 ? colorGray10 : colorGray70,
    // 确定
    // 刻度线颜色
    colorAxisTickLine: light2 ? colorGray10 : colorGray70,
    // 确定
    // 分隔线颜色
    colorAxisSplitLine: light2 ? colorGray5 : colorGray80,
    // 确定
    // 坐标轴指示器悬浮线
    colorAxisPointerLine: light2 ? colorGray10 : colorGray70,
    // 确定
    // 透明边框色
    colorBorderTransparent: colorTransparent,
    // 文本透明
    colorTextTransparent: colorTransparent,
    // 指示器阴影
    colorAxisPointerShadow: light2 ? codeToRGB(colorGray10, 0.5) : codeToRGB(colorGray5, 0.05),
    // 确定
    // tip阴影
    colorShadow: light2 ? codeToRGB(colorGray90, 0.08) : codeToRGB(colorGray100, 0.5),
    // 确定
    // 以下和规范还未确认
    // 边框颜色
    colorBorder: light2 ? colorGray0 : colorGray90,
    // 禁用边框颜色和图表colorBgPrimary保持一致（聚合气泡图用todo）
    colorBorderDisabled: light2 ? colorGray0 : codeToRGB(colorGray5, 0.1),
    // 确定
    // label颜色
    colorLabel: light2 ? colorGray90 : colorGray5,
    // label禁用颜色（和文本禁用色保持一致）
    colorLabelDisabled: light2 ? colorGray20 : colorGray60,
    // 确定
    // 虚线的颜色
    colorDash: light2 ? colorGray0 : colorGray90,
    // 背景透明
    colorBgTransparent: colorTransparent,
    // 无数据占位背景
    colorBgEmpty: light2 ? colorGray10 : codeToRGB(colorGray10, 0.1),
    // labelLine颜色
    colorLabelLine: light2 ? colorGray90 : colorGray5,
    // 线透明
    colorLineTransparent: colorTransparent,
    // tip阴影垂直偏移
    shadowOffsetY: space2x,
    // tip阴影模糊
    shadowBlur: space6x,
    // 主文本字号
    textFontSize: fontSizeMd,
    // 次级文本字号
    subtextFontSize: fontSizeBase,
    // 标题文本字号
    titleFontSize: fontSize4xl,
    // 副标题文本字号
    subtitleFontSize: fontSizeLg,
    // 坐标轴线宽 2
    axisLineWidth: border2x,
    // 刻度线线宽 2
    axisTickLineWidth: border2x,
    // 分隔线线宽 1
    axisSplitLineWidth: borderBase,
    // 坐标轴指示器的标线线宽 1
    axisPointerLineWidth: borderBase,
    // 待定
    // 坐标轴类型
    axisLineType: lineTypeSolid,
    // 刻度线类型
    axisTickLineType: lineTypeSolid,
    // 直角坐标系分隔线类型
    axisSplitLineType: lineTypeSolid,
    // 极坐标系分隔线类型
    polarAxisSplitLineType: lineTypeSolid,
    // 坐标轴指示器标线类型
    axisPointerLineType: lineTypeSolid,
    // 坐标轴名称间距
    axisNameSpace: space2x,
    // 坐标轴文本间距
    axisLabelSpace: spaceBase,
    // 标识线宽度
    markLineWidth: borderBase,
    // 标识线高亮宽度
    markLineEmphasisWidth: borderBase,
    //  border 0
    borderWidthNone: borderNone,
    // 标题文本间距
    titleSpace: space2x,
    // 容器的间距
    containerGap: space2x,
    // 容器的圆角
    containerBoderRadius: borderRadiusLg,
    // 图元
    symbolSizeLG: size3x,
    // 图元 雷达图用
    symbolSize: size3x,
    // 图元 超大
    symbolSizeSM: size2x,
    // 图元的边框
    symbolBorderWidth: border2x,
    // 图元的边框 雷达图专用
    symbolBorderWidthSM: border2x,
    // 柱条的宽度
    barWidth: size4x,
    // 堆叠进度图宽度 20
    barWidthLG: size5x,
    // label字号
    labelFontSize: fontSizeBase,
    // labelLine的长度
    labelLineLength: size6x,
    // 边框 细
    borderWidth: borderBase,
    // 边框
    borderWidthLG: border2x,
    // 圆角 0
    borderRadiusNone,
    // 圆角 小
    borderRadius: borderRadiusBase,
    // series.lineStyle
    lineWidth: border2x,
    // series.lineStyle 0
    lineWidthNone: borderNone,
    // 图例单元尺寸
    legendItemSize: 2,
    // 图例圆形单元尺寸
    legendCircleItemSize: 12,
    // 图例的间距
    legendSpace: space8x,
    // 无padding
    paddingNone: spaceNone,
    paddingSM: spaceBase,
    padding: space2x,
    paddingLG: space4x
  };
}
var aliasTokenMap = (_aliasTokenMap = {}, _aliasTokenMap[THEMES.LIGHT] = getAliasToken$3, _aliasTokenMap[THEMES.DARK] = function(globalToken2) {
  return getAliasToken$3(globalToken2, false);
}, _aliasTokenMap[THEMES.BPIT_LIGHT] = getAliasToken$1, _aliasTokenMap[THEMES.BPIT_DARK] = function(globalToken2) {
  return getAliasToken$1(globalToken2, false);
}, _aliasTokenMap[THEMES.CLOUD_LIGHT] = getAliasToken$2, _aliasTokenMap[THEMES.CLOUD_DARK] = function(globalToken2) {
  return getAliasToken$2(globalToken2, false);
}, _aliasTokenMap[THEMES.HDESIGN_LIGHT] = getAliasToken$1, _aliasTokenMap[THEMES.HDESIGN_DARK] = function(globalToken2) {
  return getAliasToken$1(globalToken2, false);
}, _aliasTokenMap);
function getAliasToken(themeName, globalToken2) {
  return _extends({}, aliasTokenMap[themeName](globalToken2));
}
function getModelToken(aliasToken) {
  var colorBgPrimary = aliasToken.colorBgPrimary, colorTextPrimary = aliasToken.colorTextPrimary, colorDash = aliasToken.colorDash, colorBgSecondary = aliasToken.colorBgSecondary, colorTextTransparent = aliasToken.colorTextTransparent, colorIconPrimary = aliasToken.colorIconPrimary, colorTextSecondary = aliasToken.colorTextSecondary, colorAxisLine = aliasToken.colorAxisLine, colorInactive = aliasToken.colorInactive, colorIconDisabled = aliasToken.colorIconDisabled, colorAxisTickLine = aliasToken.colorAxisTickLine, colorAxisSplitLine = aliasToken.colorAxisSplitLine, colorAxisPointerLine = aliasToken.colorAxisPointerLine, colorAxisPointerShadow = aliasToken.colorAxisPointerShadow, colorShadow = aliasToken.colorShadow, shadowOffsetY = aliasToken.shadowOffsetY, shadowBlur = aliasToken.shadowBlur, titleSpace = aliasToken.titleSpace, titleFontSize = aliasToken.titleFontSize, subtitleFontSize = aliasToken.subtitleFontSize, subtextFontSize = aliasToken.subtextFontSize, axisLabelSpace = aliasToken.axisLabelSpace, axisLineType = aliasToken.axisLineType, axisLineWidth = aliasToken.axisLineWidth, axisTickLineType = aliasToken.axisTickLineType, axisSplitLineType = aliasToken.axisSplitLineType, axisTickLineWidth = aliasToken.axisTickLineWidth, axisSplitLineWidth = aliasToken.axisSplitLineWidth, axisPointerLineType = aliasToken.axisPointerLineType, axisPointerLineWidth = aliasToken.axisPointerLineWidth, polarAxisSplitLineType = aliasToken.polarAxisSplitLineType, textFontSize = aliasToken.textFontSize, axisNameSpace = aliasToken.axisNameSpace, legendSpace = aliasToken.legendSpace, legendItemSize = aliasToken.legendItemSize, legendCircleItemSize = aliasToken.legendCircleItemSize, containerGap = aliasToken.containerGap, markLineWidth = aliasToken.markLineWidth, markLineEmphasisWidth = aliasToken.markLineEmphasisWidth, colorBorder = aliasToken.colorBorder, borderWidthNone = aliasToken.borderWidthNone, containerBoderRadius = aliasToken.containerBoderRadius, paddingNone = aliasToken.paddingNone, paddingLG = aliasToken.paddingLG;
  return {
    /** -----标题------ */
    // 主副标题之前的间距
    titleItemGap: titleSpace,
    // 标题文本颜色
    titleTextColor: colorTextPrimary,
    // 标题副文本颜色
    titleSubTextColor: colorTextSecondary,
    // 标题文本字号
    titleTextFontSize: titleFontSize,
    // 标题副文本字号
    titleSubtextFontSize: subtitleFontSize,
    /** -----图例------ */
    // 图例文本颜色
    legendTextColor: colorTextSecondary,
    // 图例富文本颜色
    legendTextRichColor: colorTextSecondary,
    // 图例文本字号
    legendTextFontSize: subtextFontSize,
    // 图例富文本颜色
    legendTextRichFontSize: subtextFontSize,
    // 图例文本的padding
    legendTextPadding: [containerGap / 2, 0, 0, 0],
    // 图例富文本的padding
    legendTextRichPadding: [containerGap / 2, 0, 0, 0],
    // 图例每项之间的间隔
    legendItemGap: legendSpace,
    // 圆形图例时每项的宽度
    legendCircleItemWidth: legendItemSize * 12,
    // 圆形图例时每项的高度
    legendCircleItemHeight: legendCircleItemSize,
    // 方形图例时每项的宽度
    legendReactItemWidth: legendItemSize * 6,
    // 方形图例时每项的高度
    legendReactItemHeight: legendItemSize,
    // 图例翻页文本颜色
    legendPageTextColor: colorTextPrimary,
    // 图例翻页图标激活颜色
    legendPageIconColor: colorIconPrimary,
    // 图例翻页图标失效颜色
    legendPageIconInactiveColor: colorIconDisabled,
    // 图例失效颜色
    legendInactiveColor: colorInactive,
    // 图例失效边框颜色
    legendInactiveBorderColor: colorBorder,
    // 图例边框宽度
    legendBorderWidth: borderWidthNone,
    // 图例失效边框宽度
    legendInactiveBorderWidth: borderWidthNone,
    // 图例图形边框宽度
    legendItemBorderWidth: borderWidthNone,
    // 图例的padding
    legendPadding: paddingNone,
    /** -----x轴------ */
    // x轴名称间距
    xAxisNameGap: axisNameSpace,
    // x轴名称颜色
    xAxisNameColor: colorTextSecondary,
    // x轴名称字号
    xAxisNameFontSize: textFontSize,
    // x轴标签文本颜色
    xAxisLabelColor: colorTextSecondary,
    // x轴标签文本字号
    xAxisLabelFontSize: subtextFontSize,
    // x轴轴线颜色
    xAxisLineColor: colorAxisLine,
    // x轴轴线粗细
    xAxisLineWidth: axisLineWidth,
    // x轴轴线类别
    xAxisLineType: axisLineType,
    // x轴刻度线颜色
    xAxisTickLineColor: colorAxisTickLine,
    // x轴刻度线粗细
    xAxisTickLineWidth: axisTickLineWidth,
    // x轴刻度线类别
    xAxisTickLineType: axisTickLineType,
    // x轴分隔线颜色
    xAxisSplitLineColor: colorAxisSplitLine,
    // x轴分隔线粗细
    xAxisSplitLineWidth: axisSplitLineWidth,
    // x轴分隔线类别
    xAxisSplitLineType: axisSplitLineType,
    /** -----y轴------ */
    // y轴名称间距
    yAxisNameGap: axisNameSpace,
    // y轴名称颜色
    yAxisNameColor: colorTextSecondary,
    // y轴名称字号
    yAxisNameFontSize: textFontSize,
    // y轴标签文本颜色
    yAxisLabelColor: colorTextSecondary,
    // y轴标签文本字号
    yAxisLabelFontSize: subtextFontSize,
    // y轴轴线颜色
    yAxisLineColor: colorAxisLine,
    // y轴轴线粗细
    yAxisLineWidth: axisLineWidth,
    // y轴轴线类别
    yAxisLineType: axisLineType,
    // y轴刻度线颜色
    yAxisTickLineColor: colorAxisTickLine,
    // y轴刻度线粗细
    yAxisTickLineWidth: axisTickLineWidth,
    // y轴刻度线类别
    yAxisTickLineType: axisTickLineType,
    // y轴分隔线颜色
    yAxisSplitLineColor: colorAxisSplitLine,
    // y轴分隔线粗细
    yAxisSplitLineWidth: axisSplitLineWidth,
    // y轴分隔线类别
    yAxisSplitLineType: axisSplitLineType,
    /** -----radar轴------ */
    // radar轴名称颜色
    radarAxisNameColor: colorTextSecondary,
    // radar轴名字号
    radarAxisNameFontSize: subtextFontSize,
    // radar轴标签文本颜色
    radarAxisLabelColor: colorTextSecondary,
    // radar轴线颜色
    radarAxisLineColor: colorAxisLine,
    // radar轴线粗细
    radarAxisLineWidth: axisLineWidth,
    // radar轴线类别
    radarAxisLineType: axisLineType,
    // radar轴刻度线颜色
    radarAxisTickLineColor: colorAxisTickLine,
    // radar轴刻度线粗细
    radarAxisTickLineWidth: axisTickLineWidth,
    // radar轴刻度线类别
    radarAxisTickLineType: axisTickLineType,
    // radar轴分隔线颜色
    radarSplitLineColor: colorAxisSplitLine,
    // radar轴分隔线粗细
    radarSplitLineWidth: axisSplitLineWidth,
    // radar轴分隔线类别
    radarSplitLineType: polarAxisSplitLineType,
    /** -----极坐标系角度轴------ */
    // 角度轴标签文本颜色
    angleAxisLabelColor: colorTextSecondary,
    // 角度轴标签文本字号
    angleAxisLabelFontSize: subtextFontSize,
    // 角度轴轴线颜色
    angleAxisLineColor: colorAxisLine,
    // 角度轴轴线粗细
    angleAxisLineWidth: axisLineWidth,
    // 角度轴轴线类别
    angleAxisLineType: axisLineType,
    // 角度轴刻度线颜色
    angleAxisTickLineColor: colorAxisTickLine,
    // 角度轴刻度线粗细
    angleAxisTickLineWidth: axisTickLineWidth,
    // 角度轴刻度线类别
    angleAxisTickLineType: axisTickLineType,
    // 角度轴分隔线颜色
    angleAxisSplitLineColor: colorAxisSplitLine,
    // 角度轴分隔线粗细
    angleAxisSplitLineWidth: axisSplitLineWidth,
    // 角度轴分隔线类别
    angleAxisSplitLineType: polarAxisSplitLineType,
    /** -----极坐标系径向轴------ */
    // 径向轴标签间距
    radiusAxisLabelGap: axisLabelSpace,
    // 径向轴标签颜色
    radiusAxisLabelColor: colorTextSecondary,
    // 径向轴标签字号
    radiusAxisLabelFontSize: subtextFontSize,
    // 径向轴轴线颜色
    radiusAxisLineColor: colorAxisLine,
    // 径向轴轴线粗细
    radiusAxisLineWidth: axisLineWidth,
    // 径向轴轴线类别
    radiusAxisLineType: axisLineType,
    // 径向轴刻度线颜色
    radiusAxisTickLineColor: colorAxisTickLine,
    // 径向轴刻度线粗细
    radiusAxisTickLineWidth: axisTickLineWidth,
    // 径向轴刻度线类别
    radiusAxisTickLineType: axisTickLineType,
    // 径向轴分隔线颜色
    radiusAxisSplitLineColor: colorAxisSplitLine,
    // 径向轴分隔线粗细
    radiusAxisSplitLineWidth: axisSplitLineWidth,
    // 径向轴分隔线类别
    radiusAxisSplitLineType: axisSplitLineType,
    /** -----tooltip------ */
    // tip背景
    tooltipBg: colorBgSecondary,
    // tip文本颜色
    tooltipTextColor: colorTextPrimary,
    // tip文本字号
    tooltipTextFontSize: textFontSize,
    // tip圆角
    tooltipBorderRaduis: containerBoderRadius,
    // tip坐标轴指示器线颜色
    tooltipAxisPointerLineColor: colorAxisPointerLine,
    // tip坐标轴指示器线粗细
    tooltipAxisPointerLineWidth: axisPointerLineWidth,
    // tip坐标轴指示器线类别
    tooltipAxisPointerLineType: axisPointerLineType,
    // tip坐标轴指示器阴影
    tooltipAxisPointerShadowColor: colorAxisPointerShadow,
    // tip阴影
    tooltipShadowColor: colorShadow,
    // tip阴影垂直方向偏移
    tooltipShadowOffsetY: shadowOffsetY,
    // tip阴影模糊
    tooltipShadowBlur: shadowBlur,
    // tip边框
    tooltipBorderWidth: borderWidthNone,
    // tip的padding
    tooltipPadding: paddingLG,
    /** -----visualMap------ */
    // PiecesColor
    visualMapPiecesColor: colorTextTransparent,
    // dashColor
    visualMapDashColor: colorDash,
    /** -----markPoint------ */
    // markPoint标签文本
    markPointLabelColor: colorTextTransparent,
    /** ----- markLine------ */
    // 标记线粗细
    markLineWidth,
    // 标记线高亮粗细
    markLineEmphasisWidth,
    /** ----- markLine------ */
    // 手柄中心填充色
    dataZoomHandleColor: colorBgSecondary,
    // 手柄外框色
    dataZoomHandleBorderColor: colorBgPrimary,
    // 手柄阴影色
    dataZoomHandleShadowColor: colorAxisPointerShadow,
    // 手柄hover时中心填充色(todo待处理)
    dataZoomEmphasisHandleColor: colorTextPrimary,
    // 手柄hover时外框色
    dataZoomEmphasisHandleBorderColor: colorBgPrimary
  };
}
var BarChart$2 = function BarChart$22(aliasToken) {
  var borderWidth = aliasToken.borderWidth, barWidth = aliasToken.barWidth, colorLabel = aliasToken.colorLabel, labelFontSize = aliasToken.labelFontSize, colorBorderTransparent = aliasToken.colorBorderTransparent, borderRadius2 = aliasToken.borderRadius, colorBgTransparent = aliasToken.colorBgTransparent;
  return {
    itemStyle: {
      borderWidth,
      borderColor: colorBorderTransparent,
      borderRadius: borderRadius2,
      color: colorBgTransparent
    },
    label: {
      color: colorLabel,
      fontSize: labelFontSize
    },
    barWidth
  };
};
var BarChart$3 = BarChart$2;
var BubbleChart$2 = function BubbleChart$22(aliasToken) {
  var colorLabel = aliasToken.colorLabel;
  return {
    emphasis: {
      label: {
        color: colorLabel
      }
    }
  };
};
var BubbleChart$3 = BubbleChart$2;
var FunnelChart$1 = function FunnelChart$12(aliasToken) {
  var colorLabel = aliasToken.colorLabel, colorBorder = aliasToken.colorBorder;
  return {
    itemStyle: {
      borderColor: colorBorder
    },
    label: {
      color: colorLabel
    }
  };
};
var FunnelChart$2 = FunnelChart$1;
var HillChart = function HillChart2(aliasToken) {
  var colorLabel = aliasToken.colorLabel, colorBorder = aliasToken.colorBorder;
  return {
    label: {
      color: colorLabel
    },
    emphasis: {
      itemStyle: {
        borderColor: colorBorder
      }
    }
  };
};
var HillChart$1 = HillChart;
var JadeJueChart = function JadeJueChart2(aliasToken) {
  var barWidth = aliasToken.barWidth, colorBorder = aliasToken.colorBorder, colorBgEmpty = aliasToken.colorBgEmpty;
  return {
    barWidth,
    itemStyle: {
      borderColor: colorBorder,
      // 做背景特殊
      color: colorBgEmpty
    }
  };
};
var JadeJueChart$1 = JadeJueChart;
var TreeChart$2 = function TreeChart$22(aliasToken) {
  var colorLabel = aliasToken.colorLabel, colorAxisLine = aliasToken.colorAxisLine;
  return {
    label: {
      color: colorLabel
    },
    lineStyle: {
      color: colorAxisLine
    }
  };
};
var TreeChart$3 = TreeChart$2;
var SunburstChart$1 = function SunburstChart$12(aliasToken) {
  var colorBorder = aliasToken.colorBorder, colorLabel = aliasToken.colorLabel;
  return {
    itemStyle: {
      borderColor: colorBorder
    },
    label: {
      color: colorLabel
    }
  };
};
var SunburstChart$2 = SunburstChart$1;
var SankeyChart$2 = function SankeyChart$22(aliasToken) {
  var colorLabel = aliasToken.colorLabel;
  return {
    label: {
      color: colorLabel
    }
  };
};
var SankeyChart$3 = SankeyChart$2;
function RadarChart$2(aliasToken) {
  var colorBorder = aliasToken.colorBorder, borderWidthLG = aliasToken.borderWidthLG, symbolSizeLG = aliasToken.symbolSizeLG, symbolSize = aliasToken.symbolSize, lineWidth = aliasToken.lineWidth, lineWidthNone = aliasToken.lineWidthNone, colorBgTransparent = aliasToken.colorBgTransparent, symbolBorderWidth = aliasToken.symbolBorderWidth, symbolBorderWidthSM = aliasToken.symbolBorderWidthSM;
  return {
    symbolBorderWidth,
    symbolBorderWidthSM,
    symbolSizeLG,
    areaStyleColor: colorBgTransparent,
    symbolSize,
    border: borderWidthLG,
    lineWidth,
    lineWidthNone,
    borderColor: colorBorder
  };
}
var ProcessChart$2 = function ProcessChart$22(aliasToken) {
  var colorAxisLine = aliasToken.colorAxisLine, colorLabel = aliasToken.colorLabel, colorTextDisabled = aliasToken.colorTextDisabled, colorBgEmpty = aliasToken.colorBgEmpty, colorTextSecondary = aliasToken.colorTextSecondary;
  return {
    axisLine: {
      lineStyle: {
        color: colorAxisLine
      },
      label: {
        color: colorTextSecondary
      }
    },
    label: {
      color: colorLabel,
      disabledColor: colorTextDisabled
    },
    itemStyle: {
      color: colorBgEmpty
    }
  };
};
var ProcessChart$3 = ProcessChart$2;
var PolarBarChart = function PolarBarChart2(aliasToken) {
  var colorTextSecondary = aliasToken.colorTextSecondary;
  return {
    // 坐标轴label
    label: {
      color: colorTextSecondary
    }
  };
};
var PolarBarChart$1 = PolarBarChart;
var PieChart$2 = function PieChart$22(aliasToken) {
  var colorBorder = aliasToken.colorBorder, borderWidthLG = aliasToken.borderWidthLG, borderWidthNone = aliasToken.borderWidthNone, colorLabel = aliasToken.colorLabel, labelFontSize = aliasToken.labelFontSize, labelLineLength = aliasToken.labelLineLength, colorLabelLine = aliasToken.colorLabelLine, borderRadiusNone = aliasToken.borderRadiusNone, colorBgEmpty = aliasToken.colorBgEmpty;
  return {
    itemStyle: {
      borderWidth: borderWidthLG,
      borderColor: colorBorder,
      borderWidthNone,
      borderRadius: borderRadiusNone
    },
    label: {
      distance: labelLineLength,
      color: colorLabel,
      fontSize: labelFontSize
    },
    lineStyle: {
      color: colorLabelLine
    },
    emptyCircleStyle: {
      color: colorBgEmpty
    }
  };
};
var PieChart$3 = PieChart$2;
var AreaChart = function AreaChart2(aliasToken) {
  var colorBgTransparent = aliasToken.colorBgTransparent;
  return {
    areaStyle: {
      color: colorBgTransparent
    }
  };
};
var AreaChart$1 = AreaChart;
var LineChart$2 = function LineChart$22(aliasToken) {
  var colorBorder = aliasToken.colorBorder, borderWidthLG = aliasToken.borderWidthLG, borderWidthNone = aliasToken.borderWidthNone, symbolSizeLG = aliasToken.symbolSizeLG, symbolSizeSM = aliasToken.symbolSizeSM, lineWidth = aliasToken.lineWidth, colorLineTransparent = aliasToken.colorLineTransparent;
  return {
    symbolSize: {
      symbolSizeSM,
      symbolSizeLG
    },
    lineStyle: {
      lineWidth
    },
    itemStyle: {
      borderZero: borderWidthNone,
      border: borderWidthLG,
      borderColor: colorBorder
    },
    markLine: {
      lineStyle: {
        color: colorLineTransparent
      }
    }
  };
};
var LineChart$3 = LineChart$2;
var AssembleBubbleChart = function AssembleBubbleChart2(aliasToken) {
  var colorLabel = aliasToken.colorLabel, colorLabelDisabled = aliasToken.colorLabelDisabled, colorBorderDisabled = aliasToken.colorBorderDisabled, colorInactive = aliasToken.colorInactive;
  return {
    label: {
      color: colorLabel,
      disabledColor: colorLabelDisabled
    },
    disabledBorderColor: colorBorderDisabled,
    itemStyle: {
      disabledColor: colorInactive
    }
  };
};
var AssembleBubbleChart$1 = AssembleBubbleChart;
var BoxplotChart$1 = function BoxplotChart$12(aliasToken) {
  var colorBgPrimary = aliasToken.colorBgPrimary;
  return {
    itemStyle: {
      color: colorBgPrimary
    }
  };
};
var BoxplotChart$2 = BoxplotChart$1;
var CandlestickChart$2 = function CandlestickChart$22(aliasToken) {
  var colorTextSecondary = aliasToken.colorTextSecondary;
  return {
    axisPointer: {
      label: {
        color: colorTextSecondary
      }
    }
  };
};
var CandlestickChart$3 = CandlestickChart$2;
var CircleProcessChart = function CircleProcessChart2(aliasToken) {
  var colorBgEmpty = aliasToken.colorBgEmpty;
  return {
    backgroundStyle: {
      color: colorBgEmpty
    }
  };
};
var CircleProcessChart$1 = CircleProcessChart;
var GaugeChart$2 = function GaugeChart$22(aliasToken) {
  var colorAxisLine = aliasToken.colorAxisLine, colorBgEmpty = aliasToken.colorBgEmpty, colorTextSecondary = aliasToken.colorTextSecondary, colorTextPrimary = aliasToken.colorTextPrimary;
  return {
    // 用于轨道，特殊使用空数据颜色
    splitLine: {
      lineStyle: {
        color: colorBgEmpty
      }
    },
    axisLine: {
      lineStyle: {
        color: colorAxisLine
      }
    },
    axisLabel: {
      color: colorTextSecondary
    },
    detail: {
      rich: {
        color: colorTextPrimary
      }
    }
  };
};
var GaugeChart$3 = GaugeChart$2;
var HeatMapChart$2 = function HeatMapChart$22(aliasToken) {
  var colorAxisLine = aliasToken.colorAxisLine, colorTextPrimary = aliasToken.colorTextPrimary, colorLabel = aliasToken.colorLabel, colorBorder = aliasToken.colorBorder;
  return {
    axisLine: {
      lineStyle: {
        color: colorAxisLine
      }
    },
    visualMap: {
      text: {
        color: colorTextPrimary
      }
    },
    label: {
      color: colorLabel
    },
    custom: {
      style: {
        stroke: colorBorder
      }
    }
  };
};
var HeatMapChart$3 = HeatMapChart$2;
var ScatterChart = function ScatterChart2(aliasToken) {
  var colorBgPrimary = aliasToken.colorBgPrimary;
  return {
    itemStyle: {
      color: colorBgPrimary
    }
  };
};
var ScatterChart$1 = ScatterChart;
var LiquidfillChart$1 = function LiquidfillChart$12(aliasToken) {
  var colorLabel = aliasToken.colorLabel, colorBgPrimary = aliasToken.colorBgPrimary;
  return {
    label: {
      color: colorLabel
    },
    backgroundStyle: {
      color: colorBgPrimary
    }
  };
};
var LiquidfillChart$2 = LiquidfillChart$1;
var RegionChart$1 = function RegionChart$12(aliasToken) {
  var colorTextPrimary = aliasToken.colorTextPrimary;
  return {
    visualMap: {
      textStyle: {
        color: colorTextPrimary
      }
    }
  };
};
var RegionChart$2 = RegionChart$1;
var WaveChart = function WaveChart2(aliasToken) {
  var colorAxisLine = aliasToken.colorAxisLine, colorTextSecondary = aliasToken.colorTextSecondary, colorAxisSplitLine = aliasToken.colorAxisSplitLine;
  return {
    axisLineColor: colorAxisLine,
    axisLabelColor: colorTextSecondary,
    axisNameColor: colorTextSecondary,
    splitLineColor: colorAxisSplitLine
  };
};
var WaveChart$1 = WaveChart;
var WordCloudChart$2 = function WordCloudChart$22(aliasToken) {
  var colorShadow = aliasToken.colorShadow;
  return {
    emphasis: {
      textStyle: {
        textShadowColor: colorShadow
      }
    }
  };
};
var WordCloudChart$3 = WordCloudChart$2;
function getChartsToken(aliasToken) {
  return {
    AssembleBubbleChart: AssembleBubbleChart$1(aliasToken),
    BarChart: BarChart$3(aliasToken),
    BoxplotChart: BoxplotChart$2(aliasToken),
    BubbleChart: BubbleChart$3(aliasToken),
    CandlestickChart: CandlestickChart$3(aliasToken),
    CircleProcessChart: CircleProcessChart$1(aliasToken),
    FunnelChart: FunnelChart$2(aliasToken),
    GaugeChart: GaugeChart$3(aliasToken),
    HeatMapChart: HeatMapChart$3(aliasToken),
    ScatterChart: ScatterChart$1(aliasToken),
    HillChart: HillChart$1(aliasToken),
    JadeJueChart: JadeJueChart$1(aliasToken),
    LineChart: LineChart$3(aliasToken),
    AreaChart: AreaChart$1(aliasToken),
    LiquidfillChart: LiquidfillChart$2(aliasToken),
    PieChart: PieChart$3(aliasToken),
    PolarBarChart: PolarBarChart$1(aliasToken),
    ProcessChart: ProcessChart$3(aliasToken),
    RadarChart: RadarChart$2(aliasToken),
    RegionChart: RegionChart$2(aliasToken),
    SankeyChart: SankeyChart$3(aliasToken),
    SunburstChart: SunburstChart$2(aliasToken),
    TreeChart: TreeChart$3(aliasToken),
    WaveChart: WaveChart$1(aliasToken),
    WordCloudChart: WordCloudChart$3(aliasToken)
  };
}
function getToken(themeName) {
  var globalToken2 = getGlobalToken(themeName);
  var aliasToken = getAliasToken(themeName, globalToken2);
  var modelToken = getModelToken(aliasToken);
  var chartsToken = getChartsToken(aliasToken);
  return _extends({}, color$1[themeName].colorSet, modelToken, chartsToken);
}
var ictLight = getToken(THEMES.LIGHT);
var ictDark = getToken(THEMES.DARK);
var bpitLight = getToken(THEMES.BPIT_LIGHT);
var bpitDark = getToken(THEMES.BPIT_DARK);
var cloudLight = getToken(THEMES.CLOUD_LIGHT);
var cloudDark = getToken(THEMES.CLOUD_DARK);
var hdesignLight = getToken(THEMES.HDESIGN_LIGHT);
var hdesignDark = getToken(THEMES.HDESIGN_DARK);
var HashMap = /* @__PURE__ */ function() {
  function HashMap2(initObj) {
    this.data = newMap();
    for (var key in initObj) {
      if (Object.hasOwnProperty.call(initObj, key)) {
        this.set(key, initObj[key]);
      }
    }
  }
  var _proto = HashMap2.prototype;
  _proto.hasKey = function hasKey(key) {
    return this.data.has(key);
  };
  _proto.get = function get(key) {
    return this.data.get(key);
  };
  _proto.set = function set(key, value) {
    this.data.set(key, value);
    return value;
  };
  _proto.each = function each3(callback, context) {
    this.data.forEach(function(value, key) {
      callback.call(context, value, key);
    });
  };
  _proto.keys = function keys() {
    var keys2 = this.data.keys();
    return typeof Map === "function" ? Array.from(keys2) : keys2;
  };
  _proto.removeKey = function removeKey(key) {
    this.data.delete(key);
  };
  return HashMap2;
}();
function newMap() {
  return typeof Map === "function" ? /* @__PURE__ */ new Map() : new MapPolyfill();
}
var MapPolyfill = /* @__PURE__ */ function() {
  function MapPolyfill2() {
  }
  var _proto2 = MapPolyfill2.prototype;
  _proto2.delete = function _delete(key) {
    var existed = this.has(key);
    if (existed) {
      delete this.data[key];
    }
    return existed;
  };
  _proto2.has = function has(key) {
    return Object.prototype.hasOwnProperty.call(this.data, key);
  };
  _proto2.get = function get(key) {
    return this.data[key];
  };
  _proto2.set = function set(key, value) {
    this.data[key] = value;
    return this;
  };
  _proto2.keys = function keys() {
    return _keys(this.data);
  };
  _proto2.forEach = function forEach(callback) {
    var data3 = this.data;
    for (var key in data3) {
      if (Object.prototype.hasOwnProperty.call(data3, key)) {
        callback(data3[key], key);
      }
    }
  };
  return MapPolyfill2;
}();
function _keys(obj2) {
  if (!obj2) {
    return [];
  }
  if (Object.keys) {
    return Object.keys(obj2);
  }
  var keyList = [];
  for (var key in obj2) {
    if (Object.prototype.hasOwnProperty.call(obj2, key)) {
      keyList.push(key);
    }
  }
  return keyList;
}
var HashMap$1 = HashMap;
function getBasicToken(name2, config2) {
  return _extends({}, getGlobalToken(name2), config2);
}
function getMapToken(name2, config2) {
  return _extends({}, aliasTokenMap[name2](config2), config2);
}
function getConfigModelToken(config2) {
  return _extends({}, getModelToken(config2), config2);
}
function mergeSpecialToken(name2, chartsConfig, config2) {
  TOKENCHARTNAMES.forEach(function(item) {
    if (config2[item])
      merge(chartsConfig, config2[item]);
  });
  var colorState2 = config2.colorState;
  if (colorState2) {
    var newColorState = merge(cloneDeep(color$1[name2].colorSet.colorState), colorState2);
    return _extends({}, chartsConfig, {
      colorState: newColorState
    });
  }
  return _extends({}, chartsConfig);
}
function mergeToken(name2, config2) {
  var basicConfig = getBasicToken(name2, config2);
  var mapConfig = getMapToken(name2, basicConfig);
  var modelConfig = getConfigModelToken(mapConfig);
  var chartsConfig = getChartsToken(mapConfig);
  var specialConfig = mergeSpecialToken(name2, chartsConfig, config2);
  return _extends({
    colorGroup: basicConfig.colorGroup
  }, modelConfig, specialConfig);
}
var themeToken = new HashMap$1((_HashMap$ = {}, _HashMap$[THEMES.LIGHT] = cloneDeep(ictLight), _HashMap$[THEMES.DARK] = cloneDeep(ictDark), _HashMap$[THEMES.BPIT_LIGHT] = cloneDeep(bpitLight), _HashMap$[THEMES.BPIT_DARK] = cloneDeep(bpitDark), _HashMap$[THEMES.CLOUD_LIGHT] = cloneDeep(cloudLight), _HashMap$[THEMES.CLOUD_DARK] = cloneDeep(cloudDark), _HashMap$[THEMES.HDESIGN_LIGHT] = cloneDeep(hdesignLight), _HashMap$[THEMES.HDESIGN_DARK] = cloneDeep(hdesignDark), _HashMap$[CURRENT_THEME] = cloneDeep(ictLight), _HashMap$));
var Theme = /* @__PURE__ */ function() {
  function Theme2() {
  }
  Theme2.set = function set(name2, config2) {
    var defaultConfig = cloneDeep(this.getConfig(DEFAULT_THEME_NAME));
    merge(defaultConfig, config2);
    themeToken.set(name2, defaultConfig);
  };
  Theme2.setConfig = function setConfig(name2, config2) {
    var themeKeys = this.getThemeKeys();
    var validate = themeKeys.includes(name2);
    if (validate) {
      var newConfig = mergeToken(name2, config2);
      var oldConfig = this.getConfig(name2);
      merge(oldConfig, newConfig);
    } else {
      var _newConfig = mergeToken(DEFAULT_THEME_NAME, config2);
      themeToken.set(name2, _newConfig);
    }
  };
  Theme2.getThemeKeys = function getThemeKeys() {
    return themeToken.keys();
  };
  Theme2.resetThemeCongfig = function resetThemeCongfig() {
    themeToken.set(THEMES.LIGHT, cloneDeep(ictLight));
    themeToken.set(THEMES.DARK, cloneDeep(ictDark));
    themeToken.set(THEMES.BPIT_LIGHT, cloneDeep(bpitLight));
    themeToken.set(THEMES.BPIT_DARK, cloneDeep(bpitDark));
    themeToken.set(THEMES.CLOUD_LIGHT, cloneDeep(cloudLight));
    themeToken.set(THEMES.CLOUD_DARK, cloneDeep(cloudDark));
    themeToken.set(THEMES.HDESIGN_LIGHT, cloneDeep(hdesignLight));
    themeToken.set(THEMES.HDESIGN_DARK, cloneDeep(hdesignDark));
    themeToken.set(CURRENT_THEME, cloneDeep(ictLight));
  };
  Theme2.getConfig = function getConfig(name2) {
    return themeToken.get(name2);
  };
  Theme2.setDefaultTheme = function setDefaultTheme2(name2) {
    var tempTheme = this.validate(name2);
    if (this.themeName !== tempTheme) {
      this.themeName = tempTheme;
      themeToken.set(CURRENT_THEME, themeToken.get(tempTheme));
      this.config = this.getConfig(CURRENT_THEME);
    }
  };
  Theme2.validate = function validate(name2) {
    var tempTheme = name2 || this.themeName || DEFAULT_THEME_NAME;
    if (tempTheme.toLowerCase().includes("cloud-light")) {
      tempTheme = THEMES.CLOUD_LIGHT;
    }
    if (tempTheme.toLowerCase().includes("cloud-dark")) {
      tempTheme = THEMES.CLOUD_DARK;
    }
    var themeKeys = themeToken.keys();
    var validate2 = themeKeys.includes(tempTheme);
    if (!validate2) {
      tips.error(THEME_ERROR_TIP_MESSAGE);
      tempTheme = THEMES.LIGHT;
    }
    return tempTheme;
  };
  Theme2.getTokenByName = function getTokenByName(chartName2) {
    var token = _extends({}, this.config[chartName2]);
    return new Proxy({}, {
      get: function get(_, prop) {
        return token[prop];
      }
    });
  };
  return Theme2;
}();
Theme.themeName = void 0;
Theme.config = cloneDeep(bpitLight);
var Theme$1 = Theme;
function throttle(delay2, callback, options2) {
  var _ref6 = options2 || {}, _ref6$noTrailing = _ref6.noTrailing, noTrailing = _ref6$noTrailing === void 0 ? false : _ref6$noTrailing, _ref6$noLeading = _ref6.noLeading, noLeading = _ref6$noLeading === void 0 ? false : _ref6$noLeading, _ref6$debounceMode = _ref6.debounceMode, debounceMode = _ref6$debounceMode === void 0 ? void 0 : _ref6$debounceMode;
  var timeoutID;
  var cancelled = false;
  var lastExec = 0;
  function clearExistingTimeout() {
    if (timeoutID) {
      clearTimeout(timeoutID);
    }
  }
  function cancel(options22) {
    var _ref7 = options22 || {}, _ref7$upcomingOnly = _ref7.upcomingOnly, upcomingOnly = _ref7$upcomingOnly === void 0 ? false : _ref7$upcomingOnly;
    clearExistingTimeout();
    cancelled = !upcomingOnly;
  }
  function wrapper() {
    for (var _len = arguments.length, arguments_ = new Array(_len), _key = 0; _key < _len; _key++) {
      arguments_[_key] = arguments[_key];
    }
    var self2 = this;
    var elapsed = Date.now() - lastExec;
    if (cancelled) {
      return;
    }
    function exec() {
      lastExec = Date.now();
      callback.apply(self2, arguments_);
    }
    function clear() {
      timeoutID = void 0;
    }
    if (!noLeading && debounceMode && !timeoutID) {
      exec();
    }
    clearExistingTimeout();
    if (debounceMode === void 0 && elapsed > delay2) {
      if (noLeading) {
        lastExec = Date.now();
        if (!noTrailing) {
          timeoutID = setTimeout(debounceMode ? clear : exec, delay2);
        }
      } else {
        exec();
      }
    } else if (noTrailing !== true) {
      timeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === void 0 ? delay2 - elapsed : delay2);
    }
  }
  wrapper.cancel = cancel;
  return wrapper;
}
function axistip(echartsDom, echartsIns, eChartOption) {
  if (isArray(eChartOption)) {
    var _eChartOption$xAxis;
    (_eChartOption$xAxis = eChartOption.xAxis) == null ? void 0 : _eChartOption$xAxis.forEach(function(item) {
      item.triggerEvent = true;
    });
  }
  var tipContainer = document.createElement("div");
  tipContainer.className = "labeltip";
  echartsIns.on("mousemove", function(param) {
    if (param.componentType === "xAxis") {
      tipContainer.textContent = param.value;
      var tipContainerReact = tipContainer.getBoundingClientRect();
      var echartsDomRect = echartsDom.getBoundingClientRect();
      var echartsDomStyle = getComputedStyle(echartsDom);
      var echartsDomBorder = parseFloat(echartsDomStyle.borderRightWidth) + parseFloat(echartsDomStyle.borderLeftWidth);
      var tipContainerW = tipContainerReact.width;
      var tipContainerH = tipContainerReact.height;
      var _param$event = param.event, offsetX = _param$event.offsetX, offsetY = _param$event.offsetY;
      var tipLeft = 0;
      var tipTop = 0;
      if (tipContainerW < echartsDomRect.width - echartsDomBorder) {
        tipTop = offsetY - 16;
        var reviseL = echartsDomRect.width - echartsDomBorder - offsetX - tipContainerW - 16;
        if (reviseL > 0) {
          tipLeft = offsetX + 16;
        } else {
          tipLeft = offsetX - tipContainerW - 16;
        }
      } else {
        tipTop = offsetY - tipContainerH - 16;
      }
      tipContainer.style.cssText = "\n        position: absolute;\n        display: inline-block;\n        word-break: break-all;\n        padding: 8px;\n        top:" + tipTop + "px;\n        left:" + tipLeft + "px;\n        color: " + Theme$1.config.tooltipTextColor + ";\n        font-size: 14px;\n        background: " + Theme$1.config.tooltipBg + ";\n        box-shadow:0 " + Theme$1.config.tooltipShadowOffsetY + "px \n        " + Theme$1.config.tooltipShadowBlur + "px 0 " + Theme$1.config.tooltipShadowColor + ";\n      ";
    }
  });
  echartsIns.on("mouseout", function(param) {
    if (param.componentType === "xAxis") {
      tipContainer.textContent = "";
      tipContainer.style.cssText = "\n      opacity:0;\n      position: absolute;\n      display: inline-block;\n      word-break: break-all;\n      padding: 8px;\n      font-size: 14px;";
    }
  });
  echartsDom.appendChild(tipContainer);
}
var matchHtmlRegExp = /["'&<>/]/;
function escapeHtml(string) {
  var str = "" + string;
  var match = matchHtmlRegExp.exec(str);
  if (!match) {
    return str;
  }
  var escape;
  var html = "";
  var index;
  var lastIndex = 0;
  for (index = match.index; index < str.length; index++) {
    switch (str.charCodeAt(index)) {
      case 34:
        escape = "&quot;";
        break;
      case 38:
        escape = "&amp;";
        break;
      case 39:
        escape = "&#x27;";
        break;
      case 60:
        escape = "&lt;";
        break;
      case 62:
        escape = "&gt;";
        break;
      case 47:
        escape = "&#x2F;";
        break;
      default:
        continue;
    }
    if (lastIndex !== index) {
      html += str.substring(lastIndex, index);
    }
    lastIndex = index + 1;
    html += escape;
  }
  return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
}
var defendXSS = function defendXSS2(obj2) {
  if (typeof obj2 === "string") {
    return escapeHtml(obj2);
  } else if (typeof obj2 === "number") {
    return obj2;
  } else if (typeof obj2 === "object") {
    for (var key in obj2) {
      obj2[key] = defendXSS2(obj2[key]);
    }
    return obj2;
  } else {
    return obj2;
  }
};
var defendXSS$1 = defendXSS;
var ERROR_SVG = function ERROR_SVG2(fillColor) {
  return '<svg width="80px" height="80px" viewBox="0 0 200 200" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">\n        <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">\n            <g transform="translate(5.000000, 41.000000)">\n                <path d="M135.649368,0 C140.813579,-9.48650299e-16 145,4.18642074 145,9.35063244 L145,30.3128 C145,31.2446148 144.244615,32 143.3128,32 L126.298735,32 L126.298735,32 L126.298735,9.35063244 C126.298735,4.18642074 130.485156,9.48650299e-16 135.649368,0 Z" fill-opacity="0.08" fill="' + fillColor + '"></path>\n                <path d="M135.666667,0 C140.821324,0 145,4.09339657 145,9.14285714 L145,29.7142857 C145,30.9766509 143.955331,32 142.666667,32 L125.885703,32 L125.885703,9.7809637 C125.885703,4.37908661 130.26479,9.92308723e-16 135.666667,0 L135.666667,0 L135.666667,0 Z M135.666667,2.05920206 L134.981839,2.05920206 C131.115845,2.05920206 127.981839,5.19320881 127.981839,9.05920206 L127.981839,29.9407979 L127.981839,29.9407979 L142.666667,29.9407979 C142.794372,29.9407979 142.897898,29.839385 142.897898,29.7142857 L142.897898,9.14285714 C142.897898,5.23066247 139.660365,2.05920206 135.666667,2.05920206 Z" fill="' + fillColor + '" fill-rule="nonzero"></path>\n                <path d="M128.031703,105.57885 L128.031724,136.725807 C128.031724,142.400087 123.427668,147 117.748276,147 L115,147 L115,144.863 L117.748276,144.863993 C122.246921,144.863993 125.893793,141.220403 125.893793,136.725807 L125.894079,106.401172 C126.620404,106.155789 127.333413,105.881214 128.031703,105.57885 Z M136.360709,0 C136.644838,0.899738066 136.524602,1.57454162 136,2.02441065 C131.599253,2.02441065 128.031742,5.59192129 128.031724,9.99266869 L128.031703,54.4211505 C127.333413,54.1187859 126.620404,53.8442105 125.894079,53.5988278 L125.893083,27.9709748 C125.893033,27.9381122 125.89298,27.9039511 125.892924,27.8684915 L125.892114,27.3806471 L125.891993,27.3109015 L125.891993,27.3109015 L125.891021,26.7681443 L125.890865,26.6828164 L125.890865,26.6828164 L125.890017,26.2269601 C125.889414,25.9068243 125.888739,25.5542254 125.887989,25.1691634 L125.887055,24.6915067 C125.880914,21.5676598 125.870528,16.5687428 125.855897,9.69475588 C125.849378,6.63789545 127.472127,3.8175724 130.098992,2.28334264 L130.356319,2.13891888 L23.2834482,2.13600695 C18.7848033,2.13600695 15.137931,5.77959709 15.137931,10.2741933 L15.137,117 L13,117 L13,10.2741933 C13,4.59991303 17.6040566,0 23.2834482,0 L136.360709,0 Z" fill="' + fillColor + '" fill-rule="nonzero"></path>\n                <path d="M105.29412,117 C106.166823,117 106.874288,117.706919 106.874288,118.578947 L106.874288,136.247276 C106.874288,140.105898 109.495409,144.895084 115.097369,144.895084 C118.616046,144.895084 115.289571,147 117,147 L15.0115833,147 C6.72091477,147 0,140.284265 0,132 L0,118.578947 C0,117.706919 0.707465271,117 1.58016791,117 L105.29412,117 Z M104.73844,119.133713 L2.13536204,119.133713 L2.13536204,132 C2.13536204,138.998182 7.72687236,144.69141 14.6892832,144.862335 L15.0115833,144.866287 L108.724094,144.866287 L108.655993,144.812245 C106.247587,142.858894 104.821938,139.819547 104.742438,136.537479 L104.738926,136.247276 L104.73844,119.133713 Z" fill="' + fillColor + '" fill-rule="nonzero"></path>\n            </g>\n            <g transform="translate(32.000000, 55.000000)">\n                <path d="M18.5,0 C8.2991,0 0,8.2991 0,18.5 C0,28.7009 8.2991,37 18.5,37 C28.7009,37 37,28.7009 37,18.5 C37,8.2991 28.7009,0 18.5,0" id="Fill-1" fill="#1476FF"></path>\n                <path d="M11.4542029,12.4542029 C12.1323292,11.7760767 13.324783,11.8678039 14.1159303,12.6589512 L14.1159303,12.6589512 L18.5,17.043 L22.8840697,12.6589512 C23.675217,11.8678039 24.8676708,11.7760767 25.5457971,12.4542029 C26.2239233,13.1323292 26.1321961,14.324783 25.3410488,15.1159303 L20.957,19.5 L25.3410488,23.8840697 C26.0905568,24.6335776 26.2123303,25.743261 25.6464822,26.4345838 L25.5457971,26.5457971 C24.8676708,27.2239233 23.675217,27.1321961 22.8840697,26.3410488 L22.8840697,26.3410488 L18.5,21.957 L14.1159303,26.3410488 C13.324783,27.1321961 12.1323292,27.2239233 11.4542029,26.5457971 C10.7760767,25.8676708 10.8678039,24.675217 11.6589512,23.8840697 L16.043,19.5 L11.6589512,15.1159303 C10.9094432,14.3664224 10.7876697,13.256739 11.3535178,12.5654162 Z" fill="#ffffff" fill-rule="nonzero"></path>\n            </g>\n            <g transform="translate(92.000000, 91.000000)" fill="' + fillColor + '">\n                <path d="M54.661608,58.5980308 L48.4015328,52.3382734 C47.8661557,51.8047505 47.8661557,50.9368624 48.4015328,50.4015125 C48.93691,49.8661625 49.8048421,49.8661625 50.338392,50.4015125 L56.5984672,56.6612699 C57.1338443,57.1966198 57.1338443,58.0626808 56.5984672,58.5980308 C56.3316922,58.8666193 55.9808649,59 55.6300376,59 C55.2792102,59 54.9283829,58.8666193 54.661608,58.5980308 Z"></path>\n                <path d="M64.2299385,53.5190184 C66.59153,53.5190184 68.5059782,55.4315327 68.5059782,57.7907386 L68.5059782,74.877619 C68.5059782,77.2368249 66.59153,79.1493391 64.2299385,79.1493391 C61.868347,79.1493391 59.9538988,77.2368249 59.9538988,74.877619 L59.9538988,57.7907386 C59.9538988,55.4315327 61.868347,53.5190184 64.2299385,53.5190184 Z M64.2299385,55.6548785 C63.0491428,55.6548785 62.0919187,56.6111356 62.0919187,57.7907386 L62.0919187,74.877619 C62.0919187,76.057222 63.0491428,77.0134791 64.2299385,77.0134791 C65.4107343,77.0134791 66.3679584,76.057222 66.3679584,74.877619 L66.3679584,57.7907386 C66.3679584,56.6111356 65.4107343,55.6548785 64.2299385,55.6548785 Z"  fill-rule="nonzero" transform="translate(64.229939, 66.334179) rotate(-45.000000) translate(-64.229939, -66.334179) "></path>\n                <path d="M30,0 C46.5423465,0 60,13.4576535 60,30 C60,46.5423465 46.5423465,60 30,60 C13.4576535,60 0,46.5423465 0,30 C0,13.4576535 13.4576535,0 30,0 Z M30,2.14285714 C14.6411208,2.14285714 2.14285714,14.6411208 2.14285714,30 C2.14285714,45.3588792 14.6411208,57.8571429 30,57.8571429 C45.3588792,57.8571429 57.8571429,45.3588792 57.8571429,30 C57.8571429,14.6411208 45.3588792,2.14285714 30,2.14285714 Z" fill-rule="nonzero"></path>\n            </g>\n            <g transform="translate(53.177778, 12.000000)" stroke="' + fillColor + '" stroke-width="0.76">\n                <path d="M120.505373,158 L127.662222,158 C134.378005,158 139.822222,152.555783 139.822222,145.84 L139.822222,12.16 C139.822222,5.44421744 134.378005,-3.01002608e-15 127.662222,0 L11.9822222,0 C5.26643966,1.23366924e-15 -0.177777778,5.44421744 -0.177777778,12.16 L-0.177777778,23.786605 L-0.177777778,23.786605"></path>\n            </g>\n            <ellipse fill="' + fillColor + '" cx="171.047716" cy="170.746356" rx="3.74528" ry="3.7414966"></ellipse>\n            <ellipse fill="' + fillColor + '" cx="53.3389156" cy="33.9144801" rx="3.74528" ry="3.7414966"></ellipse>\n        </g>\n    </svg>';
};
var STAGE_EMPTY_SVG = function STAGE_EMPTY_SVG2(fillColor) {
  return '<svg width="80px" height="80px" viewBox="0 0 200 200" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">\n        <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">\n            <g transform="translate(-0.340000, -0.000000)">\n                <g>\n                    <rect x="0" y="0" width="199.8" height="199.8"></rect>\n                    <path d="M33.966,63.936 L171.0288,63.936 C172.573651,63.936 173.826,65.1883491 173.826,66.7332 L173.826,167.832 C173.826,172.24586 170.24786,175.824 165.834,175.824 L41.958,175.824 C37.5441403,175.824 33.966,172.24586 33.966,167.832 L33.966,63.936 L33.966,63.936 Z"></path>\n                    <path d="M26.7732,63.936 L135.864,63.936 L135.864,63.936 L135.864,167.832 C135.864,172.24586 132.28586,175.824 127.872,175.824 L31.968,175.824 C27.5541403,175.824 23.976,172.24586 23.976,167.832 L23.976,66.7332 C23.976,65.1883491 25.2283491,63.936 26.7732,63.936 Z"></path>\n                    <path d="M1.998,63.936 L112.385858,63.936 C113.762537,63.936 115.042272,64.6446419 115.772816,65.8114973 L133.949294,94.8437487 C134.534854,95.7790313 134.251349,97.0119183 133.316066,97.597479 C132.998228,97.7964705 132.630806,97.902 132.255815,97.902 L28.3238627,97.902 C25.612893,97.902 23.0867558,96.5277135 21.614018,94.2516642 L1.998,63.936 L1.998,63.936 Z" transform="translate(68.931000, 80.919000) scale(-1, 1) translate(-68.931000, -80.919000) "></path>\n                    <path d="M135.864,63.936 L173.810021,63.936 C175.170494,63.936 176.437498,64.6281744 177.172556,65.7729789 L195.825988,94.8244894 C196.422185,95.7530279 196.152769,96.9890705 195.224231,97.5852677 C194.902159,97.7920639 194.527467,97.902 194.14472,97.902 L160.414993,97.902 C157.582914,97.902 154.962336,96.4031709 153.526415,93.9621049 L135.864,63.936 L135.864,63.936 Z"></path>\n                </g>\n                <g transform="translate(1.000000, 0.000000)">\n                    <rect x="0" y="0" width="199.8" height="199.8"></rect>\n                    <path d="M173.965,96.796875 L173.965,166.832 C173.965,171.797592 169.939592,175.823 164.974,175.823 L126.000156,175.823 L126.000156,173.825 L164.974,173.825 C168.836127,173.825 171.967,170.694127 171.967,166.832 L171.967,96.796875 L173.965,96.796875 Z" id="矩形备份" fill="' + fillColor + '" fill-rule="nonzero"></path>\n                    <path d="M135.863,63.937 L135.863,166.832 C135.863,171.797592 131.837592,175.823 126.872,175.823 L30.9680001,175.823 C26.0024079,175.823 21.977,171.797592 21.977,166.832 L21.977,96.796875 L23.975,96.796875 L23.975,166.832 C23.975,170.694127 27.1058728,173.825 30.9680001,173.825 L126.872,173.825 C130.734127,173.825 133.865,170.694127 133.865,166.832 L133.865,65.935 L25.7732,65.935 L25.7732,63.937 L135.863,63.937 Z" fill="' + fillColor + '" fill-rule="nonzero"></path>\n                    <path d="M112.995777,63.936 C114.372456,63.936 115.652192,64.6446419 116.382735,65.8114973 L134.559213,94.8437487 C135.144774,95.7790313 134.861268,97.0119183 133.925985,97.597479 C133.608148,97.7964705 133.240725,97.902 132.865734,97.902 L28.9337822,97.902 C26.2228125,97.902 23.6966752,96.5277135 22.2239375,94.2516642 L2.60791944,63.936 L112.995777,63.936 Z M112.995777,65.934 L6.27991944,65.934 L23.9013986,93.1662482 C25.0059519,94.8732851 26.9005549,95.904 28.9337822,95.904 L132.865734,95.904 L114.689256,66.8717487 C114.323984,66.2883209 113.684117,65.934 112.995777,65.934 Z" fill="' + fillColor + '" fill-rule="nonzero" transform="translate(68.735960, 80.919000) scale(-1, 1) translate(-68.735960, -80.919000) "></path>\n                    <path d="M172.810021,63.936 C174.170494,63.936 175.437498,64.6281744 176.172556,65.7729789 L194.825988,94.8244894 C195.422185,95.7530279 195.152769,96.9890705 194.224231,97.5852677 C193.902159,97.7920639 193.527467,97.902 193.14472,97.902 L159.414993,97.902 C156.582914,97.902 153.962336,96.4031709 152.526415,93.9621049 L134.864,63.936 L172.810021,63.936 Z M172.810021,65.934 L138.357,65.934 L154.248559,92.9490786 C155.3255,94.7798782 157.290933,95.904 159.414993,95.904 L193.14472,95.904 L174.491288,66.8524894 C174.123759,66.2800872 173.490257,65.934 172.810021,65.934 Z" fill="' + fillColor + '" fill-rule="nonzero"></path>\n                    <g transform="translate(61.895063, 21.978000)" fill="' + fillColor + '" fill-rule="nonzero">\n                        <path d="M39.0029373,0.999 L39.0029373,14.985 C39.0029373,15.5367325 38.5556698,15.984 38.0039373,15.984 C37.4522049,15.984 37.0049373,15.5367325 37.0049373,14.985 L37.0049373,0.999 C37.0049373,0.447267535 37.4522049,1.0135161e-16 38.0039373,0 C38.5556698,-1.0135161e-16 39.0029373,0.447267535 39.0029373,0.999 Z"></path>\n                        <path d="M72.1457153,6.84296597 L72.1457153,20.828966 C72.1457153,21.3806984 71.6984477,21.827966 71.1467153,21.827966 C70.5949828,21.827966 70.1477153,21.3806984 70.1477153,20.828966 L70.1477153,6.84296597 C70.1477153,6.2912335 70.5949828,5.84396597 71.1467153,5.84396597 C71.6984477,5.84396597 72.1457153,6.2912335 72.1457153,6.84296597 Z" transform="translate(71.146715, 13.835966) rotate(-330.000000) translate(-71.146715, -13.835966) "></path>\n                        <path d="M5.86015938,6.84296597 L5.86015938,20.828966 C5.86015938,21.3806984 5.41289184,21.827966 4.86115938,21.827966 C4.30942691,21.827966 3.86215938,21.3806984 3.86215938,20.828966 L3.86215938,6.84296597 C3.86215938,6.2912335 4.30942691,5.84396597 4.86115938,5.84396597 C5.41289184,5.84396597 5.86015938,6.2912335 5.86015938,6.84296597 Z" transform="translate(4.861159, 13.835966) rotate(-30.000000) translate(-4.861159, -13.835966) "></path>\n                    </g>\n                    <g transform="translate(36.962000, 133.866000)">\n                        <rect fill="#1476FF" x="0" y="0" width="31.968" height="9.99" rx="2"></rect>\n                        <rect fill="' + fillColor + '" x="0" y="17.982" width="23.976" height="1.998" rx="0.6993"></rect>\n                        <rect fill="' + fillColor + '" x="0" y="25.974" width="11.988" height="1.998" rx="0.6993"></rect>\n                    </g>\n                </g>\n            </g>\n        </g>\n    </svg>';
};
var LOADING_SVG = function LOADING_SVG2(fillColor) {
  return '<svg width="24px" height="24px" viewBox="0 0 24 24" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">\n    <defs>\n        <linearGradient x1="128.248383%" y1="50%" x2="26.8114638%" y2="0%" id="huichart-loading-linearGradient">\n            <stop stop-color="' + fillColor + '" stop-opacity="0" offset="0.0956075175%"></stop>\n            <stop stop-color="' + fillColor + `" offset="100%"></stop>
        </linearGradient>
    </defs>
    <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g transform="translate(-817.000000, -590.000000)">
            <g transform="translate(538.000000, 402.000000)">
                <g transform="translate(279.000000, 188.000000)">
                    <path style="transform-origin: 50% 50%;"  d="M12,0.9 C12.7455844,0.9 13.35,1.50441559 13.35,2.25 C13.35,2.99558441 12.7455844,3.6 12,3.6 C7.36058441,3.6 3.6,7.36058441 3.6,12 C3.6,16.6394156 7.36058441,20.4 12,20.4 C16.6394156,20.4 20.4,16.6394156 20.4,12 C20.4,11.2544156 21.0044156,10.65 21.75,10.65 C22.4955844,10.65 23.1,11.2544156 23.1,12 C23.1,18.1305844 18.1305844,23.1 12,23.1 C5.86941559,23.1 0.9,18.1305844 0.9,12 C0.9,5.86941559 5.86941559,0.9 12,0.9 Z" id="Stroke-2" fill="url(#huichart-loading-linearGradient)" fill-rule="nonzero">
                    <animateTransform attributeName='transform' type="rotate" from='0' to='360' dur='1' repeatCount='indefinite'/> 
                    </path>
            
                </g>
            </g>
        </g>
    </g>
</svg>`;
};
function insertStateDom(container, state, option) {
  if (option === void 0) {
    option = {
      theme: "light"
    };
  }
  var text = "";
  var image = "";
  var theme = option.theme || "light";
  var textSize = option.textSize || 14;
  var textShow = option.textShow !== false;
  var imageSize = option.imageSize || "auto";
  var imageShow = option.imageShow !== false;
  var textColor2 = option.textColor || (theme.includes("dark") ? "#FFFFFF" : "#808080");
  var imageColor = option.imageColor || (theme.includes("dark") ? "#FFFFFF" : "#191919");
  var backgroundColor = option.backgroundColor || (theme.includes("dark") ? "#191919" : "#FFFFFF");
  if (hasStateDom(container, state))
    return;
  switch (state) {
    case "error":
      image = ERROR_SVG(defendXSS$1(imageColor));
      text = "加载失败";
      break;
    case "empty":
      image = STAGE_EMPTY_SVG(defendXSS$1(imageColor));
      text = "暂无数据";
      break;
    case "loading":
      image = LOADING_SVG(defendXSS$1(imageColor));
      backgroundColor = option.backgroundColor || (theme.includes("dark") ? "rgba(0,0,0,0.8)" : "rgba(255,255,255,0.8)");
      text = "加载中...";
      break;
    case "stage_empty":
      image = STAGE_EMPTY_SVG(defendXSS$1(imageColor));
      backgroundColor = option.backgroundColor || "transparent";
      text = "没有符合所选时间内的数据";
      break;
    case "custom":
      image = '<img style="display: block;" src="' + defendXSS$1(option.image) + '" />';
      text = option.text;
      break;
  }
  image = option.image ? '<img style="display: block;width: ' + defendXSS$1(imageSize) + 'px;" src="' + defendXSS$1(option.image) + '" />' : image;
  text = option.text || text;
  var stateDom = '<div class="huicharts-state-container huicharts-' + defendXSS$1(state) + '" style="background-color: ' + defendXSS$1(backgroundColor) + ';position:absolute;top: 0;left: 0;width: 100%;height: 100%;display: flex;align-items: center;flex-direction: column;justify-content: center;z-index: 99;">\n            <div style="display: ' + (imageShow ? "flex" : "none") + ";width: " + defendXSS$1(imageSize) + "px;height: " + defendXSS$1(imageSize) + 'px;padding: 0;margin: 0;align-items: center;justify-content: center;">' + image + '</div>\n            <div style="color: ' + defendXSS$1(textColor2) + ";font-size: " + defendXSS$1(textSize) + "px;line-height: " + defendXSS$1(textSize) + "px;display: " + (textShow ? "block" : "none") + ';margin-top: 14px;letter-spacing: 0.5px;">' + text + "</div>\n        </div>";
  container.insertAdjacentHTML("beforeend", stateDom);
}
function removeStateDom(container, state) {
  var doms = container.getElementsByClassName("huicharts-" + state);
  for (var index = 0; index < doms.length; index++) {
    var item = doms[index];
    container.removeChild(item);
  }
}
function hasStateDom(container, state) {
  var doms = container.getElementsByClassName("huicharts-" + state);
  if (doms.length >= 1) {
    return true;
  } else {
    return false;
  }
}
var BaseChart = /* @__PURE__ */ function() {
  function BaseChart2() {
    if (this.init === void 0) {
      throw new Error('This chart has not overwrite "init" callback!');
    }
    if (this.setSimpleOption === void 0) {
      throw new Error('This chart has not overwrite "setSimpleOption" callback!');
    }
    if (this.render === void 0) {
      throw new Error('This chart has not overwrite "render" callback!');
    }
    if (this.onRenderReady === void 0) {
      throw new Error('This chart has not overwrite "onRenderReady" callback!');
    }
    if (this.refresh === void 0) {
      throw new Error('This chart has not overwrite "refresh" callback!');
    }
    if (this.refreshData === void 0) {
      throw new Error('This chart has not overwrite "refreshData" callback!');
    }
    if (this.setResize === void 0) {
      throw new Error('This chart has not overwrite "setResize" callback!');
    }
    if (this.uninstall === void 0) {
      throw new Error('This chart has not overwrite "uninstall" callback!');
    }
  }
  var _proto3 = BaseChart2.prototype;
  _proto3.showLoading = function showLoading(option) {
    insertStateDom(this.dom, "loading", option);
  };
  _proto3.hideLoading = function hideLoading() {
    removeStateDom(this.dom, "loading");
  };
  _proto3.closeLoading = function closeLoading() {
    removeStateDom(this.dom, "loading");
  };
  _proto3.showError = function showError(option) {
    insertStateDom(this.dom, "error", option);
  };
  _proto3.closeError = function closeError() {
    removeStateDom(this.dom, "error");
  };
  _proto3.showEmpty = function showEmpty(option) {
    insertStateDom(this.dom, "empty", option);
  };
  _proto3.closeEmpty = function closeEmpty() {
    removeStateDom(this.dom, "empty");
  };
  _proto3.showStageEmpty = function showStageEmpty(option) {
    insertStateDom(this.dom, "stage_empty", option);
  };
  _proto3.closeStageEmpty = function closeStageEmpty() {
    removeStateDom(this.dom, "stage_empty");
  };
  _proto3.showState = function showState(option) {
    insertStateDom(this.dom, "custom", option);
  };
  _proto3.closeState = function closeState() {
    removeStateDom(this.dom, "custom");
  };
  _proto3.showCustomDom = function showCustomDom(callback) {
    if (this.dom.getElementsByClassName("huicharts-custom-dom").length > 0)
      return;
    if (getComputedStyle(this.dom).position === "static") {
      this.dom.style.position = "relative";
    }
    var customContainer = document.createElement("div");
    customContainer.className = "huicharts-custom-dom";
    customContainer.setAttribute("style", "position:absolute;width:100%;height:100%;top:0px;left:0px;display:flex;justify-content:center;align-items:center");
    this.dom.appendChild(customContainer);
    callback(customContainer);
  };
  _proto3.closeCustomDom = function closeCustomDom() {
    var customContainer = this.dom.getElementsByClassName("huicharts-custom-dom");
    this.dom.removeChild(customContainer[0]);
  };
  return BaseChart2;
}();
function readScreen(dom, readScreenText) {
  if (readScreenText) {
    dom.setAttribute("tabindex", "0");
    dom.setAttribute("aria-label", readScreenText);
  }
}
var percentToDecimal$1 = function percentToDecimal$12(percent) {
  return parseFloat(percent) / 100;
};
var getItemCount = function getItemCount2(arr, item) {
  var count = 0;
  arr.forEach(function(key) {
    if (key === item) {
      count++;
    }
  });
  return count;
};
var getRandom = function getRandom2() {
  var array = new Uint32Array(1);
  var random = Math.random();
  if (self.crypto) {
    self.crypto.getRandomValues(array);
    random = parseFloat("0." + array[0].toString());
  }
  return random;
};
function isArrayEqual(arr1, arr2) {
  if (!isArray(arr1) || !isArray(arr2)) {
    return false;
  }
  if (arr1.length !== arr2.length) {
    return false;
  }
  for (var _iterator = _createForOfIteratorHelperLoose(arr1), _step; !(_step = _iterator()).done; ) {
    var key = _step.value;
    if (getItemCount(arr1, key) !== getItemCount(arr2, key)) {
      return false;
    }
  }
  return true;
}
var mediaScreen = /* @__PURE__ */ function() {
  function mediaScreen2(dom, option, callback) {
    this.dom = dom;
    this.option = option || [];
    this.callback = callback;
    this.curRange = [];
    this.initOption = {};
  }
  var _proto4 = mediaScreen2.prototype;
  _proto4.observe = function observe() {
    var _this = this;
    if (!this.dom)
      return;
    var domWidth = this.dom.getBoundingClientRect().width;
    var range = this.getRange(domWidth, this.option);
    if (!isArrayEqual(this.curRange, range)) {
      var tempOption = cloneDeep(this.initOption);
      this.curRange = range;
      this.curRange.forEach(function(rangeIndex) {
        merge(tempOption, _this.option[rangeIndex].option);
      });
      this.callback(tempOption);
    }
  };
  _proto4.refresh = function refresh() {
    this.curRange = [];
    this.observe();
  };
  _proto4.setInitOption = function setInitOption(option) {
    this.initOption = cloneDeep(option);
  };
  _proto4.getRange = function getRange(domWidth, option) {
    var range = [];
    option.forEach(function(item, index) {
      if (item.maxWidth !== void 0 && item.minWidth !== void 0) {
        if (domWidth <= item.maxWidth && domWidth >= item.minWidth) {
          range.push(index);
        }
      } else if (item.maxWidth === void 0 && item.minWidth === void 0) {
        range.push(index);
      } else if (item.maxWidth !== void 0 && item.minWidth === void 0) {
        if (domWidth <= item.maxWidth) {
          range.push(index);
        }
      } else if (item.maxWidth === void 0 && item.minWidth !== void 0) {
        if (domWidth >= item.minWidth) {
          range.push(index);
        }
      }
    });
    range = [].concat(new Set(range));
    return range;
  };
  return mediaScreen2;
}();
var mediaScreen$1 = mediaScreen;
var SELF_CHART = ["FlowChart", "WaveChart", "RiverChart", "GanttChart", "BaiduMapChart", "HoneycombChart", "OrganizationChart", "AutonaviMapChart", "SnowFlakeChart", "TimelineChart", "MilestoneChart"];
var CoreChart = /* @__PURE__ */ function(_BaseChart) {
  function CoreChart2() {
    var _this2;
    _this2 = _BaseChart.call(this) || this;
    _this2.echartsIns = null;
    _this2.ichartsIns = null;
    _this2.eChartOption = null;
    _this2.iChartOption = null;
    _this2.dom = null;
    _this2.chartClass = null;
    _this2.plugins = {};
    _this2.hasRender = false;
    _this2.renderCallBack = null;
    _this2.resizeThrottle = 0;
    _this2.resizeObserver = null;
    _this2.mediaScreenObserver = void 0;
    return _this2;
  }
  _inheritsLoose(CoreChart2, _BaseChart);
  CoreChart2.registerTheme = function registerTheme(name2, config2) {
    if (!config2) {
      tips.error("The second parameter config is required");
      return;
    }
    Theme$1.set(name2, config2);
  };
  CoreChart2.registerConfig = function registerConfig(name2, config2) {
    if (!config2) {
      tips.error("The second parameter config is required");
      return;
    }
    Theme$1.setConfig(name2, config2);
  };
  CoreChart2.theme = function theme(name2) {
    Theme$1.setDefaultTheme(name2);
  };
  CoreChart2.resetThemeCongfig = function resetThemeCongfig() {
    Theme$1.resetThemeCongfig();
  };
  var _proto5 = CoreChart2.prototype;
  _proto5.mediaScreen = function mediaScreen2(dom, screenOption) {
    var _this3 = this;
    this.mediaScreenObserver = new mediaScreen$1(dom, screenOption, function(option) {
      _this3.setSimpleOption(_this3.chartClass, option, _this3.plugins, false);
      _this3.render();
    });
  };
  _proto5.init = function init2(chartDom, theme, initOpts) {
    if (theme === void 0) {
      theme = {};
    }
    var defaultInit = {
      domResize: true,
      windowResize: true,
      resizeThrottle: this.resizeThrottle
    };
    initOpts = merge(defaultInit, initOpts);
    this.dom = chartDom;
    this.echartsIns = echarts.init(chartDom, theme, initOpts);
    this.throttleResize = initOpts.resizeThrottle === 0 ? this.setResize.bind(this) : throttle(initOpts.resizeThrottle, this.setResize.bind(this));
    initOpts.domResize && this.setResizeObserver();
    initOpts.windowResize && window.addEventListener("resize", this.throttleResize);
  };
  _proto5.setResizeObserver = function setResizeObserver() {
    var _this4 = this;
    this.resizeObserver = new ResizeObserver(function(entries) {
      window.requestAnimationFrame(function() {
        _this4.throttleResize();
      });
    });
    this.resizeObserver.observe(this.dom);
  };
  _proto5.setResize = function setResize() {
    this.mediaScreenObserver && this.mediaScreenObserver.observe();
    this.echartsIns && this.echartsIns.resize && this.echartsIns.resize({
      width: "auto"
    });
    this.ichartsIns && this.ichartsIns.resize && this.ichartsIns.resize();
  };
  _proto5.setSimpleOption = function setSimpleOption(ChartClass, iChartOption, plugins, isInit) {
    if (plugins === void 0) {
      plugins = {};
    }
    if (isInit === void 0) {
      isInit = true;
    }
    if (isInit) {
      Theme$1.setDefaultTheme(iChartOption.theme);
      this.mediaScreenObserver && this.mediaScreenObserver.setInitOption(iChartOption);
    }
    if (iChartOption.readScreen) {
      readScreen(this.dom, iChartOption.readScreen);
    }
    if (this.isSelfChart(ChartClass)) {
      this.redirectSelfChart(ChartClass, iChartOption);
      return;
    }
    this.plugins = plugins;
    this.chartClass = ChartClass;
    this.iChartOption = iChartOption;
    this.ichartsIns = new ChartClass(iChartOption, this.echartsIns, this.plugins);
    this.eChartOption = this.ichartsIns.getOption();
    this.iChartOption.axistip && axistip(this.dom, this.echartsIns, this.eChartOption);
    mergeExtend(this.iChartOption, this.eChartOption);
  };
  _proto5.redirectSelfChart = function redirectSelfChart(SelfChart, option, plugins) {
    var stateDom = this.dom.getElementsByClassName("huicharts-state-container")[0];
    this.uninstall();
    this.dom.innerHTML = "";
    var instance = new SelfChart();
    instance.init(this.dom);
    instance.setSimpleOption(SelfChart, option, plugins);
    instance.renderCallBack = this.renderCallBack;
    if (stateDom) {
      this.dom.appendChild(stateDom);
    }
    Object.setPrototypeOf(this, instance);
    for (var key in this) {
      if (Object.hasOwnProperty.call(this, key)) {
        delete this[key];
      }
    }
  };
  _proto5.isSelfChart = function isSelfChart(chartClass) {
    return SELF_CHART.includes(chartClass.name);
  };
  _proto5.render = function render(option) {
    this.hasRender = true;
    this.setOption(this.eChartOption, option);
    this.setOptionAgain(this.eChartOption);
    this.renderCallBack && this.renderCallBack(this.echartsIns);
  };
  _proto5.setOption = function setOption2(eChartOption, option) {
    option = merge({
      notMerge: true
    }, option);
    eChartOption && this.echartsIns.setOption(eChartOption, option);
  };
  _proto5.setOptionAgain = function setOptionAgain() {
    if (this.ichartsIns && this.ichartsIns.updateOptionAgain) {
      var YAxiMax = this.getYAxisMaxValue(0);
      var YAxiMin = this.getYAxisMinValue(0);
      this.ichartsIns.updateOptionAgain(YAxiMax, YAxiMin);
      this.setOption(this.eChartOption);
    }
  };
  _proto5.refresh = function refresh(iChartOption) {
    this.iChartOption = iChartOption;
    this.setSimpleOption(this.chartClass, iChartOption, this.plugins);
    this.render();
  };
  _proto5.refreshData = function refreshData(data3) {
    this.iChartOption.data = data3;
    this.refresh(this.iChartOption);
  };
  _proto5.onRenderReady = function onRenderReady(callback) {
    this.renderCallBack = callback;
  };
  _proto5.on = function on() {
    var _this$echartsIns;
    this.echartsIns && (_this$echartsIns = this.echartsIns).on.apply(_this$echartsIns, arguments);
  };
  _proto5.off = function off() {
    var _this$echartsIns2;
    this.echartsIns && (_this$echartsIns2 = this.echartsIns).off.apply(_this$echartsIns2, arguments);
  };
  _proto5.bindEvents = function bindEvents(events) {
    var _this5 = this;
    if (events && events.length !== 0) {
      events.forEach(function(item) {
        if (item.query) {
          _this5.off(item.eventName, item.handler);
          _this5.on(item.eventName, item.query, item.handler);
        } else {
          _this5.off(item.eventName, item.handler);
          _this5.on(item.eventName, item.handler);
        }
      });
    }
  };
  _proto5.unbindEvents = function unbindEvents(events) {
    var _this6 = this;
    if (events && events.length !== 0) {
      events.forEach(function(item) {
        if (item.handler) {
          _this6.off(item.eventName, item.handler);
        } else {
          _this6.off(item.eventName);
        }
      });
    }
  };
  _proto5.uninstall = function uninstall() {
    window.removeEventListener("resize", this.throttleResize);
    if (this.resizeObserver) {
      this.resizeObserver.unobserve(this.dom);
      this.resizeObserver.disconnect();
      this.resizeObserver = null;
    }
    if (this.echartsIns && !this.echartsIns.isDisposed()) {
      this.echartsIns.dispose();
    }
    this.echartsIns = null;
  };
  _proto5.getEchartsInstance = function getEchartsInstance() {
    return this.echartsIns;
  };
  _proto5.setEchartsOption = function setEchartsOption(option) {
    option && (this.eChartOption = option);
  };
  _proto5.getEchartsOption = function getEchartsOption() {
    return this.eChartOption;
  };
  _proto5.getYAxisMaxValue = function getYAxisMaxValue(index) {
    var _this$echartsIns$getM;
    return (_this$echartsIns$getM = this.echartsIns.getModel().getComponent("yAxis", index)) == null ? void 0 : _this$echartsIns$getM.axis.scale._extent[1];
  };
  _proto5.getYAxisMinValue = function getYAxisMinValue(index) {
    var _this$echartsIns$getM2;
    return (_this$echartsIns$getM2 = this.echartsIns.getModel().getComponent("yAxis", index)) == null ? void 0 : _this$echartsIns$getM2.axis.scale._extent[0];
  };
  return CoreChart2;
}(BaseChart);
function setDefaultTheme(iChartOption) {
  iChartOption.theme = iChartOption.theme || Theme$1.themeName || THEMES.LIGHT;
}
function setDefaultColor(iChartOption) {
  if (!iChartOption.color) {
    iChartOption.color = Theme$1.config.colorGroup;
  }
}
function setDefaultXAxis(iChartOption) {
  var data3 = iChartOption.data;
  var keyName;
  if (data3 && data3.length > 0) {
    var keys = Object.keys(data3[0]);
    if (keys.length > 0) {
      keyName = keys[0];
    }
  }
  if (isArray(iChartOption.xAxis)) {
    iChartOption.xAxis.forEach(function(xAxisItem) {
      setXAxisKeyName(xAxisItem, keyName);
    });
  } else if (typeof iChartOption.xAxis == "object") {
    setXAxisKeyName(iChartOption.xAxis, keyName);
    iChartOption.xAxis = [iChartOption.xAxis];
  } else {
    iChartOption.xAxis = [{
      keyName
    }];
  }
}
function setXAxisKeyName(xAxisItem, defaultKey) {
  var keyName = defaultKey;
  if (isString(xAxisItem.data)) {
    keyName = xAxisItem.data;
    delete xAxisItem.data;
  }
  if (xAxisItem.keyName) {
    keyName = xAxisItem.keyName;
  }
  xAxisItem.keyName = keyName;
}
function setChartPadding$1(iChartOption) {
  var defaultPadding = [50, 20, 50, 20];
  var padding = iChartOption.padding || iChartOption.chartPadding;
  if (!padding) {
    iChartOption.padding = defaultPadding;
  } else if (padding.length === 1) {
    iChartOption.padding = [padding[0], 20, padding[0], 20];
  } else if (padding.length === 2) {
    iChartOption.padding = [padding[0], padding[1], padding[0], padding[1]];
  } else if (padding.length === 3) {
    iChartOption.padding = [padding[0], padding[1], padding[2], padding[1]];
  } else {
    iChartOption.padding = padding;
  }
  delete iChartOption.chartPadding;
}
function setDefaultLegend(iChartOption) {
  if (!iChartOption.legend) {
    iChartOption.legend = {
      show: true,
      position: {
        left: "center",
        bottom: 14
      },
      orient: "horizontal"
    };
  }
  if (iChartOption.legend.show === void 0) {
    iChartOption.legend.show = false;
  }
  if (!iChartOption.legend.orient) {
    iChartOption.legend.orient = "horizontal";
  }
  if (!iChartOption.legend.position) {
    iChartOption.legend.position = {
      left: "center",
      bottom: 15
    };
  }
}
function setDefaultDataZoom(iChartOption) {
  if (!iChartOption.dataZoom) {
    iChartOption.dataZoom = {
      show: false,
      position: {
        left: 40,
        bottom: 18
      }
    };
  }
  if (iChartOption.dataZoom.show === void 0) {
    iChartOption.dataZoom.show = false;
  }
  if (!iChartOption.dataZoom.position) {
    iChartOption.dataZoom.position = {
      left: "center",
      bottom: 20
    };
  }
}
function init(iChartOption) {
  setDefaultTheme(iChartOption);
  setDefaultColor(iChartOption);
  setDefaultXAxis(iChartOption);
  setChartPadding$1(iChartOption);
  setDefaultLegend(iChartOption);
  setDefaultDataZoom(iChartOption);
  return iChartOption;
}
function mini(iChartOption, baseOption2) {
  if (iChartOption.mini) {
    baseOption2.grid.forEach(function(item) {
      Object.assign(item, {
        top: 2,
        left: 0,
        right: 0,
        bottom: 1,
        containLabel: false
      });
    });
    baseOption2.legend = Object.assign(baseOption2.legend, {
      show: false
    });
    baseOption2.title = Object.assign(baseOption2.title, {
      show: false
    });
    baseOption2.tooltip = Object.assign(baseOption2.tooltip, {
      show: false
    });
    if (!isArray(baseOption2.xAxis)) {
      baseOption2.xAxis = [baseOption2.xAxis];
    }
    if (!isArray(baseOption2.yAxis)) {
      baseOption2.yAxis = [baseOption2.yAxis];
    }
    baseOption2.xAxis.forEach(function(item) {
      Object.assign(item, {
        show: false,
        boundaryGap: false
      });
    });
    baseOption2.yAxis.forEach(function(item) {
      Object.assign(item, {
        show: false,
        max: "dataMax",
        min: "dataMin"
      });
    });
  }
}
function event(chartInstance, event2) {
  if (!event2)
    return;
  var queryKeys = Object.keys(event2);
  queryKeys.forEach(function(qrKey) {
    var eKeys = Object.keys(event2[qrKey]);
    eKeys.forEach(function(key) {
      chartInstance.off(key);
      chartInstance.on(key, qrKey, function(params) {
        event2[qrKey][key](params);
      });
    });
  });
}
function getMarkLineDefault() {
  return {
    symbol: "none",
    silent: true,
    label: {
      show: false
    },
    lineStyle: {
      width: Theme$1.config.markLineWidth
    },
    emphasis: {
      label: {
        show: false
      },
      lineStyle: {
        width: Theme$1.config.markLineEmphasisWidth
      }
    },
    data: []
  };
}
function getMarkPointDefault() {
  return {
    symbol: "path://M50 0 L0 50 L100 50 Z",
    symbolSize: [10, 6],
    label: {
      color: Theme$1.config.markPointLabelColor
    },
    data: []
  };
}
function proxy(callBack) {
  return new Proxy({}, {
    get: function get(_, prop) {
      return callBack()[prop];
    }
  });
}
var getChartToken$f = function getChartToken$f2() {
  var _Theme$1$config$LineC = Theme$1.config.LineChart, _Theme$1$config$LineC2 = _Theme$1$config$LineC.symbolSize, symbolSizeSM = _Theme$1$config$LineC2.symbolSizeSM, symbolSizeLG = _Theme$1$config$LineC2.symbolSizeLG, _Theme$1$config$LineC3 = _Theme$1$config$LineC.itemStyle, borderZero = _Theme$1$config$LineC3.borderZero, border2 = _Theme$1$config$LineC3.border, borderColor = _Theme$1$config$LineC3.borderColor, lineWidth = _Theme$1$config$LineC.lineStyle.lineWidth, color3 = _Theme$1$config$LineC.markLine.lineStyle.color;
  var colorError = Theme$1.config.colorState.colorError;
  var _Theme$1$config = Theme$1.config, tooltipTextColor = _Theme$1$config.tooltipTextColor, visualMapPiecesColor = _Theme$1$config.visualMapPiecesColor, visualMapDashColor = _Theme$1$config.visualMapDashColor;
  return {
    symbolSizeSM,
    borderZero,
    symbolSizeLG,
    lineWidth,
    color: color3,
    border: border2,
    borderColor,
    colorError,
    tooltipTextColor,
    visualMapPiecesColor,
    visualMapDashColor
  };
};
var chartToken$y = proxy(getChartToken$f);
var chartToken$z = chartToken$y;
var seriesInit$9 = function seriesInit$92() {
  return {
    label: {
      show: false
    },
    // 连线上的小圆点样式
    symbol: "emptyCircle",
    symbolSize: chartToken$z.symbolSizeLG,
    showSymbol: false,
    // 数据
    data: [],
    // 线形
    type: "line",
    // 线条样式
    lineStyle: {
      width: chartToken$z.lineWidth
    },
    // 折线阶梯
    step: false,
    // 折线平滑
    smooth: false,
    // 阈值线
    markLine: null,
    // 峰值标志
    markPoint: null,
    // 折线点的每个样式配置项
    itemStyle: {}
  };
};
function setSeries$8(params) {
  var yAxis2 = params.yAxis, theme = params.theme, itemStyle2 = params.itemStyle;
  var localSeriesUnit = cloneDeep(seriesInit$9());
  handleItemStyleWithTheme(localSeriesUnit, theme);
  handleItemStyle$2(localSeriesUnit, itemStyle2);
  var series = [];
  handleSeries$7(_extends({}, params, {
    series,
    localSeriesUnit
  }));
  handleYaxis$3(series, yAxis2);
  return series;
}
function handleItemStyleWithTheme(seriesUnit, theme) {
  if (theme.toLowerCase().includes("cloud-light")) {
    seriesUnit.symbol = "emptyCircle";
    seriesUnit.itemStyle = {};
  } else {
    seriesUnit.symbol = "circle";
    seriesUnit.itemStyle = {
      shadowBlur: 2,
      borderWidth: chartToken$z.border,
      borderColor: chartToken$z.borderColor,
      shadowColor: "rgba(0, 0, 0, .2)"
    };
  }
}
function handleItemStyle$2(seriesUnit, itemStyle2) {
  if (!itemStyle2)
    return;
  if (itemStyle2.symbolSize) {
    seriesUnit.symbolSize = itemStyle2.symbolSize;
  }
  for (var key in itemStyle2) {
    seriesUnit.itemStyle[key] = itemStyle2[key];
  }
}
function handleSeries$7(params) {
  var theme = params.theme, stack = params.stack, focus = params.focus, colors = params.colors, isStep = params.isStep, isArea = params.isArea, series = params.series, isSmooth = params.isSmooth, markLine = params.markLine, markPoint = params.markPoint, splitLine = params.splitLine, legendData = params.legendData, seriesData = params.seriesData, localSeriesUnit = params.localSeriesUnit;
  legendData.forEach(function(legend2, index) {
    var seriesUnit = cloneDeep(localSeriesUnit);
    seriesUnit.smooth = isSmooth || false;
    seriesUnit.step = isStep && "end" || false;
    markLine && handleMarkLine$1(markLine, seriesUnit, theme, legend2);
    markPoint && handleMarkPoint(markPoint, seriesUnit, theme, legend2);
    focus && handleFocus$1(focus, seriesUnit);
    seriesUnit.name = legend2;
    seriesUnit.data = seriesData[legend2];
    stack && handleStack$1(stack, seriesUnit);
    series.push(seriesUnit);
  });
}
function handleYaxis$3(series, yAxis2) {
  if (Array.isArray(yAxis2)) {
    yAxis2.forEach(function(y, index) {
      series.forEach(function(s, indexs) {
        if (y.dataName && y.dataName.includes(s.name)) {
          series[indexs].yAxisIndex = index;
        }
      });
    });
  }
}
function handleMarkLine$1(markLine, seriesUnit, theme, seriesName) {
  seriesUnit.markLine = cloneDeep(getMarkLineDefault());
  if (markLine.top && !(markLine.topUse && !markLine.topUse.includes(seriesName))) {
    var markLineData = {};
    if (isString(markLine.top)) {
      markLineData = {
        type: markLine.top
      };
    } else {
      markLineData = {
        yAxis: markLine.top
      };
    }
    markLineData.label = {
      show: false,
      position: "insideEndTop"
    };
    markLineData.lineStyle = {};
    markLine.topPosition && (markLineData.label.position = markLine.topPosition || "insideStartTop");
    markLine.topLabel && (markLineData.label.show = true);
    markLine.topLabel && (markLineData.label.formatter = markLine.topLabel);
    if (!markLine.topColor) {
      markLine.topColor = chartToken$z.colorError;
    }
    if (markLine.topColor === "auto") {
      markLine.topColor = void 0;
    }
    markLine.topColor && (markLineData.label.color = markLine.topColor);
    markLine.topColor && (markLineData.lineStyle.color = markLine.topColor);
    if (markLine.topLine === false) {
      markLineData.lineStyle.color = chartToken$z.color;
    }
    seriesUnit.markLine.data.push(markLineData);
  }
  if (markLine.bottom && !(markLine.bottomUse && !markLine.bottomUse.includes(seriesName))) {
    var _markLineData = {};
    if (isString(markLine.bottom)) {
      _markLineData = {
        type: markLine.bottom
      };
    } else {
      _markLineData = {
        yAxis: markLine.bottom
      };
    }
    _markLineData.label = {
      show: false,
      position: "insideEndTop"
    };
    _markLineData.lineStyle = {};
    markLine.bottomPosition && (_markLineData.label.position = markLine.bottomPosition || "insideStartTop");
    markLine.bottomLabel && (_markLineData.label.show = true);
    markLine.bottomLabel && (_markLineData.label.formatter = markLine.bottomLabel);
    if (!markLine.bottomColor) {
      markLine.bottomColor = chartToken$z.colorError;
    }
    if (markLine.bottomColor === "auto") {
      markLine.bottomColor = void 0;
    }
    markLine.bottomColor && (_markLineData.label.color = markLine.bottomColor);
    markLine.bottomColor && (_markLineData.lineStyle.color = markLine.bottomColor);
    if (markLine.bottomLine === false) {
      _markLineData.lineStyle.color = chartToken$z.color;
    }
    seriesUnit.markLine.data.push(_markLineData);
  }
}
function handleMarkPoint(markPoint, seriesUnit, theme, seriesName) {
  seriesUnit.markPoint = cloneDeep(getMarkPointDefault());
  if (markPoint.max && !(markPoint.maxUse && !markPoint.maxUse.includes(seriesName))) {
    var _max = {
      type: "max",
      symbolOffset: [0, -11],
      itemStyle: {
        color: markPoint.maxColor || chartToken$z.colorError
      }
    };
    if (markPoint.maxColor === "auto")
      delete _max.itemStyle;
    seriesUnit.markPoint.data.push(_max);
  }
  if (markPoint.min && !(markPoint.minUse && !markPoint.minUse.includes(seriesName))) {
    var _min = {
      type: "min",
      symbolOffset: [0, 11],
      symbolRotate: 180,
      itemStyle: {
        color: markPoint.minColor || chartToken$z.colorError
      }
    };
    if (markPoint.minColor === "auto")
      delete _min.itemStyle;
    seriesUnit.markPoint.data.push(_min);
  }
}
function handleStack$1(stack, seriesUnit) {
  if (stack === true) {
    seriesUnit.stack = "Total";
    return;
  }
  if (isObject(stack)) {
    for (var _name4 in stack) {
      if (Object.hasOwnProperty.call(stack, _name4)) {
        var stackArray = stack[_name4];
        var seriesName = seriesUnit.name;
        if (stackArray.includes(seriesName)) {
          seriesUnit.stack = _name4;
        }
        break;
      }
    }
  }
}
function handleFocus$1(focus, seriesUnit) {
  if (focus) {
    seriesUnit.emphasis = {
      focus: "series",
      blurScope: "global"
    };
  }
}
var base$b = {
  grid: {
    top: "0",
    left: "0",
    right: "0",
    bottom: "0",
    containLabel: true
  },
  legend: {},
  tooltip: {}
};
var BaseOption$6 = base$b;
function min(arrMin) {
  function handleMin(arrMin2) {
    return arrMin2.filter(function(item) {
      return Object.prototype.toString.call(item) === "[object Number]";
    });
  }
  function heapJustMin(dataMin, iMin, length) {
    var childMin = 2 * iMin + 1;
    while (childMin <= length) {
      var temp = dataMin[iMin];
      if (childMin + 1 <= length && dataMin[childMin] < dataMin[childMin + 1]) {
        childMin = childMin + 1;
      }
      if (dataMin[iMin] < dataMin[childMin]) {
        dataMin[iMin] = dataMin[childMin];
        dataMin[childMin] = temp;
        iMin = childMin;
        childMin = 2 * iMin + 1;
      } else {
        break;
      }
    }
  }
  function buildHeapMin(dataMin) {
    for (var iMin = Math.floor(dataMin.length / 2); iMin >= 0; iMin--) {
      heapJustMin(dataMin, iMin, dataMin.length);
    }
  }
  function swap(arrMin2, iMin, jMin) {
    var temp = arrMin2[iMin];
    arrMin2[iMin] = arrMin2[jMin];
    arrMin2[jMin] = temp;
  }
  function heapSort(arrMin2) {
    var dataMin = handleMin(arrMin2).slice(0);
    if (!Array.isArray(dataMin))
      return;
    if (Array.isArray(dataMin) && dataMin.length === 1) {
      return dataMin;
    }
    buildHeapMin(dataMin);
    for (var iMin = dataMin.length - 1; iMin >= 0; iMin--) {
      swap(dataMin, iMin, 0);
      heapJustMin(dataMin, 0, iMin - 1);
    }
    return dataMin[0];
  }
  return heapSort(arrMin);
}
function max(arr) {
  function handle(arr2) {
    return arr2.filter(function(item) {
      return Object.prototype.toString.call(item) === "[object Number]";
    });
  }
  function heapAjust(data3, i, length) {
    var child = 2 * i + 1;
    while (child <= length) {
      var temp = data3[i];
      if (child + 1 <= length && data3[child] < data3[child + 1]) {
        child = child + 1;
      }
      if (data3[i] < data3[child]) {
        data3[i] = data3[child];
        data3[child] = temp;
        i = child;
        child = 2 * i + 1;
      } else {
        break;
      }
    }
  }
  function buildHeap(data3) {
    for (var i = Math.floor(data3.length / 2); i >= 0; i--) {
      heapAjust(data3, i, data3.length);
    }
  }
  function swap(arr2, i, j) {
    var temp = arr2[i];
    arr2[i] = arr2[j];
    arr2[j] = temp;
  }
  function heapSort(arr2) {
    var data3 = handle(arr2).slice(0);
    if (!Array.isArray(data3))
      return;
    if (Array.isArray(data3) && data3.length === 1) {
      return data3;
    }
    buildHeap(data3);
    for (var i = data3.length - 1; i >= 0; i--) {
      swap(data3, i, 0);
      heapAjust(data3, 0, i - 1);
    }
    return data3[data3.length - 1];
  }
  return heapSort(arr);
}
function setVisualMap$2(legendData, seriesData, markLine, colors, theme) {
  var visualMap = [];
  if (markLine) {
    var topValue = markLine.top;
    var bottomValue = markLine.bottom;
    var vmColor = chartToken$z.colorError;
    var topColor = markLine.topColor || vmColor;
    var bottomColor = markLine.bottomColor || vmColor;
    if (!isNumber(topValue)) {
      topValue = void 0;
    }
    if (!isNumber(bottomValue)) {
      bottomValue = void 0;
    }
    if (topValue === void 0 && bottomValue === void 0) {
      return visualMap;
    }
    if (topValue !== void 0 && bottomValue !== void 0 && bottomValue >= topValue) {
      throw new Error("阈值线bottom的值必须小于阈值线top的值");
    }
    legendData.forEach(function(legendName, index) {
      var data3 = seriesData[legendName];
      var minData = min(data3);
      var maxData = max(data3);
      var bottom2 = bottomValue;
      var top2 = topValue;
      if (markLine.topUse && !markLine.topUse.includes(legendName)) {
        top2 = void 0;
      }
      if (markLine.bottomUse && !markLine.bottomUse.includes(legendName)) {
        bottom2 = void 0;
      }
      if (top2 === void 0 && bottom2 === void 0) {
        return;
      }
      if (bottom2 === void 0) {
        bottom2 = Math.min(top2 - 0.01, minData - 0.01);
      }
      if (top2 === void 0) {
        top2 = Math.max(bottom2 + 0.01, maxData + 0.01);
      }
      var visualMapItem = handleVisualMapItem({
        index,
        topColor,
        top: top2,
        bottom: bottom2,
        colors,
        bottomColor,
        vmColor
      });
      visualMap.push(visualMapItem);
    });
  }
  return visualMap;
}
function handleVisualMapItem(_ref8) {
  var index = _ref8.index, topColor = _ref8.topColor, top2 = _ref8.top, bottom2 = _ref8.bottom, colors = _ref8.colors, bottomColor = _ref8.bottomColor, vmColor = _ref8.vmColor;
  var visualMapItem = {
    show: false,
    type: "piecewise",
    dimension: 1,
    seriesIndex: index,
    pieces: [{
      gte: top2,
      // 大于 top 的
      color: topColor
    }, {
      gt: bottom2,
      lt: top2,
      // 小于 top, 大于 bottom 的，为正常颜色
      color: getColor(colors, index)
    }, {
      lte: bottom2,
      // 小于 bottom
      color: bottomColor
    }],
    outOfRange: {
      color: vmColor
    }
  };
  return visualMapItem;
}
function setDashedLineVisualMap(seriesIndex, lineColor, predictIndex) {
  var vm = {
    type: "piecewise",
    seriesIndex,
    dimension: 0,
    show: false,
    pieces: [{
      gte: 0,
      lte: predictIndex,
      color: chartToken$z.visualMapPiecesColor
    }, {
      gt: predictIndex,
      color: lineColor
    }]
  };
  return vm;
}
function setToolTip(dataLength, fontColor, selfFormatter) {
  if (selfFormatter) {
    return selfFormatter;
  }
  var tipHtml = function tipHtml2(params) {
    var htmlString = "";
    params.forEach(function(item, index) {
      if (index < dataLength) {
        if (index === 0) {
          htmlString += defendXSS$1(item.name) + "<br/>";
        }
        var color_ = item.color.colorStops;
        htmlString += '\n                    <div>\n                        <span style="display:inline-block;width:10px;\n                        height:10px;border-radius:5px;background-color:' + defendXSS$1(color_ ? color_[0].color : item.color) + ';">\n                        </span>\n                        <span style="margin-left:5px;color:' + defendXSS$1(fontColor) + '">\n                            <span style="display:inline-block;width:80px;">' + defendXSS$1(item.seriesName) + '</span> \n                            <span style="font-weight:bold">' + defendXSS$1(item.value) + "</span>\n                        </span>\n                    </div>\n                ";
      }
    });
    return htmlString;
  };
  return tipHtml;
}
function handlePredict(option, predict, tipHtml, lineStyle2) {
  if (predict) {
    var _data = option.series;
    var dataLength = _data.length;
    option.xAxis[0].data.length;
    var predictIndex = option.xAxis[0].data.indexOf(predict);
    if (predictIndex > -1) {
      for (var index = 0; index < dataLength; index++) {
        var temp = cloneDeep(_data[index]);
        temp.lineStyle = {
          // 为了视觉上看不见盖住粗细+1
          width: chartToken$z.lineWidth + 1,
          type: [5, 8]
        };
        temp.itemStyle = {
          opacity: 0
        };
        temp.silent = true;
        temp.showSymbol = false;
        temp.showAllSymbol = false;
        option.series.push(temp);
        var dashColor = chartToken$z.visualMapDashColor;
        if (lineStyle2 && lineStyle2.dashColor) {
          dashColor = lineStyle2.dashColor;
        }
        option.visualMap.push(setDashedLineVisualMap(dataLength + index, dashColor, predictIndex));
      }
    }
    option.tooltip.formatter = setToolTip(dataLength, chartToken$z.tooltipTextColor, tipHtml);
  }
}
function getChartToken$e() {
  var colorBgTransparent = Theme$1.config.AreaChart.areaStyle.color;
  var colorError = Theme$1.config.colorState.colorError;
  return {
    colorAreaTP: colorBgTransparent,
    colorError
  };
}
var chartToken$w = proxy(getChartToken$e);
var chartToken$x = chartToken$w;
function topArea(baseOption2, iChartOption, YAxiMin) {
  defaultArea(baseOption2, iChartOption);
  markLineArea$1(baseOption2, iChartOption, YAxiMin);
  splitArea$1(baseOption2, iChartOption, YAxiMin);
}
function splitArea$1(baseOption2, iChartOption, YAxiMin) {
  if (iChartOption.area && iChartOption.splitLine) {
    var colors = baseOption2.color;
    var splitLine = iChartOption.splitLine;
    baseOption2.series.forEach(function(item, index) {
      var maxValue = max(item.data);
      var color3 = getColor(colors, index);
      var colorTo = codeToRGB(color3, 0.15);
      var colorFrom = codeToRGB(color3, 0.15);
      var percent = (maxValue - splitLine) / (maxValue - YAxiMin);
      item.areaStyle = {
        color: {
          type: "linear",
          x: 0,
          y: 0,
          x2: 0,
          y2: 1,
          colorStops: [{
            offset: 0,
            color: colorFrom
          }, {
            offset: percent,
            color: colorTo
          }, {
            offset: percent + 1e-5,
            color: chartToken$x.colorAreaTP
          }, {
            offset: 1,
            color: chartToken$x.colorAreaTP
          }]
        }
      };
    });
  }
}
function markLineArea$1(baseOption2, iChartOption, YAxiMin) {
  if (iChartOption.area && iChartOption.markLine && iChartOption.markLine.top && isNumber(iChartOption.markLine.top) && iChartOption.markLine.topChangeColor !== false) {
    var colors = baseOption2.color;
    var markLine = iChartOption.markLine;
    var topColor = codeToRGB(markLine.topColor, 0.15) || chartToken$x.colorError;
    baseOption2.series.forEach(function(item, index) {
      var maxValue = max(item.data);
      var color3 = getColor(colors, index);
      var colorTo = codeToRGB(color3, 0);
      var colorFrom = codeToRGB(color3, 0.15);
      var percent = (maxValue - markLine.top) / (maxValue - YAxiMin);
      if (maxValue > markLine.top) {
        item.areaStyle = {
          color: {
            type: "linear",
            x: 0,
            y: 0,
            x2: 0,
            y2: 1,
            colorStops: [{
              offset: 0,
              color: topColor
            }, {
              offset: percent,
              color: topColor
            }, {
              offset: percent + 1e-5,
              color: colorFrom
            }, {
              offset: 1,
              color: colorTo
            }]
          }
        };
      }
    });
  }
}
function defaultArea(baseOption2, iChartOption, YAxiMin) {
  if (iChartOption.area) {
    var colors = baseOption2.color;
    baseOption2.series.forEach(function(item, index) {
      var color3 = getColor(colors, index);
      var colorTo = codeToRGB(color3, 0);
      var colorFrom = codeToRGB(color3, 0.15);
      item.areaStyle = {
        opacity: 1,
        color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [{
          offset: 0,
          color: colorFrom
        }, {
          offset: 1,
          color: colorTo
        }])
      };
    });
  }
}
function handleData$2(baseOpt, legendData, xAxisData) {
  if (!baseOpt.legend.data) {
    baseOpt.legend.data = legendData;
  }
  baseOpt.xAxis.forEach(function(item) {
    item.data = xAxisData;
  });
}
function onlyOnePoint(baseOption2) {
  baseOption2.series.forEach(function(item) {
    if (item.data.length === 1) {
      item.showSymbol = true;
    }
  });
}
function discrete(iChartOption, baseOption2) {
  if (iChartOption.discrete) {
    baseOption2.series.forEach(function(series) {
      var newSeries = cloneDeep(series);
      newSeries.symbol = "circle";
      newSeries.symbolSize = chartToken$z.symbolSizeSM;
      newSeries.itemStyle.borderWidth = chartToken$z.borderZero;
      newSeries.showSymbol = true;
      newSeries.showAllSymbol = true;
      newSeries.emphasis = {
        itemStyle: {
          opacity: 0
        }
      };
      var discreteData = [];
      for (var index = 0; index < newSeries.data.length; index++) {
        var pre = newSeries.data[index - 1];
        var next = newSeries.data[index];
        var cur = newSeries.data[index + 1];
        if (!isNullValue(pre) || !isNullValue(cur)) {
          discreteData.push(null);
        } else {
          discreteData.push(next);
        }
      }
      newSeries.data = discreteData;
      baseOption2.series.push(newSeries);
    });
    var dataLength = baseOption2.legend.data.length;
    var tipFormatter = baseOption2.tooltip.formatter;
    baseOption2.tooltip.formatter = function(params, ticket, callback) {
      if (tipFormatter) {
        return tipFormatter(params.slice(0, dataLength), ticket, callback);
      } else {
        return defaultFormatter(params, dataLength);
      }
    };
  }
}
function isNullValue(value) {
  return value === "" || value === void 0 || value === null;
}
function defaultFormatter(params, dataLength) {
  var htmlString = "";
  params.forEach(function(item, index) {
    if (index < dataLength) {
      if (index === 0) {
        htmlString += '<div style="margin-bottom:4px;">' + defendXSS$1(item.name) + "</div>";
      }
      htmlString += '<div>\n                              <span style="display:inline-block;width:10px;height:10px;border-radius:5px;background-color:' + defendXSS$1(item.color) + ';"></span>\n                              <span style="margin-left:5px;>\n                                  <span style="display:inline-block; margin-right:8px;min-width:60px;">' + defendXSS$1(item.seriesName) + '</span> \n                                  <span style="font-weight:bold">' + defendXSS$1(item.value) + "</span>\n                              </span>\n                          </div>";
    }
  });
  return htmlString;
}
function bottomArea(baseOption2, iChartOption, YAxiMax) {
  markLineArea(baseOption2, iChartOption, YAxiMax);
  splitArea(baseOption2, iChartOption, YAxiMax);
  formatter(baseOption2, iChartOption);
}
function markLineArea(baseOption2, iChartOption, YAxiMax) {
  if (iChartOption.area && iChartOption.markLine && iChartOption.markLine.bottom && isNumber(iChartOption.markLine.bottom)) {
    var temp = [];
    baseOption2.series.forEach(function(item) {
      var bottomColor = codeToRGB(iChartOption.markLine.bottomColor, 0.15) || chartToken$x.colorError;
      var minValue = min(item.data);
      var percent = (iChartOption.markLine.bottom - minValue) / (YAxiMax - minValue);
      if (iChartOption.markLine.bottom >= minValue) {
        var newSeries = pureBottomArea(item, percent, bottomColor);
        temp.push(newSeries);
      }
    });
    baseOption2.series = baseOption2.series.concat(temp);
  }
}
function splitArea(baseOption2, iChartOption, YAxiMax) {
  if (iChartOption.area && iChartOption.splitLine) {
    var temp = [];
    var colors = baseOption2.color;
    baseOption2.series.forEach(function(item, index) {
      var minValue = min(item.data);
      var percent = (iChartOption.splitLine - minValue) / (YAxiMax - minValue);
      var color3 = getColor(colors, index);
      var colorTo = codeToRGB(color3, 0.15);
      var colorFrom = codeToRGB(color3, 0.15);
      var newSeries = gradientBottomArea(item, percent, colorTo, colorFrom);
      temp.push(newSeries);
    });
    baseOption2.series = baseOption2.series.concat(temp);
  }
}
function gradientBottomArea(item, percent, colorTo, colorFrom) {
  var newSeries = {
    type: item.type,
    name: item.name,
    data: item.data,
    smooth: item.smooth,
    step: item.step,
    lineStyle: {
      width: 0
    },
    symbol: "none",
    areaStyle: {
      origin: "end",
      color: {
        type: "linear",
        x: 0,
        y: 0,
        x2: 0,
        y2: 1,
        colorStops: [{
          offset: 0,
          color: chartToken$x.colorAreaTP
        }, {
          offset: 1 - percent - 1e-5,
          color: chartToken$x.colorAreaTP
        }, {
          offset: 1 - percent,
          color: colorTo
        }, {
          offset: 1,
          color: colorFrom
        }]
      }
    }
  };
  return newSeries;
}
function pureBottomArea(itemx, percentx, bottomColorx) {
  var seriesObj = {
    type: itemx.type,
    name: itemx.name,
    data: itemx.data,
    smooth: itemx.smooth,
    step: itemx.step,
    symbol: "none",
    areaStyle: {
      color: {
        x: 0,
        y: 0,
        x2: 0,
        y2: 1,
        colorStops: [{
          offset: 0,
          color: chartToken$x.colorAreaTP
        }, {
          offset: 1 - percentx - 1e-5,
          color: chartToken$x.colorAreaTP
        }, {
          offset: 1 - percentx,
          color: bottomColorx
        }, {
          offset: 1,
          color: bottomColorx
        }],
        type: "linear"
      },
      origin: "end"
    },
    lineStyle: {
      width: 0
    }
  };
  return seriesObj;
}
function formatter(baseOption2, iChartOption) {
  if (iChartOption.area) {
    if (iChartOption.splitLine || iChartOption.markLine && iChartOption.markLine.bottom && isNumber(iChartOption.markLine.bottom)) {
      var dataLength = baseOption2.legend.data.length;
      var tipFormatter = baseOption2.tooltip.formatter;
      baseOption2.tooltip.formatter = function(params, ticket, callback) {
        if (tipFormatter) {
          return tipFormatter(params.slice(0, dataLength), ticket, callback);
        } else {
          return defaultFormatter(params, dataLength);
        }
      };
    }
  }
}
var baseGridOption = {
  top: 0,
  left: 0,
  right: 0,
  bottom: 0,
  containLabel: true
};
function base$a() {
  var option = cloneDeep(baseGridOption);
  return option;
}
function grid(iChartOpt) {
  var gridUnit = base$a();
  gridUnit.top = iChartOpt.padding[0];
  gridUnit.left = iChartOpt.padding[3];
  gridUnit.right = iChartOpt.padding[1];
  gridUnit.bottom = iChartOpt.padding[2];
  var gridResult = iChartOpt.grid || [gridUnit];
  if (!isArray(gridResult)) {
    gridResult = [gridResult];
  }
  gridResult.forEach(function(item) {
    merge(gridUnit, item);
  });
  return gridResult;
}
function getBaseOption$3() {
  return {
    data: [],
    // 坐标轴类型
    type: "category",
    // 坐标轴两边留白策略
    boundaryGap: true,
    // 坐标轴在grid区域中分隔线
    splitLine: {
      show: false,
      lineStyle: {
        width: Theme$1.config.xAxisSplitLineWidth,
        color: Theme$1.config.xAxisSplitLineColor,
        type: Theme$1.config.xAxisSplitLineType
      }
    },
    // 坐标轴名称样式配置
    nameTextStyle: {
      color: Theme$1.config.xAxisNameColor,
      fontSize: Theme$1.config.xAxisNameFontSize
    },
    // 坐标轴线配置
    axisLine: {
      lineStyle: {
        width: Theme$1.config.xAxisLineWidth,
        color: Theme$1.config.xAxisLineColor,
        type: Theme$1.config.xAxisLineType
      }
    },
    // 坐标轴刻度配置
    axisTick: {
      alignWithLabel: true,
      lineStyle: {
        width: Theme$1.config.xAxisTickLineWidth,
        color: Theme$1.config.xAxisTickLineColor,
        type: Theme$1.config.xAxisTickLineType
      }
    },
    // 坐标轴刻度标签配置
    axisLabel: {
      color: Theme$1.config.xAxisLabelColor,
      fontSize: Theme$1.config.xAxisLabelFontSize
    }
  };
}
function base$9() {
  var option = getBaseOption$3();
  return option;
}
function name(xAxisUnit, xAxisItem, iChartOpt) {
  xAxisUnit.name = iChartOpt.xAxisName || xAxisItem.name;
  xAxisUnit.nameLocation = xAxisItem.nameLocation || "end";
  xAxisUnit.nameTextStyle = Object.assign(xAxisUnit.nameTextStyle, xAxisItem.nameTextStyle);
}
function axisLine(xAxisUnit, xAxisItem, iChartOption) {
  if (iChartOption.xAxisLine || xAxisItem.line) {
    var xAxisLine = iChartOption.xAxisLine || xAxisItem.line;
    if (xAxisLine.show === false) {
      xAxisUnit.axisLine.show = false;
      xAxisUnit.axisTick.show = false;
      xAxisUnit.axisLabel.show = false;
    }
    if (xAxisLine.lineStyle) {
      Object.assign(xAxisUnit.axisLine.lineStyle, xAxisLine.lineStyle);
    }
    if (xAxisLine.textStyle) {
      Object.assign(xAxisUnit.axisLabel, xAxisLine.textStyle);
    }
  }
}
function axisLabel(xAxisUnit, xAxisItem, iChartOption) {
  xAxisUnit.axisLabel.formatter = xAxisItem.formatter || void 0;
  xAxisUnit.axisLabel.interval = iChartOption.xAxisInterval || xAxisItem.interval;
  xAxisUnit.axisLabel.rotate = iChartOption.xAxisLabelRotate || xAxisItem.labelRotate;
  if (iChartOption.xAxisEllipsis || xAxisItem.ellipsis) {
    var xEllipsis = iChartOption.xAxisEllipsis || xAxisItem.ellipsis;
    xAxisUnit.axisLabel.overflow = xEllipsis.overflow || "none";
    xAxisUnit.axisLabel.width = xEllipsis.labelWidth;
  }
}
function axisMargin(xAxisUnit, xAxisItem, iChartOption) {
  if (xAxisItem && xAxisItem.axisMargin) {
    var axisMargin2 = xAxisItem.axisMargin;
    var _min2 = axisMargin2.left;
    var _max2 = axisMargin2.right;
    if (_min2) {
      xAxisUnit.min = function(value) {
        return value.min - _min2;
      };
    }
    if (_max2) {
      xAxisUnit.max = function(value) {
        return value.max + _max2;
      };
    }
  }
}
function boundaryGap(xAxisUnit, xAxisItem, iChartOption) {
  var xAxisFullGrid = iChartOption.xAxisFullGrid || xAxisItem.fullGrid;
  xAxisUnit.boundaryGap = xAxisFullGrid !== true;
}
function xAxis(iChartOpt, chartName2) {
  var xAxisResult = iChartOpt.xAxis || {};
  xAxisResult = toArray(xAxisResult).map(function(xAxisItem) {
    var xAxisUnit = base$9();
    name(xAxisUnit, xAxisItem, iChartOpt);
    boundaryGap(xAxisUnit, xAxisItem, iChartOpt);
    axisLabel(xAxisUnit, xAxisItem, iChartOpt);
    axisLine(xAxisUnit, xAxisItem, iChartOpt);
    axisMargin(xAxisUnit, xAxisItem);
    merge(xAxisUnit, xAxisItem);
    return xAxisUnit;
  });
  return xAxisResult;
}
function getBaseOption$2() {
  return {
    type: "value",
    axisLine: {
      show: false,
      lineStyle: {
        width: Theme$1.config.yAxisLineWidth,
        type: Theme$1.config.yAxisLineType,
        color: Theme$1.config.yAxisLineColor
      }
    },
    axisTick: {
      show: false,
      lineStyle: {
        width: Theme$1.config.yAxisTickLineWidth,
        type: Theme$1.config.yAxisTickLineType,
        color: Theme$1.config.yAxisTickLineColor
      }
    },
    axisLabel: {
      color: Theme$1.config.yAxisLabelColor,
      fontSize: Theme$1.config.yAxisLabelFontSize
    },
    nameTextStyle: {
      color: Theme$1.config.yAxisNameColor,
      fontSize: Theme$1.config.yAxisNameFontSize
    },
    splitLine: {
      show: true,
      lineStyle: {
        width: Theme$1.config.yAxisSplitLineWidth,
        type: Theme$1.config.yAxisSplitLineType,
        color: Theme$1.config.yAxisSplitLineColor
      },
      minInterval: void 0,
      maxInterval: void 0
    }
  };
}
function base$8() {
  return getBaseOption$2();
}
function getBaseOption$1() {
  return {
    text: "",
    textStyle: {
      fontWeight: "normal",
      color: Theme$1.config.yAxisNameColor,
      fontSize: Theme$1.config.yAxisNameFontSize
    },
    padding: [0, 0, 0, 0]
  };
}
function base$7() {
  return getBaseOption$1();
}
var appendHTML = function appendHTML2(dom, child) {
  dom.insertAdjacentHTML("beforeend", child);
};
var appendDom = function appendDom2(dom, child) {
  dom.insertAdjacentElement("beforeend", child);
};
var getTextWidth = function getTextWidth2(text, fontSize) {
  if (fontSize === void 0) {
    fontSize = 12;
  }
  var result = 0;
  var ele = document.createElement("span");
  ele.innerText = text;
  ele.setAttribute("style", "font-size: " + fontSize + "px");
  document.documentElement.append(ele);
  result = ele.offsetWidth;
  document.documentElement.removeChild(ele);
  return result;
};
var completePadding = function completePadding2(padding) {
  var titlePadding = [];
  if (!padding || padding.length === 0) {
    titlePadding = [20, 0, 0, 20];
  } else if (padding.length === 1) {
    titlePadding = [padding[0] + 20, padding[0], padding[0], padding[0] + 20];
  } else if (padding.length === 2) {
    titlePadding = [padding[0] + 20, padding[1], padding[0], padding[1] + 20];
  } else if (padding.length === 3) {
    titlePadding = [padding[0] + 20, padding[1], padding[2], padding[1] + 20];
  } else {
    titlePadding = [padding[0] + 20, padding[1], padding[2], padding[3] + 20];
  }
  return titlePadding;
};
var completePadding$1 = completePadding;
function title$1(iChartOption, chartName2, nameTextStyle) {
  if (nameTextStyle === void 0) {
    nameTextStyle = {};
  }
  var name2 = "";
  if (iChartOption.yAxisName) {
    name2 = iChartOption.yAxisName;
  }
  if (iChartOption.yAxis && iChartOption.yAxis.name) {
    name2 = iChartOption.yAxis.name;
  }
  if (iChartOption.yAxis && iChartOption.yAxis.length === 1 && iChartOption.yAxis[0].name) {
    name2 = iChartOption.yAxis[0].name;
  }
  iChartOption.theme;
  var padding = iChartOption.padding;
  var title2 = base$7();
  title2.text = name2;
  if (chartName2 === "BarChart" && iChartOption.direction === "horizontal") {
    var nameLength = getTextWidth(name2, 12);
    title2.right = padding[1] - nameLength - 24;
    title2.bottom = padding[2];
    title2.textAlign = "left";
  } else {
    title2.padding[0] = padding[0] - 30;
    title2.padding[3] = padding[3];
  }
  merge(title2.textStyle, nameTextStyle);
  merge(title2.padding, completePadding$1(nameTextStyle.padding));
  delete title2.textStyle.padding;
  return title2;
}
var transformData = function transformData2(origindata) {
  var newData = {};
  var count = Object.keys(origindata[0]).length;
  var _loop = function _loop2(i2) {
    var arr = [];
    origindata.forEach(function(key) {
      var firstKey = Object.keys(key)[i2];
      var firstValue = key[firstKey];
      arr.push(firstValue);
      newData[firstKey] = arr;
    });
  };
  for (var i = 1; i < count; i++) {
    _loop(i);
  }
  return newData;
};
var fluctuation = function fluctuation2(data3, allowRange) {
  var min2 = Infinity;
  var max2 = -Infinity;
  var range = allowRange || [-Infinity, Infinity];
  var dataKeys = Object.keys(data3);
  dataKeys.forEach(function(key) {
    data3[key].forEach(function(item) {
      if (isArray(item)) {
        var arr = item.filter(function(t) {
          return !isNaN(Number(t)) && Number(t) > range[0] && Number(t) < range[1];
        });
        var curMin = Math.min.apply(Math, arr);
        var curMax = Math.max.apply(Math, arr);
        min2 = Math.min(min2, curMin);
        max2 = Math.max(max2, curMax);
      } else {
        var num = Number(item);
        if (num < range[0] || num > range[1]) {
          return;
        }
        min2 = Math.min(min2, num);
        max2 = Math.max(max2, num);
      }
    });
  });
  var axisMin = Math.floor(min2 - (max2 - min2) / 5 * 4);
  if (min2 > 0 && axisMin < 0) {
    axisMin = 0;
  }
  var axisMax = Math.ceil(max2 + (max2 - min2) / 5);
  return [axisMin, axisMax];
};
var fluctuation$1 = fluctuation;
function yAxis(baseOpt, iChartOpt, chartName2) {
  var yAxisOpt = iChartOpt.yAxis;
  var yAxisName = iChartOpt.yAxisName;
  var data3 = iChartOpt.data;
  if (!isArray(yAxisOpt)) {
    yAxisOpt = [yAxisOpt];
  }
  if (isNeedTitle(yAxisOpt, yAxisName)) {
    var _yAxisOpt$;
    baseOpt.title = title$1(iChartOpt, chartName2, (_yAxisOpt$ = yAxisOpt[0]) == null ? void 0 : _yAxisOpt$.nameTextStyle);
  }
  var yAxis2 = [];
  yAxisOpt.forEach(function(item, index) {
    var temp = base$8();
    if (item && item.unit) {
      temp.axisLabel.formatter = "{value} " + item.unit;
    }
    if (item && item.formatter) {
      temp.axisLabel.formatter = item.formatter;
    }
    if (item && item.name) {
      item.nameTextStyle = Object.assign(temp.nameTextStyle, item.nameTextStyle);
    }
    if (item && item.labelTextStyle) {
      item.labelTextStyle = Object.assign(temp.axisLabel, item.labelTextStyle);
    }
    if (item && item.splitLine) {
      item.splitLine = Object.assign(temp.splitLine, item.splitLine);
    }
    if (item && item.fluctuation === true) {
      var newdata = transformData(data3);
      var value = fluctuation$1(newdata);
      temp.min = value[0];
      temp.max = value[1];
    }
    if (item && item.allowRange) {
      var _newdata = transformData(data3);
      var _value = fluctuation$1(_newdata, item.allowRange);
      temp.min = _value[0];
      temp.max = _value[1];
    }
    temp = merge(temp, item);
    if (index === 0 && yAxisOpt.length === 1 && temp.position !== "right") {
      delete temp.name;
    }
    yAxis2.push(temp);
  });
  return yAxis2;
}
function isNeedTitle(yAxisOpt, yAxisName) {
  if (yAxisName) {
    return true;
  }
  if (yAxisOpt.length === 1 && yAxisOpt[0] && yAxisOpt[0].position !== "right") {
    return true;
  }
  return false;
}
var pageIconArr = ["path://M677.391515 873.916768c-7.86101 0-15.618586-2.999596-21.617778-8.895354L324.473535 533.721212c-11.998384-11.894949-11.998384-31.340606 0-43.235555L655.670303 159.288889c5.999192-5.999192 13.756768-8.895354 21.617778-8.895354 7.757576 0 15.618586 2.999596 21.617778 8.895354 11.894949 11.894949 11.894949 31.237172 0 43.235555L389.223434 512.103434 698.905859 821.785859c11.894949 11.998384 11.894949 31.340606 0 43.235555-5.895758 5.895758-13.756768 8.895354-21.514344 8.895354z m0 0", "path://M711.6 488.624L355.2 152.976a29.36 29.36 0 0 0-42.352 0 31.408 31.408 0 0 0 0 43.552L647.76 512 312.848 827.36a31.408 31.408 0 0 0 0 43.552 29.36 29.36 0 0 0 42.352 0l356.4-335.648a36.32 36.32 0 0 0 0-46.64z"];
function getBaseOption() {
  return {
    data: [],
    icon: "circle",
    left: "center",
    bottom: 12,
    padding: Theme$1.config.legendPadding,
    inactiveColor: Theme$1.config.legendInactiveColor,
    inactiveBorderColor: Theme$1.config.legendInactiveBorderColor,
    inactiveBorderWidth: Theme$1.config.legendInactiveBorderWidth,
    borderWidth: Theme$1.config.legendBorderWidth,
    formatter: void 0,
    textStyle: {
      fontSize: Theme$1.config.legendTextFontSize,
      color: Theme$1.config.legendTextColor,
      align: "left",
      verticalAlign: "top",
      padding: Theme$1.config.legendTextPadding,
      rich: {
        a: {
          fontSize: Theme$1.config.legendTextRichFontSize,
          color: Theme$1.config.legendTextRichColor,
          align: "left",
          verticalAlign: "top",
          padding: Theme$1.config.legendTextRichPadding
        },
        b: {
          fontSize: Theme$1.config.legendTextRichFontSize,
          color: Theme$1.config.legendTextRichColor,
          align: "left",
          verticalAlign: "top",
          padding: Theme$1.config.legendTextRichPadding
        }
      },
      overflow: "none",
      width: void 0
    },
    width: void 0,
    pageTextStyle: {
      color: Theme$1.config.legendPageTextColor
    },
    pageIconColor: Theme$1.config.legendPageIconColor,
    pageIconInactiveColor: Theme$1.config.legendPageIconInactiveColor,
    pageIcons: {
      horizontal: pageIconArr,
      vertical: pageIconArr
    },
    selectedMode: true,
    align: "left",
    itemGap: Theme$1.config.legendItemGap,
    itemWidth: Theme$1.config.legendCircleItemWidth,
    itemHeight: Theme$1.config.legendCircleItemHeight,
    itemStyle: {
      borderWidth: Theme$1.config.legendItemBorderWidth
    }
  };
}
function base$6() {
  return getBaseOption();
}
function icon(legend2, iChartOption) {
  if (iChartOption.legend.icon === "line") {
    legend2.icon = "rect";
    legend2.itemHeight = Theme$1.config.legendReactItemHeight;
    legend2.itemWidth = Theme$1.config.legendReactItemWidth;
  }
}
function size(legend2, selfLegend) {
  legend2.width = selfLegend.width || "auto";
  legend2.height = selfLegend.height || "auto";
}
function position(legend2, selfLegend) {
  legend2.top = selfLegend.position.top || "auto";
  legend2.left = selfLegend.position.left || "auto";
  legend2.right = selfLegend.position.right || "auto";
  legend2.bottom = selfLegend.position.bottom || "auto";
}
function textStyle$1(legend2, textStyle2) {
  if (textStyle2) {
    legend2.textStyle.rich = Object.assign(legend2.textStyle.rich, textStyle2.rich);
    legend2.textStyle = Object.assign(legend2.textStyle, textStyle2);
  }
}
function itemStyle(legend2, chartName2) {
  if (chartName2 === "BubbleChart") {
    legend2.itemStyle.borderWidth = 1;
  }
}
function legend(iChartOption, chartName2) {
  var selfLegend = iChartOption.legend;
  var data3 = selfLegend.data, show = selfLegend.show, orient2 = selfLegend.orient, formatter4 = selfLegend.formatter, selectedMode = selfLegend.selectedMode;
  var legend2 = base$6();
  if (!show) {
    legend2.show = false;
  }
  if (orient2) {
    legend2.orient = orient2;
  }
  legend2.selectedMode = selectedMode !== void 0 ? selectedMode : true;
  position(legend2, selfLegend);
  size(legend2, selfLegend);
  itemStyle(legend2, chartName2);
  legend2.formatter = formatter4;
  legend2.itemWidth = selfLegend.itemWidth || legend2.itemWidth;
  legend2.itemHeight = selfLegend.itemHeight || legend2.itemHeight;
  legend2.itemGap = selfLegend.itemGap || legend2.itemGap;
  legend2.data = data3;
  textStyle$1(legend2, selfLegend.textStyle);
  Object.assign(legend2, iChartOption.legend);
  icon(legend2, iChartOption);
  return legend2;
}
var chartType = ["CircleProcessChart", "GaugeChart", "RadarChart", "FunnelChart", "JadeJueChart", "LiquidfillChart", "PieChart", "PolarBarChart", "SunburstChart"];
function getbaseOption(chartName2) {
  var trigger = chartName2 && chartType.includes(chartName2) ? "item" : "axis";
  return {
    trigger,
    confine: true,
    borderRadius: Theme$1.config.tooltipBorderRaduis,
    axisPointer: {
      z: 0,
      type: "line",
      lineStyle: {
        type: Theme$1.config.tooltipAxisPointerLineType,
        width: Theme$1.config.tooltipAxisPointerLineWidth,
        color: Theme$1.config.tooltipAxisPointerLineColor
      },
      shadowStyle: {
        color: Theme$1.config.tooltipAxisPointerShadowColor
      }
    },
    textStyle: {
      color: Theme$1.config.tooltipTextColor,
      fontSize: Theme$1.config.tooltipTextFontSize
    },
    borderWidth: Theme$1.config.tooltipBorderWidth,
    padding: Theme$1.config.tooltipPadding,
    backgroundColor: Theme$1.config.tooltipBg,
    formatter: void 0,
    extraCssText: "box-shadow:0 " + Theme$1.config.tooltipShadowOffsetY + "px \n    " + Theme$1.config.tooltipShadowBlur + "px 0 " + Theme$1.config.tooltipShadowColor + ";"
  };
}
function base$5(chartName2) {
  return getbaseOption(chartName2);
}
function axisPointer(tooltip2, chartName2) {
  switch (chartName2) {
    case "ProcessBarChart":
    case "BarChart":
      tooltip2.axisPointer = {
        type: "shadow",
        shadowStyle: {
          color: Theme$1.config.tooltipAxisPointerShadowColor
        }
      };
      break;
  }
}
function tooltip(iChartOption, chartName2) {
  var formatter4 = iChartOption.tipHtml;
  var formatterStyle = iChartOption.tipHtmlStyle;
  var tooltip2 = base$5(chartName2);
  if (formatter4) {
    tooltip2.formatter = formatter4;
  }
  if (formatterStyle) {
    tooltip2.padding = formatterStyle.padding || tooltip2.padding;
    tooltip2.backgroundColor = formatterStyle.backgroundColor || tooltip2.backgroundColor;
  }
  axisPointer(tooltip2, chartName2);
  merge(tooltip2, iChartOption.tooltip);
  return tooltip2;
}
var baseOption = [{
  end: 100,
  start: 0,
  height: 24,
  bottom: 18,
  show: false,
  type: "slider",
  left: "center",
  xAxisIndex: [0],
  zoomLock: false,
  borderColor: "none",
  // 边框
  backgroundColor: void 0,
  // 背景颜色
  fillerColor: void 0,
  // 选中范围填充颜色
  handleSize: "85%",
  // 控制手柄的尺寸
  handleIcon: "path://M0 0.2 Q 0 0 0.2 0 L0.8 0 Q1 0 1 0.2 L1 2.8 Q1 3 0.8 3L0.2 3 Q0 3 0 2.8 Z",
  // 手柄形状
  handleStyle: {
    color: void 0,
    // 手柄颜色
    shadowBlur: 5,
    // 阴影模糊大小
    shadowColor: void 0,
    shadowOffsetX: 0,
    // 阴影偏移x轴多少
    shadowOffsetY: 0,
    // 阴影偏移y轴多少
    opacity: 1,
    // 透明度
    borderColor: void 0,
    // 手柄边框颜色
    borderWidth: 5,
    // 手柄边框宽度
    borderJoin: "round"
    // 手柄边框圆角
  },
  dataBackground: {
    lineStyle: {
      color: void 0,
      // 线条颜色
      join: "round",
      cap: "round"
    },
    areaStyle: {
      opacity: 1,
      // 阴影的透明度
      color: void 0
      // 填充的颜色
    }
  },
  selectedDataBackground: {
    // 选中部分样式
    lineStyle: {
      color: void 0
      // 线条颜色
    },
    areaStyle: {
      opacity: 0.9,
      // 阴影的透明度
      color: void 0
      // 填充的颜色
    }
  },
  moveHandleSize: "0",
  // 移动手柄的尺寸高度
  emphasis: {
    handleStyle: {
      color: void 0,
      borderColor: void 0
    }
  }
}];
function base$4(theme) {
  var option = cloneDeep(baseOption);
  if (theme.includes("dark")) {
    option[0].handleStyle.color = Theme$1.config.dataZoomHandleColor;
    option[0].handleStyle.borderColor = Theme$1.config.dataZoomHandleBorderColor;
    option[0].handleStyle.shadowColor = Theme$1.config.dataZoomHandleShadowColor;
    option[0].emphasis.handleStyle.color = Theme$1.config.dataZoomEmphasisHandleColor;
    option[0].emphasis.handleStyle.borderColor = Theme$1.config.dataZoomEmphasisHandleBorderColor;
    option[0].backgroundColor = "#090909";
    option[0].fillerColor = "rgba(255,255,255,0)";
    option[0].dataBackground.lineStyle.color = "#282828";
    option[0].dataBackground.areaStyle.color = "#282828";
    option[0].selectedDataBackground.lineStyle.color = "#555555";
    option[0].selectedDataBackground.areaStyle.color = "#555555";
  } else {
    option[0].handleStyle.color = "#ffffff";
    option[0].handleStyle.borderColor = "#1476ff";
    option[0].handleStyle.shadowColor = "transparent";
    option[0].emphasis.handleStyle.color = "#ffffff";
    option[0].emphasis.handleStyle.borderColor = "#1476ff";
    option[0].backgroundColor = "#f3f3f3";
    option[0].fillerColor = "rgba(175,218,245,.5)";
    option[0].dataBackground.lineStyle.color = "#c2c2c2";
    option[0].dataBackground.areaStyle.color = "#e8e8e8";
    option[0].selectedDataBackground.lineStyle.color = "#9fb3ce";
    option[0].selectedDataBackground.areaStyle.color = "#bcd0eb";
  }
  return option;
}
function datazoom(iChartOption) {
  var theme = iChartOption.theme;
  var self2 = iChartOption.dataZoom;
  var dataZoom = base$4(theme);
  var show = self2.show, position2 = self2.position, start = self2.start, end = self2.end, startValue = self2.startValue, endValue = self2.endValue, style = self2.style, zoomOnMouseWheel = self2.zoomOnMouseWheel, height = self2.height;
  if (show) {
    end && (dataZoom[0].end = end);
    start && (dataZoom[0].start = start);
    if (startValue !== void 0) {
      delete dataZoom[0].start;
      dataZoom[0].startValue = startValue;
    }
    if (endValue !== void 0) {
      delete dataZoom[0].end;
      dataZoom[0].endValue = endValue;
    }
    height && (dataZoom[0].height = height);
    dataZoom[0].show = true;
    dataZoom[0].top = position2.top || "auto";
    dataZoom[0].left = position2.left || "auto";
    dataZoom[0].right = position2.right || "auto";
    dataZoom[0].bottom = position2.bottom || "auto";
    if (style) {
      var _dataZoom$ = dataZoom[0], backgroundColor = _dataZoom$.backgroundColor, dataBackground = _dataZoom$.dataBackground, selectedDataBackground = _dataZoom$.selectedDataBackground, fillerColor = _dataZoom$.fillerColor;
      dataZoom[0].backgroundColor = style.backgroundColor || backgroundColor;
      dataZoom[0].dataBackground.areaStyle.color = style.unSelectDataColor || dataBackground.areaStyle.color;
      dataZoom[0].selectedDataBackground.areaStyle.color = style.selectDataColor || selectedDataBackground.areaStyle.color;
      dataZoom[0].fillerColor = style.middleFillerColor || fillerColor;
      if (style.handleStyle) {
        dataZoom[0].handleStyle = Object.assign(dataZoom[0].handleStyle, style.handleStyle);
      }
    }
    merge(dataZoom[0], self2);
  }
  return dataZoom;
}
function xkey(iChartOption) {
  var xAxisKey;
  iChartOption.xAxis.forEach(function(xAxisItem) {
    xAxisKey = xAxisItem.keyName;
  });
  return xAxisKey;
}
function xdata(data3, xAxisKey) {
  var xAxisData = [];
  data3.forEach(function(item) {
    xAxisData.push(item[xAxisKey]);
  });
  return xAxisData;
}
function ydata(data3, legendData) {
  var seriesData = {};
  legendData.forEach(function(legend2) {
    seriesData[legend2] = [];
  });
  data3.forEach(function(item) {
    legendData.forEach(function(legend2) {
      seriesData[legend2].push(item[legend2]);
    });
  });
  return seriesData;
}
function ldata(data3, xAxisKey) {
  var legendData = [];
  if (data3.length > 0) {
    var temp = data3[0];
    for (var key in temp) {
      if (key !== xAxisKey) {
        legendData.push(key);
      }
    }
  }
  return legendData;
}
function RectCoordSys(baseOpt, iChartOpt, chartName2) {
  baseOpt.grid = grid(iChartOpt);
  baseOpt.color = iChartOpt.color;
  baseOpt.xAxis = xAxis(iChartOpt);
  baseOpt.yAxis = yAxis(baseOpt, iChartOpt, chartName2);
  baseOpt.tooltip = tooltip(iChartOpt, chartName2);
  baseOpt.legend = legend(iChartOpt, chartName2);
  baseOpt.dataZoom = datazoom(iChartOpt);
}
var LineChart = /* @__PURE__ */ function() {
  function LineChart2(iChartOption, chartInstance) {
    this.baseOption = {};
    this.baseOption = cloneDeep(BaseOption$6);
    this.iChartOption = {};
    this.iChartOption = init(iChartOption);
    this.updateOption(chartInstance);
  }
  var _proto6 = LineChart2.prototype;
  _proto6.updateOption = function updateOption(chartInstance) {
    var theme = this.iChartOption.theme;
    var iChartOption = this.iChartOption;
    RectCoordSys(this.baseOption, this.iChartOption, "LineChart");
    var xAxisKey = xkey(iChartOption);
    var xAxisData = xdata(iChartOption.data, xAxisKey);
    var legendData = ldata(iChartOption.data, xAxisKey);
    var seriesData = ydata(iChartOption.data, legendData);
    handleData$2(this.baseOption, legendData, xAxisData);
    this.baseOption.series = setSeries$8({
      theme,
      seriesData,
      legendData,
      yAxis: iChartOption.yAxis,
      focus: iChartOption.focus,
      stack: iChartOption.stack,
      isStep: iChartOption.step,
      isArea: iChartOption.area,
      colors: this.baseOption.color,
      isSmooth: iChartOption.smooth,
      markLine: iChartOption.markLine,
      markPoint: iChartOption.markPoint,
      splitLine: iChartOption.splitLine,
      labelHtml: iChartOption.labelHtml,
      itemStyle: iChartOption.itemStyle
    });
    this.baseOption.visualMap = setVisualMap$2(legendData, seriesData, iChartOption.markLine, iChartOption.color, iChartOption.theme);
    handlePredict(this.baseOption, iChartOption.predict, iChartOption.tipHtml, iChartOption.lineStyle);
    if (iChartOption.event) {
      event(chartInstance, iChartOption.event);
    }
    if (iChartOption.silent) {
      this.baseOption.tooltip = {};
    }
    this.baseOption.animationDuration = this.iChartOption.animationDuration || 1e3;
    onlyOnePoint(this.baseOption);
    discrete(iChartOption, this.baseOption);
    mergeSeries(iChartOption, this.baseOption);
    mergeVisualMap(iChartOption, this.baseOption);
    mini(iChartOption, this.baseOption);
  };
  _proto6.updateOptionAgain = function updateOptionAgain(YAxiMax, YAxiMin) {
    topArea(this.baseOption, this.iChartOption, YAxiMin);
    bottomArea(this.baseOption, this.iChartOption, YAxiMax);
  };
  _proto6.getOption = function getOption() {
    return this.baseOption;
  };
  return LineChart2;
}();
var LineChart$1 = LineChart;
function getChartToken$d() {
  var _Theme$1$config$BarCh = Theme$1.config.BarChart, _Theme$1$config$BarCh2 = _Theme$1$config$BarCh.itemStyle, borderWidth = _Theme$1$config$BarCh2.borderWidth, borderColor = _Theme$1$config$BarCh2.borderColor, borderRadius2 = _Theme$1$config$BarCh2.borderRadius, color3 = _Theme$1$config$BarCh2.color, _Theme$1$config$BarCh3 = _Theme$1$config$BarCh.label, colorLabel = _Theme$1$config$BarCh3.color, fontSize = _Theme$1$config$BarCh3.fontSize, barWidth = _Theme$1$config$BarCh.barWidth;
  var colorError = Theme$1.config.colorState.colorError;
  return {
    borderWidth,
    borderColor,
    borderRadius: borderRadius2,
    color: color3,
    labelColor: colorLabel,
    fontSize,
    barWidth,
    colorError
  };
}
var chartToken$u = proxy(getChartToken$d);
var chartToken$v = chartToken$u;
function setStack(baseOption2, iChartOption, legendData, seriesData) {
  var type = iChartOption.type;
  if (type && type === "stack") {
    baseOption2.series.forEach(function(item) {
      item.itemStyle.borderWidth = chartToken$v.borderWidth;
      item.itemStyle.borderColor = chartToken$v.borderColor;
    });
    var direction = iChartOption.direction;
    iChartOption.data.forEach(function(item, i) {
      for (var j = legendData.length - 1; j >= 0; j--) {
        var _name5 = legendData[j];
        if (item[_name5]) {
          seriesData[_name5][i] = {
            value: seriesData[_name5][i],
            itemStyle: {
              borderRadius: direction === "horizontal" ? [0, chartToken$v.borderRadius, chartToken$v.borderRadius, 0] : [chartToken$v.borderRadius, chartToken$v.borderRadius, 0, 0]
            }
          };
          break;
        }
      }
    });
  }
}
function setDoubleSides(baseOption2, iChartOption) {
  var type = iChartOption.type;
  if (type && type === "double-sides") {
    var _yAxis = baseOption2.yAxis;
    _yAxis.forEach(function(item) {
      item.axisLabel.formatter = function(value) {
        return Math.abs(value);
      };
    });
    if (!baseOption2.tooltip.formatter) {
      baseOption2.tooltip.formatter = function(params, ticket, callback) {
        var html = "";
        params.forEach(function(item, index) {
          if (index === 0) {
            html += '<div style="margin-bottom:4px;">' + defendXSS$1(item.name) + "</div>";
          }
          html += '<div>\n                      <span style="display:inline-block;width:10px;height:10px;border-radius:5px;background-color:' + defendXSS$1(item.color) + ';"></span>\n                      <span style="margin-left:5px;color:#000000">\n                          <span style="display:inline-block; margin-right:8px;min-width:48px;">' + defendXSS$1(item.seriesName) + '</span> \n                          <span style="font-weight:bold">' + defendXSS$1(item.value ? Math.abs(item.value) : "-") + "</span>\n                      </span>\n                  </div>";
        });
        return html;
      };
    }
  }
}
function setDirection$2(baseOption2, direction) {
  if (direction && direction === "horizontal") {
    var temp = baseOption2.xAxis;
    baseOption2.xAxis = baseOption2.yAxis;
    baseOption2.yAxis = temp;
  }
}
var seriesInit$8 = function seriesInit$82() {
  return {
    label: {
      show: false,
      color: chartToken$v.labelColor,
      fontSize: chartToken$v.fontSize
    },
    // 数据
    data: [],
    // 柱形
    type: "bar",
    // 柱条宽度
    barWidth: chartToken$v.barWidth,
    // 柱间距离
    barGap: "60%",
    // 阈值线
    markLine: null,
    // 峰值标志
    markPoint: null,
    // 柱形的每个样式配置项
    itemStyle: {
      borderRadius: [chartToken$v.borderRadius, chartToken$v.borderRadius, 0, 0]
    }
  };
};
function handleWaterFall(type, seriesUnit) {
  if (type && type === "water-fall") {
    seriesUnit.itemStyle.borderRadius = [chartToken$v.borderRadius, chartToken$v.borderRadius, chartToken$v.borderRadius, chartToken$v.borderRadius];
    seriesUnit.data.push(seriesUnit.data.reduce(function(prev, curr) {
      var n = Number(curr) || 0;
      return prev + n;
    }, 0));
  }
}
function handleRange(type, seriesUnit) {
  if (type && type === "range") {
    seriesUnit.itemStyle.borderRadius = [chartToken$v.borderRadius, chartToken$v.borderRadius, chartToken$v.borderRadius, chartToken$v.borderRadius];
  }
}
function setSeries$7(seriesData, legendData, iChartOption) {
  var type = iChartOption.type;
  var direction = iChartOption.direction;
  var seriesInit_ = handleItemStyle$1(direction, iChartOption.itemStyle);
  var series = [];
  legendData.forEach(function(legend2, index) {
    var seriesUnit = cloneDeep(seriesInit_);
    handleLabel$2(seriesUnit, iChartOption, index);
    handleFocus(seriesUnit, iChartOption);
    seriesUnit.name = legend2;
    if (iChartOption.itemStyle && iChartOption.itemStyle.barMinHeight) {
      seriesUnit.data = seriesData[legend2].map(function(item) {
        return item === 0 ? void 0 : item;
      });
    } else {
      seriesUnit.data = seriesData[legend2];
    }
    handleMarkLine(seriesUnit, iChartOption, direction);
    handleStack(type, seriesUnit, index, legendData, iChartOption);
    handleBothSides(type, seriesUnit, direction, index, legendData);
    handleDoubleSides(type, seriesUnit, index, legendData);
    handleWaterFall(type, seriesUnit);
    handleRange(type, seriesUnit);
    handleContain(type, seriesUnit);
    series.push(seriesUnit);
  });
  handleYaxis$2(series, iChartOption.yAxis);
  return series;
}
function handleItemStyle$1(direction, itemStyle2) {
  var seriesInit_ = cloneDeep(seriesInit$8());
  if (direction && direction === "horizontal") {
    seriesInit_.itemStyle.borderRadius = [0, chartToken$v.borderRadius, chartToken$v.borderRadius, 0];
  }
  if (itemStyle2 != null && itemStyle2.barMinHeight) {
    seriesInit_.barMinHeight = itemStyle2.barMinHeight;
  }
  if (itemStyle2 != null && itemStyle2.barWidth) {
    seriesInit_.barWidth = itemStyle2.barWidth;
  }
  if (itemStyle2 != null && itemStyle2.barGap) {
    seriesInit_.barGap = itemStyle2.barGap;
  }
  if (itemStyle2 != null && itemStyle2.color) {
    seriesInit_.itemStyle.color = itemStyle2.color;
  }
  merge(seriesInit_.itemStyle, itemStyle2);
  return seriesInit_;
}
function handleLabel$2(seriesUnit, iChartOption, index) {
  var label2 = iChartOption.label;
  var labelOption;
  if (label2 && isArray(label2)) {
    labelOption = label2[index];
  } else {
    labelOption = label2;
  }
  if (labelOption && labelOption.show) {
    merge(seriesUnit.label, labelOption);
    seriesUnit.label.show = true;
    seriesUnit.label.offset = labelOption.offset || [0, 0];
    seriesUnit.label.position = labelOption.position || "inside";
    seriesUnit.label.formatter = labelOption.formatter;
  }
}
function handleMarkLine(seriesUnit, iChartOption, direction) {
  var name2 = seriesUnit.name;
  var markLine = iChartOption.markLine;
  var isTopMarkLine = markLine && markLine.top && !(markLine.topUse && !markLine.topUse.includes(name2));
  var isBottomMarkLine = markLine && markLine.bottom && !(markLine.bottomUse && !markLine.bottomUse.includes(name2));
  if (isTopMarkLine || isBottomMarkLine) {
    seriesUnit.markLine = cloneDeep(getMarkLineDefault());
    merge(seriesUnit.markLine, markLine);
    seriesUnit.markLine.lineStyle.color = markLine.color || chartToken$v.colorError;
  }
  if (isTopMarkLine) {
    if (direction && direction === "horizontal") {
      seriesUnit.markLine.data.push({
        xAxis: markLine.top
      });
    } else {
      seriesUnit.markLine.data.push({
        yAxis: markLine.top
      });
    }
  }
  if (isBottomMarkLine) {
    if (direction && direction === "horizontal") {
      seriesUnit.markLine.data.push({
        xAxis: markLine.bottom
      });
    } else {
      seriesUnit.markLine.data.push({
        yAxis: markLine.bottom
      });
    }
  }
}
function handleFocus(seriesUnit, iChartOption) {
  if (iChartOption.focus) {
    seriesUnit.emphasis = {
      focus: "series",
      blurScope: "global"
    };
  }
}
function handleStack(type, seriesUnit, index, legendData, iChartOption) {
  if (type && type === "stack") {
    var stack = iChartOption.stack;
    if (stack) {
      for (var _name6 in stack) {
        if (Object.hasOwnProperty.call(stack, _name6)) {
          var stackArray = stack[_name6];
          var seriesName = seriesUnit.name;
          var stackIndex = stackArray.indexOf(seriesName);
          if (stackIndex !== -1) {
            seriesUnit.stack = _name6;
            if (stackIndex + 1 < stackArray.length) {
              delete seriesUnit.itemStyle.borderRadius;
            }
          }
          break;
        }
      }
    } else {
      seriesUnit.stack = "stack";
      if (index !== legendData.length - 1) {
        delete seriesUnit.itemStyle.borderRadius;
      }
    }
  }
}
function handleBothSides(type, seriesUnit, direction, index, legendData) {
  if (type && (type === "both-sides" || type === "double-sides")) {
    seriesUnit.stack = "stack";
    if (direction && direction === "horizontal") {
      if (index === 0) {
        seriesUnit.itemStyle.borderRadius = [0, chartToken$v.borderRadius, chartToken$v.borderRadius, 0];
      }
      if (index === legendData.length - 1) {
        seriesUnit.itemStyle.borderRadius = [chartToken$v.borderRadius, 0, 0, chartToken$v.borderRadius];
      }
    } else {
      if (index === 0) {
        seriesUnit.itemStyle.borderRadius = [chartToken$v.borderRadius, chartToken$v.borderRadius, 0, 0];
      }
      if (index === legendData.length - 1) {
        seriesUnit.itemStyle.borderRadius = [0, 0, chartToken$v.borderRadius, chartToken$v.borderRadius];
      }
    }
  }
}
function handleDoubleSides(type, seriesUnit, index, legendData) {
  if (type && type === "double-sides") {
    if (index === legendData.length - 1) {
      seriesUnit.data = seriesUnit.data.map(function(item) {
        if (isNumber(item)) {
          return -1 * item;
        } else {
          return item;
        }
      });
    }
  }
}
function handleContain(type, seriesUnit) {
  if (type && type === "contain") {
    seriesUnit.barGap = "-100%";
  }
}
function handleColorStops(percent, originColor, markLineColor) {
  var colorStops = [{
    offset: 0,
    color: markLineColor || chartToken$v.colorError
  }, {
    offset: percent,
    color: markLineColor || chartToken$v.colorError
  }, {
    offset: percent + 1e-3,
    color: originColor
  }, {
    offset: 1,
    color: originColor
  }];
  return colorStops;
}
function handleTopObj(d, direction, percent, originColor, markLineColor) {
  var topObj = {
    value: d,
    itemStyle: {
      color: {
        type: "linear",
        x: direction === "horizontal" ? 1 : 0,
        y: direction === "horizontal" ? 0 : 0,
        x2: direction === "horizontal" ? 0 : 0,
        y2: direction === "horizontal" ? 0 : 1,
        colorStops: handleColorStops(percent, originColor, markLineColor)
      }
    }
  };
  return topObj;
}
function handleBottomObj(d, direction, percent, originColor, markLineColor) {
  var bottomObj = {
    value: d,
    itemStyle: {
      color: {
        type: "linear",
        x: direction === "horizontal" ? 0 : 0,
        y: direction === "horizontal" ? 0 : 1,
        x2: direction === "horizontal" ? 1 : 0,
        y2: direction === "horizontal" ? 0 : 0,
        colorStops: handleColorStops(percent, originColor, markLineColor)
      }
    }
  };
  return bottomObj;
}
var colorStopsOrigin = [{
  offset: 0,
  color: chartToken$v.colorError
}, {
  offset: 1,
  color: chartToken$v.colorError
}];
function handleColorStopsTop(originColor, bottomPercent) {
  var colorStops = [{
    offset: 0,
    color: originColor
  }, {
    offset: bottomPercent,
    color: originColor
  }, {
    offset: bottomPercent + 1e-4,
    color: chartToken$v.colorError
  }, {
    offset: 1,
    color: chartToken$v.colorError
  }];
  return colorStops;
}
function handleColorStopsBottom(originColor, topPercent) {
  var colorStops = [{
    offset: 0,
    color: chartToken$v.colorError
  }, {
    offset: topPercent,
    color: chartToken$v.colorError
  }, {
    offset: topPercent + 1e-4,
    color: originColor
  }, {
    offset: 1,
    color: originColor
  }];
  return colorStops;
}
function handleColorStopsOther(originColor, topPercent, bottomPercent) {
  var colorStops = [{
    offset: 0,
    color: chartToken$v.colorError
  }, {
    offset: topPercent,
    color: chartToken$v.colorError
  }, {
    offset: topPercent + 1e-4,
    color: originColor
  }, {
    offset: bottomPercent,
    color: originColor
  }, {
    offset: bottomPercent + 1e-4,
    color: chartToken$v.colorError
  }, {
    offset: 1,
    color: chartToken$v.colorError
  }];
  return colorStops;
}
function handleResObj$1(d, direction, colorStops) {
  var resObj = {
    value: d,
    itemStyle: {
      color: {
        type: "linear",
        x: direction === "horizontal" ? 1 : 0,
        y: direction === "horizontal" ? 0 : 0,
        x2: direction === "horizontal" ? 0 : 0,
        y2: direction === "horizontal" ? 0 : 1,
        colorStops
      }
    }
  };
  return resObj;
}
function handleSeries$6(iChartOption, baseOption2, exclude, colors, direction) {
  var top2 = iChartOption.markLine.top;
  var bottom2 = iChartOption.markLine.bottom;
  var usefullSeries = baseOption2.series.filter(function(item) {
    return !exclude.includes(item.name);
  });
  usefullSeries.forEach(function(item, index) {
    if (!exclude.includes(item.name)) {
      var barData = item.data;
      var placeHolderData = baseOption2.series[index * 2].data;
      item.data = barData.map(function(d, i) {
        var pd = placeHolderData[i];
        if (top2 === void 0) {
          top2 = pd + d + 1;
        }
        if (bottom2 === void 0) {
          bottom2 = pd - 1;
        }
        var originColor = getColor(colors, index);
        var topPercent = 0;
        var bottomPercent = 1;
        topPercent = (d + pd - top2) / d;
        topPercent < 0 && (topPercent = 0);
        topPercent > 1 && (topPercent = 1);
        bottomPercent = (d + pd - bottom2) / d;
        bottomPercent < 0 && (bottomPercent = 0);
        bottomPercent > 1 && (bottomPercent = 1);
        var colorStops = [];
        if (topPercent === 1 || bottomPercent === 0) {
          colorStops = colorStopsOrigin;
        } else if (topPercent === 0 && bottomPercent === 1) {
          return d;
        } else if (topPercent === 0) {
          colorStops = handleColorStopsTop(originColor, bottomPercent);
        } else if (bottomPercent === 1) {
          colorStops = handleColorStopsBottom(originColor, topPercent);
        } else {
          colorStops = handleColorStopsOther(originColor, topPercent, bottomPercent);
        }
        var resObj = handleResObj$1(d, direction, colorStops);
        return resObj;
      });
    }
  });
}
function setMarkLine$2(baseOption2, iChartOption) {
  var type = iChartOption.type;
  var colors = baseOption2.color;
  var direction = iChartOption.direction;
  var exclude = ["Placeholder"];
  if (iChartOption.markLine && type !== "water-fall" && type !== "range") {
    var _top = iChartOption.markLine.top;
    var topUse = iChartOption.markLine.topUse;
    var _bottom = iChartOption.markLine.bottom;
    var bottomUse = iChartOption.markLine.bottomUse;
    var markLineColor = iChartOption.markLine.color;
    var usefullSeries = baseOption2.series.filter(function(item) {
      return !exclude.includes(item.name);
    });
    usefullSeries.forEach(function(item, index) {
      if (!exclude.includes(item.name)) {
        var barData = item.data;
        item.data = barData.map(function(d) {
          var originColor = getColor(colors, index);
          if (_top && d >= 0 && _top >= 0 && d > _top) {
            if (topUse && !topUse.includes(item.name)) {
              return d;
            }
            var percent = (d - _top) / (d - 0);
            var topObj = handleTopObj(d, direction, percent, originColor, markLineColor);
            return topObj;
          } else if (_bottom && d <= 0 && _bottom <= 0 && d < _bottom) {
            if (bottomUse && !bottomUse.includes(item.name)) {
              return d;
            }
            var _percent = (_bottom - d) / (0 - d);
            var bottomObj = handleBottomObj(d, direction, _percent, originColor, markLineColor);
            return bottomObj;
          } else {
            return d;
          }
        });
      }
    });
  }
  if (iChartOption.markLine && type === "range") {
    handleSeries$6(iChartOption, baseOption2, exclude, colors, direction);
  }
}
function placeFun(index, placeholderData) {
  var a = {
    name: "Placeholder",
    type: "bar",
    stack: "stack" + index,
    itemStyle: {
      borderColor: chartToken$v.borderColor,
      color: chartToken$v.color
    },
    emphasis: {
      itemStyle: {
        borderColor: chartToken$v.borderColor,
        color: chartToken$v.color
      }
    },
    data: placeholderData
  };
  return a;
}
function setRange(baseOption2, iChartOption) {
  var type = iChartOption.type;
  if (type && type === "range") {
    var tempArray = [];
    baseOption2.series.forEach(function(item, index) {
      var barData = item.data;
      var barRealData = [];
      var placeholderData = [];
      var placeholder = placeFun(index, placeholderData);
      barData.forEach(function(d) {
        placeholderData.push(d[0]);
        barRealData.push(d[1] - d[0]);
      });
      item.stack = "stack" + index;
      item.data = barRealData;
      tempArray.push(placeholder);
      tempArray.push(item);
    });
    baseOption2.series = tempArray;
  }
}
function setWaterFall(baseOption2, iChartOption) {
  var type = iChartOption.type;
  var totalName = iChartOption.totalName || "Total";
  var totalPosition = iChartOption.totalPosition || "end";
  if (type && type === "water-fall") {
    var tempArray = [];
    baseOption2.series.forEach(function(item, index) {
      var barData = item.data;
      var placeholderData = [0];
      var placeholder = placeFun(index, placeholderData);
      if (totalPosition === "end") {
        barData.forEach(function(d, i) {
          if (i < barData.length - 1) {
            placeholderData.push((Number(d) || 0) + placeholderData[i]);
          }
        });
        placeholderData[placeholderData.length - 1] = 0;
      } else {
        barData.unshift(barData.pop());
        placeholderData[0] = barData[0];
        barData.forEach(function(d, i) {
          if (i > 0) {
            placeholderData.push(placeholderData[i - 1] - (Number(d) || 0));
          }
        });
        placeholderData[0] = 0;
      }
      item.stack = "stack" + index;
      tempArray.push(placeholder);
      tempArray.push(item);
    });
    if (totalPosition === "end") {
      baseOption2.xAxis[0].data.push(totalName);
    } else {
      baseOption2.xAxis[0].data.unshift(totalName);
    }
    baseOption2.series = tempArray;
  }
}
function setLimitFormatter(baseOption2, iChartOption, seriesData) {
  var type = iChartOption.type;
  var toolTipFormatter = baseOption2.tooltip.formatter;
  var exclude = ["Placeholder"];
  var colors = baseOption2.color;
  baseOption2.tooltip.formatter = function(params, ticket, callback) {
    var newParams = params.filter(function(item) {
      return !exclude.includes(item.seriesName);
    });
    if (toolTipFormatter) {
      return toolTipFormatter(newParams, ticket, callback);
    }
    var htmlString = "";
    newParams.forEach(function(item, index) {
      if (index === 0) {
        htmlString += '<div style="margin-bottom:4px;">' + defendXSS$1(item.name) + "</div>";
      }
      var itemColor = typeof item.color === "string" ? item.color : getColor(colors, index);
      htmlString += '\n                    <div>\n                        <span style="display:inline-block;width:10px;height:10px;border-radius:5px;background-color:' + defendXSS$1(itemColor) + ';">\n                        </span>\n                        <span style="margin-left:5px;">\n                            <span style="display:inline-block;margin-right:8px;min-width:60px;">' + defendXSS$1(item.seriesName) + '</span> \n                            <span style="font-weight:bold">\n                              ' + defendXSS$1(type === "range" ? "[" + params[index * 2].value + "-" + (params[index * 2].value + item.value) + "]" : item.value || seriesData[item.seriesName][item.dataIndex]) + "\n                            </span>\n                        </span>\n                    </div>\n                ";
    });
    return htmlString;
  };
}
function handleYaxis$2(series, yAxis2) {
  if (Array.isArray(yAxis2)) {
    yAxis2.forEach(function(y, index) {
      series.forEach(function(s, indexs) {
        if (y.dataName && y.dataName.includes(s.name)) {
          series[indexs].yAxisIndex = index;
        }
      });
    });
  }
}
var BarChart = /* @__PURE__ */ function() {
  function BarChart2(iChartOption, chartInstance) {
    this.baseOption = {};
    this.baseOption = cloneDeep(BaseOption$6);
    this.chartInstance = chartInstance;
    this.iChartOption = init(iChartOption);
    this.updateOption();
  }
  var _proto7 = BarChart2.prototype;
  _proto7.updateOption = function updateOption() {
    var iChartOption = this.iChartOption;
    RectCoordSys(this.baseOption, this.iChartOption, "BarChart");
    var xAxisKey = xkey(iChartOption);
    var xAxisData = xdata(iChartOption.data, xAxisKey);
    var legendData = ldata(iChartOption.data, xAxisKey);
    var seriesData = ydata(iChartOption.data, legendData);
    this.baseOption.legend.data = iChartOption.legend.data || legendData;
    this.baseOption.xAxis.forEach(function(item) {
      item.data = xAxisData;
    });
    this.baseOption.series = setSeries$7(seriesData, legendData, iChartOption);
    setStack(this.baseOption, iChartOption, legendData, seriesData);
    setDoubleSides(this.baseOption, iChartOption);
    setWaterFall(this.baseOption, iChartOption);
    setRange(this.baseOption, iChartOption);
    setMarkLine$2(this.baseOption, iChartOption);
    setDirection$2(this.baseOption, iChartOption.direction);
    setLimitFormatter(this.baseOption, iChartOption, seriesData);
    if (iChartOption.event) {
      event(this.chartInstance, iChartOption.event);
    }
    if (iChartOption.silent) {
      this.baseOption.tooltip = {};
    }
    mergeSeries(iChartOption, this.baseOption);
    mergeVisualMap(iChartOption, this.baseOption);
  };
  _proto7.updateOptionAgain = function updateOptionAgain(YAxiMax, YAxiMin) {
    var baseOption2 = this.baseOption;
    var iChartOption = this.iChartOption;
    var lineDataName = iChartOption.lineDataName;
    if (lineDataName && lineDataName.length > 0) {
      var lineChartBaseOpt = new LineChart$1(iChartOption, {}, this.chartInstance);
      var lineBaseOption = lineChartBaseOpt.getOption();
      var lineSeries = lineBaseOption.series;
      var barSeries = baseOption2.series;
      lineDataName.forEach(function(lineName) {
        var bar = null;
        var line = null;
        for (var i = 0; i < lineSeries.length; i++) {
          if (lineSeries[i].name === lineName) {
            line = lineSeries[i];
            break;
          }
        }
        for (var _i2 = 0; _i2 < barSeries.length; _i2++) {
          if (barSeries[_i2].name === lineName) {
            bar = barSeries[_i2];
            break;
          }
        }
        for (var key in line) {
          bar[key] = line[key];
        }
      });
    }
  };
  _proto7.getOption = function getOption() {
    return this.baseOption;
  };
  _proto7.setOption = function setOption2() {
  };
  return BarChart2;
}();
var BarChart$1 = BarChart;
function handleResObj(item, colors, index) {
  var resObj = cloneDeep(item);
  resObj.color = {
    rgba: codeToRGB(getColor(colors, index), 1),
    from: 1,
    to: 0.2
  };
  return resObj;
}
function handleTempLegend(tempLegend, legendOffset, index) {
  if (tempLegend.orient === "horizontal") {
    var offset = legendOffset || 30;
    var _bottom2 = parseFloat(tempLegend.bottom) - index * parseFloat(offset);
    if (tempLegend.bottom.toString().includes("%")) {
      tempLegend.bottom = _bottom2 + "%";
    } else {
      tempLegend.bottom = _bottom2;
    }
  } else {
    var _offset = legendOffset || 120;
    var _left = parseFloat(tempLegend.left) + index * parseFloat(_offset);
    if (tempLegend.left.toString().includes("%")) {
      tempLegend.left = _left + "%";
    } else {
      tempLegend.left = _left;
    }
  }
}
function handleTempSeriesObj(item) {
  var tempSeriesObj = cloneDeep(item);
  tempSeriesObj.itemStyle = {
    color: item.color.rgba
  };
  return tempSeriesObj;
}
function installInnerData(data3, innerData, innerIndex) {
  data3.children && data3.children.forEach(function(citem, cindex) {
    if (!innerData[innerIndex]) {
      innerData[innerIndex] = [];
    }
    var colorFrom = data3.color.from - (data3.color.from - data3.color.to) / (data3.children.length + 1) * (cindex + 1);
    var colorTo = data3.color.from - (data3.color.from - data3.color.to) / (data3.children.length + 1) * (cindex + 2);
    citem.color = {
      rgba: changeRgbaOpacity(data3.color.rgba, colorFrom),
      from: colorFrom,
      to: colorTo
    };
    innerData[innerIndex].push(citem);
    if (citem.children) {
      installInnerData(citem, innerData, innerIndex + 1);
    }
  });
}
function handleMulti(type, baseOption2, legend2, data3) {
  if (type === "multi-circle") {
    var colors = baseOption2.color;
    var outer = data3.map(function(item, index) {
      var resObj = handleResObj(item, colors, index);
      return resObj;
    });
    var inner = [];
    var innerDiff = 6;
    var innerIndex = 0;
    outer.forEach(function(data22) {
      installInnerData(data22, inner, innerIndex);
    });
    inner.forEach(function(innerData, innerIndex2) {
      var tempSeries = cloneDeep(baseOption2.series[0]);
      tempSeries.data = innerData.map(function(item) {
        var tempSeriesObj = handleTempSeriesObj(item);
        return tempSeriesObj;
      });
      tempSeries.radius = tempSeries.radius.map(function(item) {
        return parseFloat(item) + innerDiff * (innerIndex2 + 1) + "%";
      });
      baseOption2.series.push(tempSeries);
    });
    baseOption2.series.forEach(function(i) {
      i.label = {
        show: false
      };
      i.labelLine = {
        show: false
      };
    });
    var dataArray = [outer].concat(inner);
    var originLegend = baseOption2.legend;
    var legendOffset = legend2.offset;
    baseOption2.legend = [];
    dataArray.forEach(function(array, index) {
      var tempLegend = cloneDeep(originLegend);
      var tempLegendData = array.map(function(item) {
        return item.name;
      });
      tempLegend.data = tempLegendData;
      handleTempLegend(tempLegend, legendOffset, index);
      baseOption2.legend.push(tempLegend);
    });
  }
}
function getChartToken$c() {
  var _Theme$1$config$PieCh = Theme$1.config.PieChart, _Theme$1$config$PieCh2 = _Theme$1$config$PieCh.itemStyle, borderWidth = _Theme$1$config$PieCh2.borderWidth, borderColor = _Theme$1$config$PieCh2.borderColor, borderWidthNone = _Theme$1$config$PieCh2.borderWidthNone, borderRadius2 = _Theme$1$config$PieCh2.borderRadius, _Theme$1$config$PieCh3 = _Theme$1$config$PieCh.label, distance = _Theme$1$config$PieCh3.distance, colorLabel = _Theme$1$config$PieCh3.color, fontSize = _Theme$1$config$PieCh3.fontSize, colorLabelLine = _Theme$1$config$PieCh.lineStyle.color, emptyColor = _Theme$1$config$PieCh.emptyCircleStyle.color;
  return {
    borderWidth,
    borderColor,
    borderWidthNone,
    distance,
    labelColor: colorLabel,
    labelLineColor: colorLabelLine,
    emptyColor,
    fontSize,
    borderRadius: borderRadius2
  };
}
var chartToken$s = proxy(getChartToken$c);
var chartToken$t = chartToken$s;
function handleLabel$1(hasLabel, seriesUnit) {
  if (hasLabel) {
    seriesUnit.label = merge({
      color: chartToken$t.labelColor,
      fontSize: chartToken$t.fontSize
    }, seriesUnit.label);
  } else {
    seriesUnit.label = {
      show: false
    };
  }
}
function handleLabelLine(hasLabelLine, seriesUnit, label2) {
  var _label$distance;
  var lineColor = label2 == null ? void 0 : label2.lineColor;
  var lineLength = (_label$distance = label2 == null ? void 0 : label2.distance) != null ? _label$distance : chartToken$t.distance;
  if (hasLabelLine) {
    seriesUnit.labelLine = merge({
      show: true,
      lineStyle: {
        color: lineColor || chartToken$t.labelLineColor
      },
      smooth: 0.3,
      length: lineLength,
      length2: lineLength
    }, seriesUnit.labelLine);
  } else {
    seriesUnit.labelLine = {
      show: false,
      length: lineLength,
      length2: lineLength
    };
  }
}
function hasLabelFormatterFun(labelFormatterType, seriesUnit, sum) {
  switch (labelFormatterType) {
    case "percent":
      seriesUnit.label.formatter = function(params) {
        if (params.value === 0) {
          return "0(0 %)";
        } else {
          return params.value + "(" + Math.round(params.value * 100 / sum * 100) / 100 + " %)";
        }
      };
      break;
    case "value":
      seriesUnit.label.formatter = function(params) {
        return "" + params.value;
      };
      break;
  }
}
function handleLabelFormatter(hasLabel, hasLabelFormatter, seriesUnit, labelFormatterType, sum) {
  if (hasLabel && hasLabelFormatter) {
    seriesUnit.label.formatter = hasLabelFormatter;
  } else {
    hasLabelFormatterFun(labelFormatterType, seriesUnit, sum);
  }
}
function setLabel$3(seriesUnit, label2, data3) {
  var hasLabel = !(label2 && label2.show === false);
  var hasLabelLine = !(label2 && label2.line === false);
  var hasLabelFormatter = label2 && label2.labelHtml;
  var labelFormatterType = label2 && label2.type || "";
  var sum = data3.reduce(function(x, y) {
    return {
      value: x.value + y.value
    };
  }, {
    value: 0
  });
  sum = sum.value;
  handleLabel$1(hasLabel, seriesUnit);
  handleLabelLine(hasLabelLine, seriesUnit, label2);
  handleLabelFormatter(hasLabel, hasLabelFormatter, seriesUnit, labelFormatterType, sum);
  merge(seriesUnit.label, label2);
}
var seriesInit$7 = function seriesInit$72() {
  return {
    type: "pie",
    roundCap: true,
    radius: ["0%", "50%"],
    center: ["50%", "50%"],
    avoidLabelOverlap: true,
    itemStyle: {
      borderWidth: chartToken$t.borderWidth,
      borderColor: chartToken$t.borderColor,
      borderRadius: chartToken$t.borderRadius
    },
    selectedMode: false,
    roseType: false,
    label: {},
    labelLine: {},
    data: []
  };
};
function setPieRadius(pieType, radius) {
  if (radius) {
    return radius;
  } else {
    var radius2 = [];
    switch (pieType) {
      case "pie":
        radius2 = ["0%", "50%"];
        break;
      case "circle":
        radius2 = ["44%", "50%"];
        break;
      case "multi-circle":
        radius2 = ["44%", "50%"];
        break;
      default:
        radius2 = ["0%", "50%"];
        break;
    }
    return radius2;
  }
}
function handleEmptyData$1(data3, series, center, radius) {
  var total = data3.reduce(function(pre, cur) {
    pre = pre + cur.value;
    return pre;
  }, 0);
  if (total === 0) {
    series.forEach(function(item) {
      item.stillShowZeroSum = false;
      item.itemStyle.borderWidth = chartToken$t.borderWidthNone;
    });
    series.push({
      type: "pie",
      radius,
      center,
      label: {
        show: false
      },
      emptyCircleStyle: {
        color: chartToken$t.emptyColor
      },
      silent: true,
      animation: false
    });
  }
}
function minAngle(radius, chartInstance) {
  var decimalRadiusArr = [];
  var decimalRadius = null;
  var newRadius = null;
  if (isNumber(radius)) {
    newRadius = radius;
  } else if (isString(radius)) {
    if (radius.endsWith("%")) {
      decimalRadius = percentToDecimal$1(radius);
      newRadius = Math.min(chartInstance.getWidth(), chartInstance.getHeight()) * decimalRadius / 2;
    } else {
      newRadius = parseFloat(radius);
    }
  } else if (isArray(radius)) {
    for (var i = 0; i < radius.length; i++) {
      if (isNumber(radius[i])) {
        decimalRadiusArr.push(radius[i] / Math.min(chartInstance.getWidth(), chartInstance.getHeight()));
      } else if (isString(radius[i])) {
        if (radius[i].endsWith("%")) {
          decimalRadiusArr.push(percentToDecimal$1(radius[i]));
        } else {
          decimalRadiusArr.push(parseFloat(radius[i]));
        }
      }
    }
    decimalRadius = decimalRadiusArr[0] === 0 ? decimalRadiusArr[1] : decimalRadiusArr[0];
    newRadius = Math.min(chartInstance.getWidth(), chartInstance.getHeight()) * decimalRadius / 2;
  }
  var cosA = (Math.pow(newRadius, 2) + Math.pow(newRadius, 2) - Math.pow(3, 2)) / (2 * newRadius * newRadius);
  var angleAInRadians = Math.acos(cosA);
  var minAngle2 = angleAInRadians * (180 / Math.PI);
  return minAngle2;
}
function mergeDefaultSeries(seriesUnit) {
  for (var key in seriesInit$7()) {
    if (Object.hasOwnProperty.call(seriesInit$7(), key)) {
      if (key === "itemStyle") {
        var series = cloneDeep(seriesInit$7());
        seriesUnit[key] = merge(series.itemStyle, seriesUnit.itemStyle);
      }
      if (seriesUnit[key] === void 0) {
        seriesUnit[key] = seriesInit$7()[key];
      }
    }
  }
}
var config = ["label", "labelLine", "itemStyle", "radius", "center", "silent", "emphasis", "stillShowZeroSum", "selectedMode", "roseType", "minAngle"];
function handleSeries$5(pieType, iChartOption, chartInstance, position2) {
  var _position, _position2;
  var data3 = iChartOption.data, stillShowZeroSum = iChartOption.stillShowZeroSum;
  position2 = position2 || {};
  iChartOption.center = (_position = position2) == null ? void 0 : _position.center;
  iChartOption.radius = (_position2 = position2) == null ? void 0 : _position2.radius;
  var series = [];
  var selfSeries = iChartOption.series;
  if (selfSeries === void 0) {
    selfSeries = [{}];
  }
  selfSeries.forEach(function(seriesItem) {
    var seriesUnit = seriesItem;
    var temp = cloneDeep(iChartOption);
    config.forEach(function(name2) {
      var existValue = merge(temp[name2], seriesUnit[name2]);
      if (existValue !== void 0) {
        seriesUnit[name2] = existValue;
      }
    });
    seriesUnit.data = seriesUnit.data || iChartOption.data;
    seriesUnit.radius = setPieRadius(pieType, seriesUnit.radius);
    seriesUnit.minAngle = seriesUnit.minAngle !== void 0 ? seriesUnit.minAngle : minAngle(seriesUnit.radius, chartInstance);
    setLabel$3(seriesUnit, seriesUnit.label, seriesUnit.data);
    mergeDefaultSeries(seriesUnit);
  });
  if (stillShowZeroSum === false) {
    handleEmptyData$1(data3, selfSeries, selfSeries[0].center, selfSeries[0].radius);
  }
  series = selfSeries;
  return series;
}
function getBaseTitle() {
  return {
    text: "",
    subtext: "",
    top: "center",
    left: "center",
    itemGap: Theme$1.config.titleItemGap,
    textStyle: {
      color: Theme$1.config.titleTextColor,
      fontSize: Theme$1.config.titleTextFontSize,
      lineHeight: 28,
      fontWeight: "normal"
    },
    subtextStyle: {
      color: Theme$1.config.titleSubTextColor,
      fontSize: Theme$1.config.titleSubtextFontSize,
      lineHeight: 24,
      fontWeight: "normal"
    }
  };
}
function base$3() {
  return getBaseTitle();
}
function textStyle(titleOption, pieMain) {
  if (pieMain != null && pieMain.textSize) {
    titleOption.textStyle.fontSize = pieMain.textSize;
    titleOption.textStyle.color = pieMain.color || titleOption.textStyle.color;
    titleOption.textStyle.fontWeight = pieMain.fontWeight || "normal";
    titleOption.textStyle.lineHeight = Number(pieMain.textSize);
  }
  Object.assign(titleOption.textStyle, pieMain);
}
function subtextStyle(titleOption, pieSub) {
  if (pieSub != null && pieSub.textSize) {
    titleOption.subtextStyle.fontSize = pieSub.textSize;
    titleOption.subtextStyle.color = pieSub.color || titleOption.subtextStyle.color;
    titleOption.subtextStyle.fontWeight = pieSub.fontWeight || "normal";
    titleOption.subtextStyle.lineHeight = pieSub.textSize * 1.2;
  }
}
function title(iChartOption) {
  var text = iChartOption.text, title2 = iChartOption.title;
  if (!title2 && !text)
    return {};
  var titleOption = base$3();
  if (title2) {
    Object.assign(titleOption, title2);
    return titleOption;
  }
  var pieMain = text.main, pieSub = text.sub, textPosition = text.position, itemGap = text.itemGap;
  titleOption.textAlign = "center";
  titleOption.left = "49.5%";
  titleOption.text = (pieMain == null ? void 0 : pieMain.text) || (text == null ? void 0 : text.text) || "";
  titleOption.subtext = (pieSub == null ? void 0 : pieSub.text) || (text == null ? void 0 : text.subtext) || "";
  if (itemGap) {
    titleOption.itemGap = itemGap;
  }
  textStyle(titleOption, pieMain);
  subtextStyle(titleOption, pieSub);
  Object.assign(titleOption, text);
  if (textPosition) {
    Object.assign(titleOption, textPosition);
  }
  return titleOption;
}
function getBaseAngleAxis() {
  return {
    splitNumber: 6,
    startAngle: 90,
    axisLine: {
      show: false,
      lineStyle: {
        color: Theme$1.config.angleAxisLineColor,
        width: Theme$1.config.angleAxisLineWidth,
        type: Theme$1.config.angleAxisLineType
      }
    },
    splitLine: {
      show: false,
      lineStyle: {
        color: Theme$1.config.angleAxisSplitLineColor,
        width: Theme$1.config.angleAxisSplitLineWidth,
        type: Theme$1.config.angleAxisSplitLineType
      }
    },
    axisTick: {
      show: false,
      length: 5,
      lineStyle: {
        color: Theme$1.config.angleAxisTickLineColor,
        width: Theme$1.config.angleAxisTickLineWidth,
        type: Theme$1.config.angleAxisTickLineType
      }
    },
    axisLabel: {
      show: true,
      fontSize: Theme$1.config.angleAxisLabelFontSize,
      color: Theme$1.config.angleAxisLabelColor,
      formatter: void 0
    }
  };
}
function base$2(chartName2) {
  var angleAxisOption = getBaseAngleAxis();
  return angleAxisOption;
}
function angleAxis(iChartOption, chartName2) {
  var angleAxisOpt;
  switch (chartName2) {
    case "JadeJueChart":
      angleAxisOpt = base$2();
      merge(angleAxisOpt, iChartOption.angleAxis);
      break;
    case "PolarBarChart":
      angleAxisOpt = base$2();
      angleAxisOpt.type = "category";
      angleAxisOpt.axisLine.show = true;
      angleAxisOpt.axisLabel.show = false;
      angleAxisOpt.splitLine.show = true;
      merge(angleAxisOpt, iChartOption.angleAxis);
      break;
    case "CircleProcessChart":
      angleAxisOpt = {
        max: 100,
        show: false
      };
      break;
  }
  return angleAxisOpt;
}
function getBaseRadiusAxis() {
  return {
    axisLine: {
      show: false,
      lineStyle: {
        color: Theme$1.config.radiusAxisLineColor,
        width: Theme$1.config.radiusAxisLineWidth,
        type: Theme$1.config.radiusAxisLineType
      }
    },
    axisTick: {
      length: 5,
      show: false,
      lineStyle: {
        color: Theme$1.config.radiusAxisTickLineColor,
        width: Theme$1.config.radiusAxisTickLineWidth,
        type: Theme$1.config.radiusAxisTickLineType
      }
    },
    axisLabel: {
      show: true,
      color: Theme$1.config.radiusAxisLabelColor,
      fontSize: Theme$1.config.radiusAxisLabelFontSize,
      align: "right",
      margin: Theme$1.config.radiusAxisLabelGap * 5,
      interval: 0
    },
    splitLine: {
      lineStyle: {
        type: Theme$1.config.radiusAxisSplitLineType,
        color: Theme$1.config.radiusAxisSplitLineColor,
        width: Theme$1.config.radiusAxisSplitLineWidth
      }
    }
  };
}
function base$1(chartName2) {
  var radiusAxisOption = getBaseRadiusAxis();
  return radiusAxisOption;
}
function radiusAxis(iChartOption, chartName2) {
  var radiusAxisOpt;
  switch (chartName2) {
    case "JadeJueChart":
      radiusAxisOpt = base$1();
      break;
    case "PolarBarChart":
      radiusAxisOpt = base$1();
      radiusAxisOpt.axisLabel.margin = Theme$1.config.radiusAxisLabelGap;
      merge(radiusAxisOpt, iChartOption.radiusAxis);
      break;
    case "CircleProcessChart":
      radiusAxisOpt = {
        type: "category",
        show: false
      };
      break;
  }
  return radiusAxisOpt;
}
var basePolar = {
  center: ["50%", "50%"],
  radius: ["8%", "70%"]
};
function base(position2, chartName2) {
  var PolarOption = cloneDeep(basePolar);
  PolarOption.center = position2 && position2.center || basePolar.center;
  PolarOption.radius = position2 && position2.radius || basePolar.radius;
  return PolarOption;
}
function polar(iChartOption, chartName2) {
  var position2 = iChartOption.position;
  var polarOption = base(position2);
  switch (chartName2) {
    case "PolarBarChart":
      break;
    case "JadeJueChart":
      polarOption.radius = ["20%", "60%"];
      break;
    case "CircleProcessChart":
      polarOption.radius = ["44%", "50%"];
      break;
    default:
      polarOption = void 0;
      break;
  }
  return polarOption;
}
function PolarCoordSys(baseOpt, iChartOpt, chartName2) {
  baseOpt.color = iChartOpt.color;
  baseOpt.angleAxis = angleAxis(iChartOpt, chartName2);
  baseOpt.radiusAxis = radiusAxis(iChartOpt, chartName2);
  baseOpt.polar = polar(iChartOpt, chartName2);
  baseOpt.tooltip = tooltip(iChartOpt, chartName2);
  baseOpt.title = title(iChartOpt);
  baseOpt.legend = legend(iChartOpt);
}
var PieChart = /* @__PURE__ */ function() {
  function PieChart2(iChartOption, chartInstance) {
    this.baseOption = {};
    this.iChartOption = {};
    this.iChartOption = init(iChartOption);
    this.updateOption(chartInstance);
  }
  var _proto8 = PieChart2.prototype;
  _proto8.updateOption = function updateOption(chartInstance) {
    var iChartOption = this.iChartOption;
    var type = iChartOption.type || "circle";
    PolarCoordSys(this.baseOption, this.iChartOption, "PieChart");
    var position2 = iChartOption.position || iChartOption.chartPosition;
    this.baseOption.series = handleSeries$5(type, iChartOption, chartInstance, position2);
    handleMulti(type, this.baseOption, iChartOption.legend, iChartOption.data);
    if (iChartOption.event) {
      event(chartInstance, iChartOption.event);
    }
    if (iChartOption.silent) {
      this.baseOption.tooltip = {};
    }
  };
  _proto8.getOption = function getOption() {
    return this.baseOption;
  };
  _proto8.setOption = function setOption2() {
  };
  return PieChart2;
}();
var PieChart$1 = PieChart;
function insertCenterDom(container, option) {
  if (!option.centerDom)
    return;
  var centerDom = option.centerDom;
  var containerWidth = Math.min(container.clientWidth, container.clientHeight);
  var position2 = getComputedStyle(container).position;
  if (position2 === "static") {
    container.style.position = "relative";
  }
  var radius = getCenterDomRadius(option);
  var centerDomContainer = createCenterDomContainer(containerWidth, radius);
  var customDom = centerDom(centerDomContainer);
  isString(customDom) && appendHTML(centerDomContainer, customDom);
  isDOM(customDom) && appendDom(centerDomContainer, customDom);
  appendDom(container, centerDomContainer);
}
function resizeCenterDom(container, option) {
  var centerDomContainer = container == null ? void 0 : container.getElementsByClassName("hui_center_dom_container");
  var containerWidth = Math.min(container == null ? void 0 : container.clientWidth, container == null ? void 0 : container.clientHeight);
  var radius = getCenterDomRadius(option);
  if (centerDomContainer) {
    Array.prototype.slice.call(centerDomContainer).forEach(function(element) {
      setSize$1(element, radius, containerWidth);
    });
  }
}
var getCenterDomRadius = function getCenterDomRadius2(option) {
  var _option$position;
  var radius = ((_option$position = option.position) == null ? void 0 : _option$position.radius) || "50%";
  if (isArray(radius)) {
    radius = percentToDecimal(radius[0]);
  } else {
    radius = percentToDecimal(radius) * 0.5;
  }
  return radius;
};
var createCenterDomContainer = function createCenterDomContainer2(containerWidth, radius) {
  var centerDomContainer = document.createElement("div");
  centerDomContainer.classList.add("hui_center_dom_container");
  centerDomContainer.style.cssText = "\n        top: 50%;\n        left: 50%;\n        display: flex;\n        color: #191919;\n        position: absolute;\n        border-radius: 50%;\n        align-items: center;\n        flex-direction: column;\n        justify-content: center;\n        transform: translate(-50%, -50%);\n        background: rgb(255, 255, 255);\n        box-shadow: inset 0 0 4px rgba(0, 0, 0, 0.1)";
  setSize$1(centerDomContainer, radius, containerWidth);
  return centerDomContainer;
};
var setSize$1 = function setSize$12(dom, radius, width) {
  dom.style.width = width * radius + "px";
  dom.style.height = width * radius + "px";
};
var percentToDecimal = function percentToDecimal2(percent) {
  return parseFloat(percent) / 100;
};
var chartToken$q = Theme$1.getTokenByName("RadarChart");
var chartToken$r = chartToken$q;
function getSeriesUnit() {
  return {
    type: "radar",
    name: "data",
    // 使用的雷达坐标系
    radarIndex: 0,
    // 拐点的标记大小
    symbolSize: chartToken$r.symbolSize,
    // 拐点样式
    itemStyle: {
      borderWidth: chartToken$r.symbolBorderWidthSM,
      borderColor: chartToken$r.borderColor
    },
    // 填充面积
    areaStyle: {
      opacity: 0.2
    },
    lineStyle: {
      width: chartToken$r.lineWidth
    },
    // 高亮的样式
    emphasis: {
      focus: "none",
      areaStyle: {
        opacity: 0.4
      }
    },
    data: []
  };
}
function setSeries$6(baseOpt, iChartOpt, radarKeys, data3) {
  var isWaveRadar = iChartOpt.isWaveRadar, theme = iChartOpt.theme;
  var dataNames = Object.keys(data3);
  var seriesUnit = getSeriesUnit();
  if (theme.toLowerCase().includes("cloud-dark") || theme.toLowerCase().includes("cloud-light")) {
    seriesUnit.areaStyle.opacity = 0.1;
    seriesUnit.emphasis.areaStyle.opacity = 0.2;
    if (isWaveRadar) {
      seriesUnit.symbolSize = chartToken$r.symbolSizeLG;
      seriesUnit.itemStyle.borderWidth = chartToken$r.symbolBorderWidth;
      seriesUnit.areaStyle.opacity = 0.2;
      seriesUnit.emphasis.areaStyle.opacity = 0.4;
    }
  }
  dataNames.forEach(function(name2) {
    var radarData = {
      name: name2,
      value: radarKeys.map(function(key) {
        return data3[name2][key];
      })
    };
    seriesUnit.data.push(radarData);
  });
  baseOpt.series.push(seriesUnit);
}
function getRedPointerRadar() {
  return {
    // 雷达位置，保持和初始坐标系一致，
    center: ["50%", "50%"],
    // 雷达半径，保持和初始坐标系一致，
    radius: "50%",
    // 控制指示器名称是否显示
    axisName: {
      show: false
    },
    startAngle: void 0,
    // 轴线的角度根据需求自己定义,起始点是水平方向
    // 指示器轴的分割段数，和初始坐标轴一致
    splitNumber: 4,
    shape: "circle",
    // 坐标轴圆环分隔区域填充
    splitArea: {
      show: false
    },
    // 坐标轴射线
    axisLine: {
      show: false
    },
    // 坐标轴圆环分隔线
    splitLine: {
      show: false
    },
    indicator: void 0
  };
}
function handleRedPointerRadar(baseOption2, radarKeys, dataNameIndex, dataName) {
  var max2 = baseOption2.radar[0].indicator.find(function(item) {
    return item.name === dataName;
  }).max;
  var redPointerRadar = getRedPointerRadar();
  redPointerRadar.center = baseOption2.radar[0].center;
  redPointerRadar.radius = baseOption2.radar[0].radius;
  redPointerRadar.startAngle = 90 + 360 / radarKeys.length * dataNameIndex;
  redPointerRadar.indicator = [{
    name: "",
    max: max2
  }];
  return redPointerRadar;
}
function handleRedPointerSeries(index, dataValue, seriesName) {
  var colorError = Theme$1.config.colorState.colorError;
  return {
    name: "threshold",
    type: "radar",
    // 拐点大小
    symbolSize: chartToken$r.symbolSizeLG,
    silent: true,
    z: 99,
    // 使用的雷达坐标系的索引
    radarIndex: 2 + index,
    // 拐点的样式
    itemStyle: {
      color: colorError,
      borderColor: chartToken$r.borderColor,
      borderWidth: chartToken$r.symbolBorderWidth,
      shadowBlur: 15,
      shadowColor: colorError
    },
    // 隐藏标示线
    lineStyle: {
      width: chartToken$r.lineWidthNone,
      labelLine: {
        show: false
      }
    },
    data: [{
      value: dataValue,
      name: seriesName
      // 数据的名称，为了图例的点击消失生效，和系列的名字保持一致
    }]
  };
}
function getExceededMarkLineValue(data3, markLine, isThreshold) {
  var thresholdPoint = [];
  var names = Object.keys(data3);
  for (var i = 0; i < names.length; i++) {
    var _name7 = names[i];
    var keys = Object.keys(data3[_name7]);
    for (var j = 0; j < keys.length; j++) {
      var key = keys[j];
      var markLineVal = isThreshold ? markLine.threshold[key] : markLine;
      if (markLineVal && data3[_name7][key] >= markLineVal) {
        thresholdPoint.push({
          seriesName: _name7,
          dataName: key,
          dataValue: data3[_name7][key]
        });
      }
    }
  }
  return thresholdPoint;
}
function setMarkLineSeries(baseOpt, iChartOpt, radarKeys) {
  var markLine = iChartOpt.markLine;
  if (markLine) {
    var _data2 = iChartOpt.data;
    var isThreshold = !!(isObject(markLine) && markLine != null && markLine.threshold);
    var exceeded = getExceededMarkLineValue(_data2, markLine, isThreshold);
    exceeded.forEach(function(item, index) {
      var seriesName = item.seriesName;
      var dataName = item.dataName;
      var dataNameIndex = radarKeys.indexOf(dataName);
      var dataValue = item.dataValue;
      var redPointerRadar = handleRedPointerRadar(baseOpt, radarKeys, dataNameIndex, dataName);
      var redPointerSeries = handleRedPointerSeries(index, dataValue, seriesName);
      baseOpt.radar.push(redPointerRadar);
      baseOpt.series.push(redPointerSeries);
    });
  }
}
function getRadar() {
  return {
    // 雷达坐标系位置
    center: ["50%", "50%"],
    // 雷达坐标系半径
    radius: "50%",
    // 指示器名称与轴的距离
    axisNameGap: 15,
    // 指示器轴的分割段数
    splitNumber: 4,
    shape: "circle",
    // 坐标轴的标签是否响应和触发鼠标事件
    triggerEvent: false,
    // 坐标轴射线
    axisLine: {
      lineStyle: {
        color: Theme$1.config.radiusAxisLineColor,
        width: Theme$1.config.radarAxisLineWidth,
        type: Theme$1.config.radarAxisLineType
      }
    },
    // 坐标轴射线的刻度,只显示一条射线的刻度,其他射线的刻度需要在指示器数据indicator中每项单独配置axisLabel: { show: false }
    axisLabel: {
      show: false,
      margin: -20
    },
    // 坐标轴圆环分隔区域填充
    splitArea: {
      show: false
    },
    // 坐标轴圆环分隔线
    splitLine: {
      lineStyle: {
        color: Theme$1.config.radarSplitLineColor,
        width: Theme$1.config.radarSplitLineWidth,
        type: Theme$1.config.radarSplitLineType
      }
    },
    // 坐标轴数据
    indicator: void 0,
    // 指示器名称样式设置
    axisName: {
      show: true,
      rich: {
        a: {
          // 指示器name的样式
          color: Theme$1.config.radarAxisLabelColor,
          align: "center",
          fontSize: Theme$1.config.radarAxisNameFontSize
        },
        b: {
          // 数据value样式
          color: Theme$1.config.radarAxisLabelColor,
          fontSize: Theme$1.config.radarAxisNameFontSize,
          align: "center",
          padding: [0, 0, 4, 0]
        }
      },
      formatter: void 0
    }
  };
}
function initRadarSys(baseOpt, iChartOpt) {
  baseOpt.color = iChartOpt.color;
  baseOpt.tooltip = tooltip(iChartOpt, "RadarChart");
  baseOpt.title = title(iChartOpt);
  baseOpt.legend = legend(iChartOpt);
  baseOpt.radar = [];
  baseOpt.series = [];
}
function handleCusMax(iChartOpt) {
  var max2 = 0;
  var radarMax = iChartOpt.radarMax, radar = iChartOpt.radar;
  if (isArray(radarMax)) {
    radarMax.forEach(function(item) {
      if (item.max > max2)
        max2 = item.max;
    });
  }
  if (radar != null && radar.indicator) {
    radar.indicator.forEach(function(el) {
      if (el.max > max2)
        max2 = el.max;
    });
  }
  return max2;
}
function findDataMax(keys, data3) {
  var max2;
  for (var j = 0; j < keys.length; j++) {
    var key = keys[j];
    if (max2 === void 0) {
      max2 = data3[key];
    }
    max2 = Math.max(max2, data3[key]);
  }
  return max2;
}
function getRadarMax(data3, iChartOpt, isCustomMaxVal) {
  var max2;
  var cusDataName;
  var radarMax = iChartOpt.radarMax, radar = iChartOpt.radar;
  if (isCustomMaxVal) {
    if (isArray(radarMax)) {
      cusDataName = radarMax.map(function(item) {
        return item.name;
      });
    }
    if (radar != null && radar.indicator) {
      cusDataName = radar.indicator.map(function(i2) {
        return i2.name;
      });
    }
  }
  var names = Object.keys(data3);
  for (var i = 0; i < names.length; i++) {
    var _name8 = names[i];
    var keys = Object.keys(data3[_name8]);
    if (isCustomMaxVal) {
      var dataKeys = keys.filter(function(name2) {
        if (!cusDataName.includes(name2))
          return name2;
      });
      max2 = findDataMax(dataKeys, data3[_name8]);
      if (max2 === void 0) {
        max2 = handleCusMax(iChartOpt);
      }
    } else {
      max2 = findDataMax(keys, data3[_name8]);
    }
  }
  return max2;
}
function getRadarKeys(data3) {
  var radarKeys = [];
  var seriesNames = Object.keys(data3);
  for (var i = 0; i < seriesNames.length; i++) {
    var seriesName = seriesNames[i];
    var seriesData = data3[seriesName];
    var dataNames = Object.keys(seriesData);
    for (var j = 0; j < dataNames.length; j++) {
      var dataName = dataNames[j];
      if (!radarKeys.includes(dataName)) {
        radarKeys.push(dataName);
      }
    }
  }
  return radarKeys;
}
function getUnit(unit) {
  if (unit || unit === "")
    return unit;
  return "%";
}
function setCenterAndRadius(radar, iChartOpt) {
  var chartPosition = iChartOpt.chartPosition || iChartOpt.position || {};
  if (chartPosition.center)
    radar.center = chartPosition.center;
  if (chartPosition.radius)
    radar.radius = chartPosition.radius;
}
function setIndicator(radar, radarKeys, isCustomMaxVal, iChartOpt) {
  var radarMax = iChartOpt.radarMax, data3 = iChartOpt.data, radarMark = iChartOpt.radarMark;
  var isRadarMaxArr = isArray(radarMax);
  radar.indicator = radarKeys.map(function(name2, index) {
    if (!isRadarMaxArr) {
      return index === 0 ? {
        name: name2,
        max: radarMax
      } : {
        name: name2,
        max: radarMax,
        axisLabel: {
          show: false
        }
      };
    } else {
      var inerMax = getRadarMax(data3, iChartOpt, isCustomMaxVal);
      var isName = radarMax.find(function(item) {
        return item.name === name2;
      });
      var cusIndicator = isName || {};
      return _extends({
        name: name2,
        max: inerMax,
        axisLabel: {
          show: !!radarMark
        }
      }, cusIndicator);
    }
  });
}
function mergeRadar(radar, iChartOpt) {
  var _iChartOpt$radar;
  if (iChartOpt.radar)
    merge(radar, iChartOpt.radar);
  if ((_iChartOpt$radar = iChartOpt.radar) != null && _iChartOpt$radar.indicator) {
    var mixinIndicator = radar.indicator.map(function(i) {
      var coveredIndicator = iChartOpt.radar.indicator.find(function(indicate) {
        return indicate.name === i.name;
      });
      return coveredIndicator || i;
    });
    radar.indicator = mixinIndicator;
  }
}
function setAxisLabel(radar, iChartOpt) {
  var radarMark = iChartOpt.radarMark;
  radar.axisLabel.shoW = radarMark === void 0 ? true : !!radarMark;
}
function setAxisNameFormatter(radar, iChartOpt) {
  var data3 = iChartOpt.data, unit = iChartOpt.unit;
  var dataLength = Object.keys(data3).length;
  var actualUnit = getUnit(unit);
  radar.axisName.formatter = function(indicatorName) {
    if (dataLength === 1) {
      var d = data3[Object.keys(data3)[0]];
      var v = d[indicatorName];
      return "{b|" + v + "}{b|" + actualUnit + "}\n{a|" + indicatorName + "}";
    } else if (dataLength > 1) {
      return "{a|" + indicatorName + "}";
    }
  };
}
function setRadar(baseOpt, iChartOpt, radarKeys, isCustomMaxVal) {
  var radar = getRadar();
  setAxisLabel(radar, iChartOpt);
  setAxisNameFormatter(radar, iChartOpt);
  setCenterAndRadius(radar, iChartOpt);
  setIndicator(radar, radarKeys, isCustomMaxVal, iChartOpt);
  mergeRadar(radar, iChartOpt);
  baseOpt.radar.push(radar);
}
function handletipHtml(tooltip2, tipHtml, radarKeys) {
  tooltip2.formatter = function(params, ticket, callback) {
    return tipHtml(params, radarKeys, ticket, callback);
  };
}
function handleFormatter(tooltip2, iChartOpt, radarKeys) {
  var markLine = iChartOpt.markLine;
  var alarmColor = Theme$1.config.colorState.colorError;
  var isThreshold = !!(isObject(markLine) && markLine != null && markLine.threshold);
  tooltip2.formatter = function(params) {
    var data3 = params.data;
    var dataName = data3.name;
    var htmlString = '<div style="margin-bottom:4px;">' + defendXSS$1(dataName) + "</div>";
    data3.value.forEach(function(item, index) {
      var color3;
      if (markLine) {
        var markVal = isThreshold ? markLine.threshold[radarKeys[index]] : markLine;
        color3 = item >= markVal ? alarmColor : params.color;
      } else {
        color3 = params.color;
      }
      htmlString += '<div style="margin-bottom:4px;">\n      <span style="display:inline-block;width:8px;\n      height:8px;margin-right:8px;border-radius:5px;\n      background-color:' + defendXSS$1(color3) + ';"></span>\n      <span style="display:inline-block;margin-right:8px;\n      min-width:60px;font-size:12px">' + defendXSS$1(radarKeys[index]) + '</span>\n      <span style="font-size:14px">' + defendXSS$1(item || "-") + "</span>\n      </div>";
    });
    return htmlString;
  };
}
function setTooltip$5(baseOpt, iChartOpt, radarKeys) {
  var tipHtml = iChartOpt.tipHtml, tooltip2 = iChartOpt.tooltip;
  tipHtml ? handletipHtml(baseOpt.tooltip, tipHtml, radarKeys) : handleFormatter(baseOpt.tooltip, iChartOpt, radarKeys);
  if (tooltip2 != null && tooltip2.formatter) {
    baseOpt.tooltip.formatter = function(params, ticket, callback) {
      return tooltip2.formatter(params, radarKeys, ticket, callback);
    };
  }
}
function getMarkRadarOption() {
  return {
    center: void 0,
    // 阈值线的radius应该是一个百分比，或者是实际的像素值
    radius: void 0,
    splitNumber: 1,
    shape: "circle",
    axisName: {
      show: false
    },
    axisLine: {
      show: false
    },
    axisLabel: {
      show: false
    },
    splitArea: {
      show: false
    },
    splitLine: {
      lineStyle: {
        width: Theme$1.config.radarSplitLineWidth,
        color: void 0,
        type: "dashed"
      }
    },
    indicator: void 0
  };
}
function setMarkCenterAndRadius(radar, baseOpt) {
  radar.center = baseOpt.radar[0].center;
  radar.radius = baseOpt.radar[0].radius;
}
function setCustomMarkLine(markRadar, baseOpt, iChartOpt, radarKeys) {
  var threshold = iChartOpt.markLine.threshold;
  markRadar.indicator = cloneDeep(baseOpt.radar[0].indicator);
  var thresholdData = radarKeys.map(function(item) {
    var data3 = threshold[item] || 0;
    return data3;
  });
  var thresholdSeries = {
    type: "radar",
    symbol: "none",
    // 拐点大小
    symbolSize: chartToken$r.symbolSizeLG,
    silent: true,
    // 使用的雷达坐标系的索引
    radarIndex: 1,
    areaStyle: {
      color: chartToken$r.areaStyleColor
    },
    lineStyle: {
      color: Theme$1.config.colorState.colorError,
      type: "dashed"
    },
    data: []
  };
  thresholdSeries.data = [{
    name: "",
    value: thresholdData
  }];
  baseOpt.series.push(thresholdSeries);
}
function setCommonMarkLine(markRadar, baseOpt, iChartOpt, radarKeys) {
  var radius = baseOpt.radar[0].radius;
  var radiusIsArray = isArray(radius);
  var radarMax = iChartOpt.radarMax, markLine = iChartOpt.markLine;
  if (isObject(radarMax)) {
    tips.error("If markLine is of the number type, radarMax must be of the number type. If radarMax is of the object type, set markLine.threshold");
    return;
  }
  var markLineValue = Number.parseFloat(markLine);
  var marklineRadius;
  if (radiusIsArray) {
    var disRadius = Number.parseFloat(radius[1]) - Number.parseFloat(radius[0]);
    marklineRadius = disRadius * (markLineValue / radarMax) + Number.parseFloat(radius[0]) + (radius[0].toString().includes("%") ? "%" : "");
  } else {
    marklineRadius = markLineValue / radarMax * Number.parseFloat(radius) + (radius.toString().includes("%") ? "%" : "");
  }
  markRadar.radius = marklineRadius;
  markRadar.splitLine.lineStyle.color = Theme$1.config.colorState.colorError;
  markRadar.indicator = Array(radarKeys.length).fill({
    name: ""
  });
}
function setMarkLine$1(baseOpt, iChartOpt, radarKeys) {
  var markLine = iChartOpt.markLine;
  if (markLine) {
    var markRadar = getMarkRadarOption();
    setMarkCenterAndRadius(markRadar, baseOpt);
    var isThreshold = !!(isObject(markLine) && markLine != null && markLine.threshold);
    isThreshold ? setCustomMarkLine(markRadar, baseOpt, iChartOpt, radarKeys) : setCommonMarkLine(markRadar, baseOpt, iChartOpt, radarKeys);
    baseOpt.radar.push(markRadar);
  }
}
var RadarChart = /* @__PURE__ */ function() {
  function RadarChart2(iChartOption, chartInstance) {
    this.baseOption = {};
    this.iChartOption = {};
    this.chartInstance = chartInstance;
    this.iChartOption = init(iChartOption);
    this.updateOption(chartInstance);
  }
  var _proto9 = RadarChart2.prototype;
  _proto9.updateOption = function updateOption(chartInstance) {
    var _iChartOption$radar;
    var iChartOption = this.iChartOption;
    var isCustomMaxVal = !!(isArray(iChartOption.radarMax) || iChartOption != null && (_iChartOption$radar = iChartOption.radar) != null && _iChartOption$radar.indicator);
    iChartOption.radarMax = iChartOption.radarMax || getRadarMax(iChartOption.data, iChartOption, isCustomMaxVal);
    initRadarSys(this.baseOption, iChartOption);
    var radarKeys = getRadarKeys(iChartOption.data);
    setRadar(this.baseOption, iChartOption, radarKeys, isCustomMaxVal);
    setSeries$6(this.baseOption, iChartOption, radarKeys, iChartOption.data);
    setMarkLine$1(this.baseOption, iChartOption, radarKeys);
    setTooltip$5(this.baseOption, iChartOption, radarKeys);
    setMarkLineSeries(this.baseOption, iChartOption, radarKeys);
    mergeSeries(iChartOption, this.baseOption);
    event(chartInstance, iChartOption.event);
  };
  _proto9.updateOptionAgain = function updateOptionAgain() {
    var container = this.chartInstance.getDom();
    insertCenterDom(container, this.iChartOption);
  };
  _proto9.resize = function resize2() {
    var container = this.chartInstance.getDom();
    resizeCenterDom(container, this.iChartOption);
  };
  _proto9.getOption = function getOption() {
    return this.baseOption;
  };
  _proto9.setOption = function setOption2() {
  };
  return RadarChart2;
}();
var RadarChart$1 = RadarChart;
BaseOption$6.series = [];
BaseOption$6.tooltip = {
  show: true,
  trigger: "item",
  formatter: "{b}: {c} ({d}%)"
};
BaseOption$6.legend = {};
function getChartToken$b() {
  var _Theme$1$config$Gauge = Theme$1.config.GaugeChart, colorAxisLine = _Theme$1$config$Gauge.axisLine.lineStyle.color, colorAxisSplitLine = _Theme$1$config$Gauge.splitLine.lineStyle.color, colorTextSecondary = _Theme$1$config$Gauge.axisLabel.color, colorTextPrimary = _Theme$1$config$Gauge.detail.rich.color;
  var colorState2 = Theme$1.config.colorState;
  return {
    marklineColor: colorState2.colorError,
    axisLineColor: colorAxisLine,
    splitLineColor: colorAxisSplitLine,
    axisLabelColor: colorTextSecondary,
    detailRichColor: colorTextPrimary
  };
}
var chartToken$o = proxy(getChartToken$b);
var chartToken$p = chartToken$o;
var emptySeriesUnit = {
  type: "gauge",
  startAngle: 0,
  endAngle: 0,
  center: ["50%", "50%"],
  radius: "50%",
  splitNumber: 2,
  axisLine: {
    show: false
  },
  axisLabel: {
    show: false
  },
  splitLine: {
    show: false
  },
  itemStyle: {
    show: false
  },
  axisTick: {
    show: false
  },
  pointer: {
    show: false
  },
  detail: {
    show: false
  },
  title: {
    show: false
  },
  data: []
};
var seriesInit$6 = {
  name: "",
  type: "gauge",
  // 仪表盘轨道底色
  axisLine: {
    roundCap: true,
    lineStyle: {
      width: 10
    }
  },
  // 仪表盘进度条
  progress: {
    show: true,
    roundCap: true,
    width: 10
  },
  // 大刻度数量
  splitNumber: 4,
  // 大刻度线样式
  splitLine: {
    distance: 0,
    length: 10,
    lineStyle: {
      width: 2
    }
  },
  // 大刻度数值
  axisLabel: {
    distance: 16,
    fontSize: 14,
    color: "red"
  },
  // 小刻度线样式
  axisTick: {
    distance: 0,
    length: 10,
    lineStyle: {
      color: "transparent",
      width: 2
    }
  },
  // 指针样式
  pointer: {
    show: false,
    icon: "path://M511.999488 819.413462 72.8374 204.586538 951.1626 204.586538Z",
    length: "10%",
    width: 16,
    offsetCenter: [0, "-108%"]
  },
  title: {
    show: false
  },
  detail: {
    valueAnimation: true
  },
  data: []
};
function handleSplitLine(iChartOption, seriesUnit) {
  if (iChartOption.splitLine) {
    if (iChartOption.splitLine.show !== void 0) {
      seriesUnit.splitLine.show = iChartOption.splitLine.show;
    } else {
      seriesUnit.splitLine.show = true;
    }
  } else {
    seriesUnit.splitLine.show = true;
  }
  if (seriesUnit.splitLine.show) {
    seriesUnit.splitNumber = iChartOption.splitNumber || 4;
  } else {
    seriesUnit.splitNumber = -1;
  }
  if (iChartOption.itemStyle) {
    var _iChartOption$itemSty = iChartOption.itemStyle, _lineStyle = _iChartOption$itemSty.lineStyle, width = _iChartOption$itemSty.width;
    seriesUnit.splitLine.length = _lineStyle && _lineStyle.length || width || 10;
    seriesUnit.splitLine.distance = width ? width * -1 : -3;
  } else {
    seriesUnit.splitLine.length = 10;
    seriesUnit.splitLine.distance = -3;
  }
  if (iChartOption.itemStyle && iChartOption.itemStyle.lineStyle) {
    if (iChartOption.itemStyle.lineStyle.color) {
      seriesUnit.splitLine.lineStyle.color = iChartOption.itemStyle.lineStyle.color;
    } else {
      seriesUnit.splitLine.lineStyle.color = chartToken$p.splitLineColor;
    }
    seriesUnit.splitLine.lineStyle.width = iChartOption.itemStyle.lineStyle.width || 4;
  }
}
function handleTheme$1(iChartOption) {
  var orbitalColor = iChartOption.orbitalColor;
  seriesInit$6.axisLine.lineStyle.color = [[1, orbitalColor || chartToken$p.axisLineColor]];
  seriesInit$6.splitLine.lineStyle.color = chartToken$p.splitLineColor;
  seriesInit$6.axisLabel.color = chartToken$p.axisLabelColor;
}
function handleDetail(seriesUnit, text, data3) {
  seriesUnit.detail.formatter = text.formatter || function(value) {
    return "{value|" + value + "}\n{name|" + data3[0].name + "}";
  };
  seriesUnit.detail.offsetCenter = text.offset || [0, 0];
  seriesUnit.detail.rich = text.formatterStyle || {
    value: {
      fontSize: 60,
      fontWeight: "bolder",
      color: chartToken$p.detailRichColor
    },
    name: {
      fontSize: 14,
      color: chartToken$p.detailRichColor,
      padding: [24, 0, 0, 0]
    }
  };
}
function handleProgress(seriesUnit, iChartOption, data3) {
  var itemStyle2 = iChartOption.itemStyle;
  seriesUnit.progress.width = itemStyle2 ? itemStyle2.width ? itemStyle2.width : 10 : 10;
  if (data3 && data3.length !== 0 && data3[0].value === 0) {
    seriesUnit.progress.roundCap = false;
  }
}
function handleAxisLine(seriesUnit, iChartOption) {
  var itemStyle2 = iChartOption.itemStyle;
  seriesUnit.axisLine.lineStyle.width = itemStyle2 ? itemStyle2.width ? itemStyle2.width : 10 : 10;
}
function setSplitColor(series, splitColor) {
  series.axisLine.lineStyle.color = splitColor;
  series.axisLine.roundCap = false;
  series.progress.show = false;
  series.pointer.itemStyle = {
    color: "auto"
  };
}
function setGradientColor(series, gradientColor) {
  var linearColor = {
    type: "linear",
    x: 0,
    y: 0,
    x2: 1 / (series.data[0].value / series.max),
    y2: 0,
    colorStops: gradientColor.map(function(item, index) {
      return {
        offset: index === 0 ? 0 : index / (gradientColor.length - 1),
        color: item
      };
    }),
    global: false
  };
  if (linearColor.colorStops.length === 1) {
    linearColor.colorStops.push({
      offset: 1,
      color: gradientColor[0]
    });
  }
  series.progress.itemStyle = {
    color: linearColor
  };
  series.pointer.itemStyle = {
    color: linearColor
  };
}
function setOuterHalo(seriesHalo, splitColor) {
  var temp = cloneDeep(emptySeriesUnit);
  var outerGaugeHalo = cloneDeep(temp);
  outerGaugeHalo.startAngle = seriesHalo.startAngle;
  outerGaugeHalo.endAngle = seriesHalo.endAngle;
  outerGaugeHalo.center = seriesHalo.center;
  var distance = seriesHalo.pointer.lineDistance.slice(0, seriesHalo.pointer.lineDistance.length - 1) - 0;
  outerGaugeHalo.radius = parseFloat(seriesHalo.radius) + distance + "%";
  outerGaugeHalo.axisLine = {
    lineStyle: {
      width: 1,
      opacity: 0.3,
      color: splitColor
    }
  };
  outerGaugeHalo.splitNumber = splitColor.length;
  outerGaugeHalo.splitLine = {
    // 不同颜色之间的中缝
    distance: 8,
    length: 10,
    lineStyle: {
      width: 2,
      color: ""
    }
  };
  outerGaugeHalo.splitLine.lineStyle.color = "transparent";
  return outerGaugeHalo;
}
function setProgressOuterHalo(series, gradientColor, mask, iChartOption) {
  var temp = cloneDeep(emptySeriesUnit);
  var linearColor = {
    type: "linear",
    x: 0,
    y: 0,
    x2: 1,
    y2: 0,
    colorStops: gradientColor.map(function(item, index) {
      return {
        offset: index === 0 ? 0 : index / (gradientColor.length - 1),
        color: item
      };
    }),
    global: false
  };
  var outerGauge = cloneDeep(temp);
  outerGauge.startAngle = series.startAngle;
  outerGauge.endAngle = series.endAngle;
  if (mask && mask.show) {
    outerGauge.startAngle = series.startAngle - 5;
    outerGauge.endAngle = series.endAngle + 5;
  }
  outerGauge.center = series.center;
  var distance = series.pointer.lineDistance.slice(0, series.pointer.lineDistance.length - 1) - 0;
  outerGauge.radius = parseFloat(series.radius) + distance + "%";
  outerGauge.axisLine = {
    lineStyle: {
      width: 1,
      opacity: 0.3,
      color: [[1, linearColor]]
    }
  };
  if (mask && mask.show) {
    var pointerStyle = iChartOption.pointerStyle;
    outerGauge.axisLine = {
      lineStyle: {
        width: mask.width || (pointerStyle && pointerStyle.lineDistance || "5%").replace("%", "") * 2.5,
        opacity: 0.1,
        color: [[1, linearColor]]
      }
    };
  }
  return outerGauge;
}
function setHightLightGauge(series, iChartOption) {
  var gradientColor = iChartOption.gradientColor, mask = iChartOption.mask;
  if (mask && mask.show) {
    var pointerStyle = iChartOption.pointerStyle;
    var outerGauge = cloneDeep(emptySeriesUnit);
    outerGauge.startAngle = series.startAngle - 5;
    outerGauge.endAngle = series.endAngle + 5;
    outerGauge.center = series.center;
    var seriesRadius = series.radius.replace("%", "");
    var pointerRadius = pointerStyle && pointerStyle.lineDistance || "5%";
    outerGauge.radius = seriesRadius - 0 + (pointerRadius.replace("%", "") - 0) + "%";
    if (mask.hightLight !== false) {
      mask.hightLight = true;
    }
    if (mask && mask.hightLight) {
      var linearColor = {
        type: "linear",
        x: 0,
        y: 0,
        x2: 1,
        y2: 0,
        colorStops: gradientColor.map(function(item, index) {
          return {
            offset: index === 0 ? 0 : index / (gradientColor.length - 1),
            color: codeToRGB(codeToHex(item), 0.5)
          };
        }),
        global: false
      };
      var _max3 = iChartOption.max || 100;
      outerGauge.axisLine = {
        lineStyle: {
          width: 1,
          opacity: 1,
          color: [
            // [0.28, linearColor],
            [(iChartOption.data[0].value - 5 * _max3 / 100) / _max3, codeToRGB(codeToHex(gradientColor[0]), 0.5)],
            [(iChartOption.data[0].value + 5 * _max3 / 100) / _max3, codeToRGB(codeToHex(gradientColor[0]), 1)],
            [1, linearColor]
          ]
        }
      };
    } else {
      var _linearColor = {
        type: "linear",
        x: 0,
        y: 0,
        x2: 1,
        y2: 0,
        colorStops: gradientColor.map(function(item, index) {
          return {
            offset: index === 0 ? 0 : index / (gradientColor.length - 1),
            color: item
          };
        }),
        global: false
      };
      outerGauge.axisLine = {
        lineStyle: {
          width: 1,
          opacity: 0.3,
          color: [[1, _linearColor]]
        }
      };
    }
    return outerGauge;
  }
}
function setMarkLine(series, markLine, marklineColor) {
  var temp = cloneDeep(emptySeriesUnit);
  var markGauge = cloneDeep(temp);
  markGauge.name = "markLine";
  markGauge.min = series.min;
  markGauge.max = series.max;
  markGauge.startAngle = series.startAngle;
  markGauge.endAngle = series.endAngle;
  markGauge.center = series.center;
  markGauge.radius = series.radius;
  markGauge.animation = false;
  markGauge.pointer = {
    icon: "path://M0 0 L30 0 L30 100 L0 100 Z",
    width: 3,
    length: 15,
    offsetCenter: [0, "-86%"],
    itemStyle: {
      color: marklineColor
    }
  };
  markGauge.data = [{
    value: markLine
  }];
  return markGauge;
}
function handleOther(iChartOption, seriesUnit, series, data3) {
  var marklineColor = chartToken$p.marklineColor;
  if (iChartOption.splitColor && iChartOption.splitColor.length > 0) {
    setSplitColor(seriesUnit, iChartOption.splitColor);
  } else if (iChartOption.gradientColor && iChartOption.gradientColor.length > 0) {
    setGradientColor(seriesUnit, iChartOption.gradientColor);
  }
  if (iChartOption.markLine && data3[0].value >= iChartOption.markLine) {
    seriesUnit.pointer.itemStyle = {
      color: marklineColor
    };
    seriesUnit.progress.itemStyle = {
      color: marklineColor
    };
  }
  series.push(seriesUnit);
  if (iChartOption.splitColor && iChartOption.splitColor.length > 0) {
    var outerGauge = setOuterHalo(seriesUnit, iChartOption.splitColor);
    if (iChartOption.itemStyle && iChartOption.itemStyle.outerGauge) {
      if (iChartOption.itemStyle.outerGauge.show === false) {
        outerGauge.axisLine.lineStyle.width = 0;
        outerGauge.axisLine.lineStyle.opacity = 0;
      }
    }
    series.push(outerGauge);
  } else if (iChartOption.gradientColor && iChartOption.gradientColor.length > 1) {
    var _outerGauge = setProgressOuterHalo(seriesUnit, iChartOption.gradientColor, iChartOption.mask, iChartOption);
    if (iChartOption.itemStyle && iChartOption.itemStyle.outerGauge) {
      if (!iChartOption.itemStyle.outerGauge.show) {
        _outerGauge.axisLine.lineStyle.width = 0;
        _outerGauge.axisLine.lineStyle.opacity = 0;
      }
    }
    series.push(_outerGauge);
    var hightLightGauge = setHightLightGauge(seriesUnit, iChartOption);
    series.push(hightLightGauge);
  }
  if (iChartOption.markLine) {
    var markGauge = setMarkLine(seriesUnit, iChartOption.markLine, marklineColor);
    series.push(markGauge);
  }
}
function handleSeries$4(iChartOption) {
  var seriesName = iChartOption.seriesName;
  var data3 = iChartOption.data;
  var text = iChartOption.text || {};
  var chartPosition = iChartOption.position || iChartOption.chartPosition || {};
  var axisLabelStyle = iChartOption.axisLabelStyle || {};
  var pointerStyle = iChartOption.pointerStyle, pointer = iChartOption.pointer, min2 = iChartOption.min, max2 = iChartOption.max, startAngle = iChartOption.startAngle, endAngle = iChartOption.endAngle, silent = iChartOption.silent;
  handleTheme$1(iChartOption);
  if (axisLabelStyle.color) {
    seriesInit$6.axisLabel.color = axisLabelStyle.color;
  } else {
    seriesInit$6.axisLabel.color = chartToken$p.axisLabelColor;
  }
  seriesInit$6.axisLabel.distance = axisLabelStyle.distance || 16;
  seriesInit$6.axisLabel.fontWeight = axisLabelStyle.fontWeight || 400;
  seriesInit$6.axisLabel.fontSize = axisLabelStyle.fontSize || 14;
  var series = [];
  var seriesUnit = cloneDeep(seriesInit$6);
  seriesUnit.name = seriesName || iChartOption.name;
  seriesUnit.data = data3;
  handleSplitLine(iChartOption, seriesUnit);
  handleDetail(seriesUnit, text, data3);
  handleProgress(seriesUnit, iChartOption, data3);
  handleAxisLine(seriesUnit, iChartOption);
  seriesUnit.pointer.show = pointer || false;
  seriesUnit.pointer.width = pointerStyle && pointerStyle.width || 16;
  seriesUnit.pointer.length = pointerStyle && pointerStyle.length || "10%";
  seriesUnit.pointer.offsetCenter[1] = pointerStyle && pointerStyle.pointerDistance || "-108%";
  seriesUnit.pointer.lineDistance = pointerStyle && pointerStyle.lineDistance || "5%";
  seriesUnit.center = chartPosition.center || ["50%", "50%"];
  seriesUnit.radius = chartPosition.radius || "70%";
  seriesUnit.min = min2 || 0;
  seriesUnit.max = max2 || 100;
  seriesUnit.startAngle = startAngle === void 0 ? 225 : startAngle;
  seriesUnit.endAngle = endAngle === void 0 ? -45 : endAngle;
  handleOther(iChartOption, seriesUnit, series, data3);
  series[0].silent = silent || false;
  return series;
}
function handleTooltip$4(iChartOpt, chartName2) {
  var basicTip = tooltip(iChartOpt, chartName2);
  return basicTip;
}
var chartName = "GaugeChart";
var GaugeChart = /* @__PURE__ */ function() {
  function GaugeChart2(iChartOption, chartInstance) {
    this.baseOption = {};
    this.iChartOption = {};
    this.baseOption = cloneDeep(BaseOption$6);
    this.iChartOption = init(iChartOption);
    this.updateOption(iChartOption, chartInstance);
  }
  var _proto10 = GaugeChart2.prototype;
  _proto10.updateOption = function updateOption(iChartOption, chartInstance) {
    this.baseOption.color = iChartOption.color;
    this.baseOption.tooltip = handleTooltip$4(iChartOption, chartName);
    this.baseOption.series = handleSeries$4(iChartOption, this.baseOption.color);
    event(chartInstance, iChartOption.event);
    this.baseOption.legend.show = false;
    mergeSeries(iChartOption, this.baseOption);
  };
  _proto10.getOption = function getOption() {
    return this.baseOption;
  };
  _proto10.setOption = function setOption2() {
  };
  return GaugeChart2;
}();
var GaugeChart$1 = GaugeChart;
function getLegendData(data3) {
  return Object.keys(data3);
}
function getXAxisData(data3) {
  var xAxisData = [];
  var dataValues = Object.values(data3);
  dataValues.forEach(function(item) {
    item.forEach(function(val) {
      if (!xAxisData.includes(val[0])) {
        xAxisData.push(val[0]);
      }
    });
  });
  return xAxisData;
}
function getChartToken$a() {
  var colorLabel = Theme$1.config.BubbleChart.emphasis.label.color;
  return {
    emphasisLabelColor: colorLabel,
    labelColor: colorLabel
  };
}
var chartToken$m = proxy(getChartToken$a);
var chartToken$n = chartToken$m;
var seriesInit$5 = {
  // 数据
  data: [],
  // 气泡图
  type: "scatter",
  // 鼠标hover时显示label，并且其他legend变成灰色
  emphasis: {
    label: {
      show: true,
      color: "#ffffff",
      fontSize: 14,
      formatter: function formatter2(param) {
        return param.data[3];
      },
      position: "top"
    }
  },
  // 气泡样式
  itemStyle: {}
};
function setSeries$5(_ref9) {
  var legendData = _ref9.legendData, data3 = _ref9.data, markLine = _ref9.markLine, color3 = _ref9.color, iChartOption = _ref9.iChartOption;
  seriesInit$5.emphasis.label.color = chartToken$n.emphasisLabelColor;
  var series = [];
  legendData.forEach(function(legend2, index) {
    var seriesUnit = cloneDeep(seriesInit$5);
    var itemBorderColor = getColor(color3, index);
    var itemColor = codeToRGB(itemBorderColor, iChartOption.symbolOpacity || 0.2);
    if (markLine) {
      seriesUnit.markLine = cloneDeep(getMarkLineDefault());
      if (markLine.y) {
        seriesUnit.markLine.data.push({
          yAxis: markLine.y
        });
      }
      if (markLine.x) {
        seriesUnit.markLine.data.push({
          xAxis: markLine.x
        });
      }
    }
    seriesUnit.name = legend2;
    seriesUnit.data = data3[legend2];
    seriesUnit.itemStyle = {
      color: itemColor,
      borderColor: itemBorderColor,
      borderWidth: 1
    };
    series.push(seriesUnit);
  });
  return series;
}
function handleSeriesExtra(baseOpt, iChartOption) {
  var symbol = iChartOption.symbol, symbolRotate = iChartOption.symbolRotate, symbolOffset = iChartOption.symbolOffset, cursor = iChartOption.cursor, label2 = iChartOption.label, itemStyle2 = iChartOption.itemStyle, emphasis = iChartOption.emphasis;
  baseOpt.series.forEach(function(item) {
    item.symbol = symbol;
    item.symbolRotate = symbolRotate;
    item.symbolOffset = symbolOffset;
    item.cursor = cursor;
    item.label = label2;
    merge(item.itemStyle, itemStyle2);
    merge(item.emphasis, emphasis);
  });
}
function tooltipFormatter$1(params) {
  var seriesName = params.seriesName;
  var color3 = params.color;
  var data3 = params.data;
  var x = data3[0], y = data3[1], radius = data3[2], name2 = data3[3];
  var htmlString = '<div style="margin-bottom:4px;">\n                                ' + defendXSS$1(seriesName) + "\n                         </div>";
  htmlString += '<div style="margin-bottom:4px;">\n                            <span style="display:inline-block;width:10px;height:10px;\n                            margin-right:8px;border-radius:5px;border-style: solid;border-width:1px;\n                            border-color:' + defendXSS$1(changeRgbaOpacity(color3, 1)) + ";background-color:" + defendXSS$1(color3) + ';"></span>\n                            <span>' + defendXSS$1(name2) + "</span>\n                       </div>";
  htmlString += '\n            <div>\n                <span style="display:inline-block;margin-right:8px;min-width:60px;">x维度</span> \n                <span>' + defendXSS$1(x) + "</span>\n            </div>\n        ";
  htmlString += '\n            <div>\n                <span style="display:inline-block;margin-right:8px;min-width:60px;">y维度</span> \n                <span>' + defendXSS$1(y) + "</span>\n            </div>\n        ";
  htmlString += '\n            <div>\n                <span style="display:inline-block;margin-right:8px;min-width:60px;">半径维度</span> \n                <span>' + defendXSS$1(radius) + "</span>\n            </div>\n        ";
  return htmlString;
}
function setTooltip$4(baseOpt, iChartOption) {
  baseOpt.tooltip.trigger = "item";
  if (iChartOption.trigger === "axis") {
    baseOpt.tooltip.trigger = "axis";
    baseOpt.tooltip.axisPointer.type = "shadow";
  }
  if (!baseOpt.tooltip.formatter) {
    baseOpt.tooltip.formatter = tooltipFormatter$1;
  }
}
function handleTrendLine(option, iChartOption, plugins) {
  var ecStat = plugins.ecStat;
  if (iChartOption.trendLineConfig) {
    if (ecStat) {
      echarts.registerTransform(ecStat.transform.regression);
      option.dataset.push({
        transform: {
          type: "ecStat:regression",
          config: iChartOption.trendLineConfig
        }
      });
      option.series.push({
        name: "trendline",
        type: "line",
        smooth: true,
        datasetIndex: 1,
        symbolSize: 0.1,
        symbol: "circle",
        label: {
          show: true,
          fontSize: 14,
          color: chartToken$n.labelColor
        },
        labelLayout: {
          dx: -20
        },
        encode: {
          label: 2,
          tooltip: 1
        },
        silent: true
      });
    } else {
      throw new Error("您必须安装echarts-stat才可以使用趋势线功能");
    }
  }
}
function setVisualMap$1(baseOption2, iChartOption, legendData) {
  var visualMap = [];
  var bubbleSize = iChartOption.bubbleSize || [10, 70];
  var radius = baseOption2.dataset[0].source.map(function(item) {
    return item[2];
  });
  var minValue = min(radius);
  var maxValue = max(radius);
  var seriesIndex = new Array(legendData.length).fill(0).map(function(item, index) {
    return index;
  });
  visualMap.push({
    show: false,
    dimension: 2,
    min: minValue,
    max: maxValue,
    seriesIndex,
    inRange: {
      symbolSize: bubbleSize
    }
  });
  return visualMap;
}
function setDataset$1(baseOption2, iChartOption) {
  var source = [];
  Object.keys(iChartOption.data).forEach(function(key) {
    source = source.concat(iChartOption.data[key]);
  });
  return [{
    source
  }];
}
var BubbleChart = /* @__PURE__ */ function() {
  function BubbleChart2(iChartOption, chartInstance, plugins) {
    this.baseOption = {};
    this.baseOption = cloneDeep(BaseOption$6);
    this.iChartOption = {};
    this.chartInstance = chartInstance;
    this.iChartOption = init(iChartOption);
    this.updateOption(plugins);
  }
  var _proto11 = BubbleChart2.prototype;
  _proto11.updateOption = function updateOption(plugins) {
    var iChartOption = this.iChartOption;
    RectCoordSys(this.baseOption, this.iChartOption, "BubbleChart");
    setTooltip$4(this.baseOption, iChartOption);
    var legendData = getLegendData(iChartOption.data);
    var xAxisType = iChartOption.xAxisType;
    if (legendData && legendData[0] && iChartOption.data[legendData[0]] && iChartOption.data[legendData[0]][0] && iChartOption.data[legendData[0]][0][0] && typeof iChartOption.data[legendData[0]][0][0] === "string") {
      this.baseOption.xAxis.forEach(function(item) {
        item.type = xAxisType || "category";
        item.data = getXAxisData(iChartOption.data);
      });
    } else {
      this.baseOption.xAxis.forEach(function(item) {
        item.type = xAxisType || "value";
      });
    }
    this.baseOption.legend.data = this.baseOption.legend.data || legendData;
    this.baseOption.series = setSeries$5({
      legendData,
      data: iChartOption.data,
      markLine: iChartOption.markLine,
      color: this.baseOption.color,
      iChartOption
    });
    this.baseOption.dataset = setDataset$1(this.baseOption, iChartOption);
    this.baseOption.visualMap = setVisualMap$1(this.baseOption, iChartOption, legendData);
    handleTrendLine(this.baseOption, iChartOption, plugins);
    handleSeriesExtra(this.baseOption, iChartOption);
    if (iChartOption.event) {
      event(this.chartInstance, iChartOption.event);
    }
    mergeSeries(iChartOption, this.baseOption);
    mergeVisualMap(iChartOption, this.baseOption);
  };
  _proto11.getOption = function getOption() {
    return this.baseOption;
  };
  _proto11.setOption = function setOption2() {
  };
  return BubbleChart2;
}();
var BubbleChart$1 = BubbleChart;
BaseOption$6.xAxis = {
  show: false
};
BaseOption$6.yAxis = {
  show: false
};
function setTooltip$3(iChartOpt) {
  var basicTip = tooltip(iChartOpt);
  basicTip.trigger = "item";
  return basicTip;
}
function getChartToken$9() {
  var colorShadow = Theme$1.config.WordCloudChart.emphasis.textStyle.textShadowColor;
  return {
    emphasisTextShadowColor: colorShadow
  };
}
var chartToken$k = proxy(getChartToken$9);
var chartToken$l = chartToken$k;
var seriesInit$4 = {
  type: "wordCloud",
  // 网格大小，各项之间间距
  gridSize: 16,
  // 形状支持 circle 圆，cardioid  心， diamond 菱形， triangle-forward 、triangle 三角，star五角星
  shape: "circle",
  // 字体大小范围
  sizeRange: [16, 64],
  // 文字旋转角度范围
  rotationRange: [0, 0],
  // 旋转步值
  rotationStep: 0,
  // 画布位置
  top: "center",
  left: "center",
  right: null,
  bottom: null,
  // 画布宽
  width: "75%",
  // 画布高
  height: "80%",
  // 是否渲染超出画布的文字
  drawOutOfBound: false,
  // 文字显示时动画
  layoutAnimation: true,
  // 文字颜色
  textStyle: {
    color: function color2() {
      return "rgb(" + [Math.round(getRandom * 256), Math.round(getRandom * 256), Math.round(getRandom * 256)].join(",") + ")";
    }
  },
  // hover时样式
  emphasis: {
    // focus: 'self',
    textStyle: {
      textShadowBlur: 20,
      textShadowOffsetY: 2,
      textShadowOffsetX: 2,
      textShadowColor: "#191919"
    }
  },
  data: []
};
function handleSeries$3(params) {
  var data3 = params.data, width = params.width, height = params.height, gridSize = params.gridSize, sizeRange = params.sizeRange, rotationRange = params.rotationRange, rotationStep = params.rotationStep, shape = params.shape, maskImage = params.maskImage, textColor2 = params.textColor, colors = params.colors;
  seriesInit$4.emphasis.textStyle.textShadowColor = chartToken$l.emphasisTextShadowColor;
  var series = [];
  var seriesUnit = cloneDeep(seriesInit$4);
  if (maskImage) {
    seriesUnit.maskImage = maskImage;
  }
  seriesUnit.width = width || "75%";
  seriesUnit.height = height || "80%";
  seriesUnit.gridSize = gridSize || 16;
  seriesUnit.sizeRange = sizeRange || [16, 64];
  seriesUnit.rotationRange = rotationRange || [0, 0];
  seriesUnit.rotationStep = rotationStep || 0;
  seriesUnit.shape = shape || "circle";
  if (textColor2) {
    seriesUnit.textStyle.color = textColor2;
  } else {
    seriesUnit.textStyle.color = function(data22) {
      var index = data22.dataIndex;
      return getColor(colors, index);
    };
  }
  seriesUnit.data = data3;
  series.push(seriesUnit);
  return series;
}
var WordCloudChart = /* @__PURE__ */ function() {
  function WordCloudChart2(iChartOption) {
    this.baseOption = {};
    this.iChartOption = {};
    this.baseOption = cloneDeep(BaseOption$6);
    this.iChartOption = init(iChartOption);
    this.updateOption();
  }
  var _proto12 = WordCloudChart2.prototype;
  _proto12.updateOption = function updateOption() {
    var iChartOption = this.iChartOption;
    this.baseOption.color = iChartOption.color;
    this.baseOption.tooltip = setTooltip$3(iChartOption);
    this.baseOption.series = handleSeries$3({
      data: iChartOption.data,
      width: iChartOption.width,
      height: iChartOption.height,
      gridSize: iChartOption.gridSize,
      sizeRang: iChartOption.sizeRange,
      rotationRange: iChartOption.rotationRange,
      rotationStep: iChartOption.rotationStep,
      shape: iChartOption.shape,
      maskImage: iChartOption.maskImage,
      textColor: iChartOption.textColor,
      colors: this.baseOption.color
    });
    this.baseOption.grid.top = iChartOption.padding[0];
    this.baseOption.grid.right = iChartOption.padding[1];
    this.baseOption.grid.bottom = iChartOption.padding[2];
    this.baseOption.grid.left = iChartOption.padding[3];
  };
  _proto12.getOption = function getOption() {
    return this.baseOption;
  };
  _proto12.setOption = function setOption2() {
  };
  return WordCloudChart2;
}();
var WordCloudChart$1 = WordCloudChart;
var data = [];
var textColor = "";
var right = 0;
var top = 0;
var bottom = 0;
var left = 0;
var nodeGap = 0;
var nodeWidth = 0;
var orient = "";
var BaseOption$4 = {
  tooltip: {
    trigger: "item",
    triggerOn: "mousemove"
  },
  animation: true,
  series: [{
    nodeAlign: "left",
    orient,
    // 控制图表的位置
    right,
    top,
    bottom,
    left,
    // 控制每列矩形的距离
    nodeGap,
    // 控制矩形的宽度
    nodeWidth,
    type: "sankey",
    data: data.nodes,
    links: data.links,
    emphasis: {
      focus: "adjacency"
    },
    layout: "none",
    focusNodeAdjaceny: true,
    // 将节点按照data中的顺序排列，将值改为0
    layoutIterations: 32,
    // 设置第一层的文本在左侧
    levels: [{
      depth: 0,
      label: {
        position: "left"
      }
    }],
    lineStyle: {
      // 线条颜色过渡
      color: "gradient",
      // 线条透明度
      opacity: 0.6,
      // 线条弯曲度
      curveness: 0.5
    },
    label: {
      color: textColor,
      fontSize: 12,
      // 文字距离节点矩形块的距离
      distance: 5,
      position: "right",
      // 展示文本内容及百分比
      formatter: function formatter3(params) {
        if (params.name !== "empty" && params.name !== "virtical") {
          return params.name + "\n" + params.data.valueBfb;
        } else {
          return "";
        }
      }
    }
  }]
};
var BaseOption$5 = BaseOption$4;
function isMove(draggable, baseOpt) {
  if (draggable === void 0) {
    draggable = true;
  }
  baseOpt.series[0].draggable = draggable;
}
function handleTooltip$3(params) {
  if (params.data.value !== 0 && params.data.valueBfb !== "0%") {
    var htmlString = "";
    if (params.name.includes(">")) {
      params.name = params.name.replace(">", "---");
    }
    var value = params.data.value || params.value;
    htmlString += '<span style="display:inline-block;margin-right:5px;border-radius:50%;height:10px;">' + defendXSS$1(params.name) + '</span><br/><span style="display:inline-block;margin-right:5px;border-radius:50%;height:10px;">value  :  ' + defendXSS$1(value) + "</span>";
    return htmlString;
  }
}
function handleSankeyFormatter(formatter4, SkTooltip) {
  if (formatter4) {
    SkTooltip.formatter = formatter4;
  } else {
    SkTooltip.formatter = function(params) {
      var html = "";
      html = handleTooltip$3(params);
      return html;
    };
  }
}
function setTooltip$2(iChartOption, formatter4) {
  var SkTooltip = tooltip(iChartOption);
  handleSankeyFormatter(formatter4, SkTooltip);
  SkTooltip.trigger = "item";
  return SkTooltip;
}
function padSize(padding, baseOpt, userPadding) {
  if (userPadding) {
    baseOpt.series[0].top = padding[0];
    baseOpt.series[0].right = padding[1];
    baseOpt.series[0].bottom = padding[2];
    baseOpt.series[0].left = padding[3];
  } else {
    var distance = baseOpt.series[0].label.distance;
    if (baseOpt.series[0].orient === "horizontal") {
      var allSource = [];
      var unLeftArr = [];
      var leftArr = [];
      var rightArr = [];
      baseOpt.series[0].links.forEach(function(item) {
        if (!allSource.includes(item.source)) {
          allSource.push(item.source);
        }
        baseOpt.series[0].data.forEach(function(val) {
          if (item.target.includes(val.name) && !unLeftArr.includes(val.name)) {
            unLeftArr.push(val.name);
          }
        });
      });
      baseOpt.series[0].data.forEach(function(val) {
        if (!unLeftArr.includes(val.name) && !leftArr.includes(val.name)) {
          leftArr.push(val.name);
        }
      });
      if (baseOpt.series[0].levels[0].label.position === "left") {
        baseOpt.series[0].left = judgeMaxText(leftArr, baseOpt) + distance * 2;
      }
      unLeftArr.forEach(function(val) {
        if (!allSource.includes(val) && !rightArr.includes(val)) {
          rightArr.push(val);
        }
      });
      if (baseOpt.series[0].label.position === "right") {
        baseOpt.series[0].right = judgeMaxText(rightArr, baseOpt) + distance * 2;
      }
      baseOpt.series[0].top = 0;
      baseOpt.series[0].bottom = 0;
    } else {
      var padding2 = 2 * (baseOpt.series[0].label.fontSize + distance);
      baseOpt.series[0].top = padding2;
      baseOpt.series[0].right = 0;
      baseOpt.series[0].bottom = padding2;
      baseOpt.series[0].left = 0;
    }
  }
}
function sumBfb(links, nodes) {
  var sourceData = [];
  links.forEach(function(item) {
    if (!sourceData.includes(item.source)) {
      sourceData.push(item.source);
    }
  });
  links.forEach(function(item) {
    if (sourceData.includes(item.target)) {
      sourceData = sourceData.filter(function(items) {
        return items !== item.target;
      });
    }
  });
  var valueSum = 0;
  nodes.forEach(function(itemn) {
    sourceData.forEach(function(items) {
      if (items === itemn.name) {
        valueSum += itemn.value;
      }
    });
  });
  nodes.forEach(function(itemn) {
    if (!itemn.value) {
      itemn.value = 0;
    }
    itemn.valueBfb = itemn.value * 100 / valueSum;
    itemn.valueBfb = itemn.valueBfb.toFixed(0);
    itemn.valueBfb += "%";
  });
}
function setWidthSpace(widthSpace, baseOpt) {
  if (!widthSpace || widthSpace.length === 0) {
    widthSpace = [10, 30];
  }
  baseOpt.series[0].nodeWidth = widthSpace[0];
  baseOpt.series[0].nodeGap = widthSpace[1];
}
function setDirection$1(orient2, baseOpt) {
  if (orient2 === void 0) {
    orient2 = "horizontal";
  }
  if (orient2 === "vertical") {
    baseOpt.series[0].label.position = "bottom";
    baseOpt.series[0].levels[0].label.position = "top";
  }
  baseOpt.series[0].orient = orient2;
}
function setAlign(nodeAlign, baseOpt) {
  if (nodeAlign === void 0) {
    nodeAlign = "left";
  }
  baseOpt.series[0].nodeAlign = nodeAlign;
}
function setLabel$2(iChartOption, baseOpt) {
  var label2 = iChartOption.label;
  merge(baseOpt.series[0].label, label2);
}
function handleItemStyle(iChartOption, baseOpt) {
  var itemStyle2 = iChartOption.itemStyle;
  baseOpt.series[0].data.forEach(function(item, index) {
    if (item.name !== "empty" && item.name !== "virtical") {
      merge(item.itemStyle, itemStyle2);
    }
  });
}
function handleLineStyle(iChartOption, baseOpt) {
  var lineStyle2 = iChartOption.lineStyle;
  merge(baseOpt.series[0].lineStyle, lineStyle2);
  baseOpt.series[0].links.forEach(function(item, index) {
    if (item.source === "virtical" || item.target === "empty") {
      item.lineStyle = {
        color: "transparent"
      };
    }
  });
}
var judgeMaxText = function judgeMaxText2(textArr, baseOpt) {
  var _baseOpt$series$ = baseOpt.series[0], data3 = _baseOpt$series$.data, fontSize = _baseOpt$series$.label.fontSize;
  textArr.sort(function(a, b) {
    return b.length - a.length;
  });
  var BfbText;
  data3.forEach(function(item) {
    if (item.name === textArr[0]) {
      BfbText = item.valueBfb;
    }
  });
  var leftTextWidth = Math.max(getTextWidth(textArr[0], fontSize), getTextWidth(BfbText, fontSize));
  return leftTextWidth;
};
function getChartToken$8() {
  var colorLabel = Theme$1.config.SankeyChart.label.color;
  return {
    labelColor: colorLabel
  };
}
var chartToken$i = proxy(getChartToken$8);
var chartToken$j = chartToken$i;
function setColor$1(color3, baseOpt) {
  var data3 = baseOpt.series[0].data;
  data3.forEach(function(item, index) {
    item.itemStyle = {
      color: Array.isArray(color3) ? getColor(color3, index) : color3
      // borderColor: Array.isArray(colorGroup) ? getColor(colorGroup, index) : colorGroup,
    };
  });
}
function setTextColor(baseOpt) {
  baseOpt.series[0].label.color = chartToken$j.labelColor;
}
function handleEmptyData(nodes, links) {
  var flag = false;
  var virtualData = [];
  nodes.forEach(function(itemn) {
    itemn.value = itemn.value - 0;
    if (itemn.value === 0) {
      itemn.value = 5;
      virtualData.push(itemn.name);
      flag = true;
    }
  });
  if (flag) {
    nodes.unshift({
      name: "virtical",
      value: 0,
      itemStyle: {
        color: "transparent"
      }
    });
    nodes.push({
      name: "empty",
      value: 0,
      itemStyle: {
        color: "transparent"
      }
    });
    virtualData.unshift("virtical");
  }
  virtualData.forEach(function(item) {
    links.push({
      source: item,
      target: "empty",
      // value设置为负值且足够大，能够盖掉value为0的数据连接线
      value: -9999999999
    });
  });
}
var SankeyChart = /* @__PURE__ */ function() {
  function SankeyChart2(iChartOption) {
    this.baseOption = {};
    this.iChartOption = {};
    this.baseOption = cloneDeep(BaseOption$5);
    this.userPadding = iChartOption.padding || iChartOption.chartPadding;
    this.iChartOption = init(iChartOption);
    this.updateOption();
  }
  var _proto13 = SankeyChart2.prototype;
  _proto13.updateOption = function updateOption() {
    var iChartOption = this.iChartOption;
    var padding = iChartOption.padding || iChartOption.chartPadding;
    var _iChartOption$data = iChartOption.data, nodes = _iChartOption$data.nodes, links = _iChartOption$data.links;
    this.baseOption.series[0].data = nodes;
    this.baseOption.series[0].links = links;
    isMove(iChartOption.draggable, this.baseOption);
    setColor$1(iChartOption.color, this.baseOption);
    setTextColor(this.baseOption);
    this.baseOption.tooltip = setTooltip$2(iChartOption, iChartOption.tipHtml);
    setLabel$2(iChartOption, this.baseOption);
    sumBfb(links, nodes);
    setDirection$1(iChartOption.orient, this.baseOption);
    padSize(padding, this.baseOption, this.userPadding);
    setWidthSpace(iChartOption.widthSpace, this.baseOption);
    handleEmptyData(nodes, links);
    setAlign(iChartOption.nodeAlign, this.baseOption);
    handleItemStyle(iChartOption, this.baseOption);
    handleLineStyle(iChartOption, this.baseOption);
  };
  _proto13.getOption = function getOption() {
    return this.baseOption;
  };
  _proto13.setOption = function setOption2() {
  };
  return SankeyChart2;
}();
var SankeyChart$1 = SankeyChart;
var BaseOption$2 = {
  visualMap: {
    show: false,
    dimension: 2,
    type: "",
    min: "",
    max: "",
    inRange: {
      colorAlpha: [0, 1]
    }
  }
};
var CHARTTYPE = ["RectangularHeatMapChart", "CalendarHeatMapChart", "HexagonHeatMapChart"];
var SERIESUNIT = {
  RectangularHeatMapChart: {
    type: "scatter",
    symbol: "rect",
    symbolSize: "",
    cursor: "pointer",
    data: []
  },
  CalendarHeatMapChart: {
    name: "",
    type: "heatmap",
    cursor: "pointer",
    label: {
      show: void 0,
      color: ""
    },
    data: [],
    emphasis: {
      itemStyle: {
        shadowBlur: 10,
        shadowColor: "rgba(0, 0, 0, 0.5)"
      }
    },
    itemStyle: {
      borderColor: ""
    },
    progressive: 1e3,
    animation: false
  },
  HexagonHeatMapChart: {
    type: "custom",
    name: "",
    renderItem: void 0,
    data: []
  }
};
var VISUALMAPUNIT = {
  RectangularHeatMapChart: {
    show: false,
    dimension: 2,
    min: "",
    max: "",
    inRange: {
      colorAlpha: [0, 1]
    }
  },
  CalendarHeatMapChart: {
    show: true,
    dimension: 2,
    min: "",
    max: "",
    inRange: {},
    inverse: true,
    itemWidth: 16,
    itemHeight: 400,
    text: [],
    textStyle: {
      color: "",
      fontSize: 14
    }
  },
  HexagonHeatMapChart: {
    show: false,
    type: "continuous",
    dimension: 2,
    min: "",
    max: "",
    inRange: {
      color: void 0
    }
  }
};
var SYMBOLCOLOR = {
  RectangularHeatMapChart: "#F43146",
  CalendarHeatMapChart: "#1F55B5",
  HexagonHeatMapChart: ["#FFFFFF", "#448DFF", "#4350EA", "#33307C ", "#242648", "#973152", "#F8364D"]
};
var BaseOption$3 = BaseOption$2;
function getDataKeys(data3) {
  return Object.keys(data3);
}
function handleRectData(data3) {
  return data3;
}
function handleCategoryName(data3) {
  var defaultArr = [];
  data3.forEach(function(item) {
    if (!defaultArr.includes(item)) {
      defaultArr.push(item);
    }
  });
  return defaultArr;
}
function handlecalendarSeriesData(xAxisData, yAxisData, data3, keyName) {
  return data3.map(function(item) {
    return [xAxisData.indexOf(item[keyName[0]]), yAxisData.indexOf(item[keyName[1]]), item[keyName[2]]];
  });
}
function handleCalendarData(data3) {
  var calendarData = [];
  var keyName = getDataKeys(data3[0]);
  var xCategoryName = data3.map(function(item) {
    return item[keyName[0]];
  });
  var yCategoryName = data3.map(function(item) {
    return item[keyName[1]];
  });
  var xAxisData = handleCategoryName(xCategoryName);
  var yAxisData = handleCategoryName(yCategoryName);
  var calendarSeriesData = handlecalendarSeriesData(xAxisData, yAxisData, data3, keyName);
  calendarData.push(xAxisData);
  calendarData.push(yAxisData);
  calendarData.push(calendarSeriesData);
  return calendarData;
}
function computeCoordinates(arr, number, halfWidth, r) {
  return arr.map(function(item, index) {
    var groupNumber = number * 2 - 1;
    var remainder = index % groupNumber;
    var group = index / groupNumber;
    var lineNumber = Math.floor(group);
    if (remainder < number - 1) {
      return [(remainder + 1) * 2 * halfWidth, (1 + 3 * lineNumber) * r, item.value, r, item];
    } else {
      return [((remainder - number + 1) * 2 + 1) * halfWidth, (1 + 1.5 * (2 * lineNumber + 1)) * r, item.value, r, item];
    }
  });
}
function handleHexagonData(data3, iChartOption, chartInstance) {
  var containerWidth = chartInstance.getWidth();
  var containerHeight = chartInstance.getHeight();
  var hexagonData = [];
  var number = iChartOption.quantity || 40;
  var xValue = containerWidth;
  var yValue = containerHeight;
  var initialData = data3;
  var x = xValue / (2 * number);
  var r = x / Math.sqrt(0.75);
  var coordinatesArr = computeCoordinates(initialData, number, x, r);
  hexagonData.push(coordinatesArr);
  hexagonData.push(xValue);
  hexagonData.push(yValue);
  hexagonData.push(r);
  return hexagonData;
}
var dataHandler = {
  RectangularHeatMapChart: handleRectData,
  CalendarHeatMapChart: handleCalendarData,
  HexagonHeatMapChart: handleHexagonData
};
function getData(type, iChartOption, chartInstance) {
  if (iChartOption.data && iChartOption.data.length > 0) {
    var chartData = dataHandler[type](iChartOption.data, iChartOption, chartInstance);
    return chartData;
  }
  return null;
}
function getChartToken$7() {
  var _Theme$1$config$HeatM = Theme$1.config.HeatMapChart, colorAxisLine = _Theme$1$config$HeatM.axisLine.lineStyle.color, colorTextPrimary = _Theme$1$config$HeatM.visualMap.text.color, colorLabel = _Theme$1$config$HeatM.label.color, colorBorder = _Theme$1$config$HeatM.custom.style.stroke;
  return {
    axisLineColor: colorAxisLine,
    visualMapTextColor: colorTextPrimary,
    labelColor: colorLabel,
    customStrokeColor: colorBorder
  };
}
var chartToken$g = proxy(getChartToken$7);
var chartToken$h = chartToken$g;
function handleRenderItem(params, api) {
  var center = api.coord([api.value(0), api.value(1)]);
  var points = [];
  var viewRadius = api.size([api.value(3), api.value(3)]);
  var angle = Math.PI / 6;
  for (var i = 0; i < 6; i++, angle += Math.PI / 3) {
    points.push([center[0] + viewRadius[0] * Math.cos(angle), center[1] + viewRadius[0] * Math.sin(angle)]);
  }
  return {
    type: "group",
    children: [{
      type: "polygon",
      shape: {
        points
      },
      style: {
        stroke: chartToken$h.customStrokeColor,
        fill: api.visual("color"),
        lineWidth: 1
      }
    }]
  };
}
function handleRectangularSeries(seriesUnit, iChartOpt, data3) {
  seriesUnit.symbolSize = iChartOpt.rectangleSize || 8;
  seriesUnit.data = data3;
}
function handleCalendarSeries(seriesUnit, iChartOpt, data3) {
  var _iChartOpt$showLabel;
  seriesUnit.data = data3[2];
  seriesUnit.itemStyle.borderColor = iChartOpt.borderColor || iChartOpt.color;
  seriesUnit.label.show = (_iChartOpt$showLabel = iChartOpt.showLabel) != null ? _iChartOpt$showLabel : true;
  seriesUnit.label.color = chartToken$h.labelColor;
  if (iChartOpt.changeProperty && iChartOpt.changeProperty === "color") {
    seriesUnit.itemStyle.borderWidth = 0;
  }
}
function handleHexagonSeries(seriesUnit, data3) {
  seriesUnit.data = data3[0];
  seriesUnit.renderItem = handleRenderItem;
}
var seriesHandler = {
  RectangularHeatMapChart: handleRectangularSeries,
  CalendarHeatMapChart: handleCalendarSeries,
  HexagonHeatMapChart: handleHexagonSeries
};
function handleSeries$2(baseOpt, iChartOpt, data3, type) {
  var series = [];
  var seriesItem = cloneDeep(SERIESUNIT[type]);
  if (type === CHARTTYPE[2]) {
    seriesHandler[type](seriesItem, data3);
  } else {
    seriesHandler[type](seriesItem, iChartOpt, data3);
  }
  series.push(seriesItem);
  baseOpt.series = series;
}
function handleCalendar(iChartOption, visualMapItem, maxValue, minValue) {
  visualMapItem.show = !!iChartOption.handle;
  if (iChartOption.handle) {
    visualMapItem.inverse = !!iChartOption.handle.inverse;
    visualMapItem.text = iChartOption.handle.text || [maxValue, minValue];
    visualMapItem.orient = iChartOption.handle.orient || "vertical";
    visualMapItem.calculable = !!iChartOption.handle.calculable;
    visualMapItem.textStyle.color = chartToken$h.visualMapTextColor;
    visualMapItem.itemWidth = iChartOption.handle.width || 20;
    visualMapItem.itemHeight = iChartOption.handle.height || 400;
    if (iChartOption.handle.position) {
      merge(visualMapItem, iChartOption.handle.position);
    } else {
      visualMapItem.right = "4%";
      visualMapItem.bottom = "6%";
    }
  }
  if (!iChartOption.changeProperty || iChartOption.changeProperty === "opcity") {
    visualMapItem.inRange = {
      opacity: [0, 1]
    };
  } else {
    visualMapItem.inRange = {
      color: iChartOption.color
    };
  }
}
function setVisualMap(baseOpt, type, data3, iChartOption) {
  var visualMap = [];
  var visualMapItem = cloneDeep(VISUALMAPUNIT[type]);
  var intervalData = {
    RectangularHeatMapChart: data3,
    CalendarHeatMapChart: data3[2],
    HexagonHeatMapChart: data3[0]
  };
  var intervalArr = intervalData[type].map(function(item) {
    return item[2];
  });
  var minValue = min(intervalArr);
  var maxValue = max(intervalArr);
  visualMapItem.min = minValue;
  visualMapItem.max = maxValue;
  if (type === CHARTTYPE[1]) {
    handleCalendar(iChartOption, visualMapItem, maxValue, minValue);
  }
  if (type === CHARTTYPE[2]) {
    visualMapItem.inRange.color = iChartOption.color;
  }
  visualMap.push(visualMapItem);
  baseOpt.visualMap = visualMap;
}
function setHeatMapDeaultIchartOption(iChartOpt) {
  if (!iChartOpt.color) {
    iChartOpt.color = SYMBOLCOLOR[iChartOpt.type];
  }
  var padding = iChartOpt.chartPadding || iChartOpt.padding;
  if (!padding && iChartOpt.type === CHARTTYPE[1]) {
    iChartOpt.padding = iChartOpt.handle ? [50, 120, 20, 20] : [50, 30, 20, 20];
  }
}
function rectangularFormatter(params) {
  var color3 = params.color;
  var data3 = params.data;
  var x = data3[0], y = data3[1], z = data3[2], name2 = data3[3];
  var htmlString = '<div style="margin-bottom:4px;">\n                                矩形热力图\n                            </div>';
  htmlString += '<div style="margin-bottom:4px;">\n                            <span style="display:inline-block;width:10px;height:10px;\n                            margin-right:8px;border-style: solid;border-width:1px;\n                            border-color:' + defendXSS$1(changeRgbaOpacity(color3, 1)) + ";background-color:" + defendXSS$1(color3) + ';"></span>\n                            <span>' + defendXSS$1(name2) + "</span>\n                        </div>";
  htmlString += '\n                            <div>\n                                <span style="display:inline-block;margin-right:8px;min-width:60px;">x维度</span> \n                                <span>' + defendXSS$1(x) + "</span>\n                            </div>";
  htmlString += '\n                            <div>\n                                <span style="display:inline-block;margin-right:8px;min-width:60px;">y维度</span> \n                                <span>' + defendXSS$1(y) + "</span>\n                            </div>";
  htmlString += '\n                            <div>\n                                <span style="display:inline-block;margin-right:8px;\n                                min-width:60px;">透明度维度</span> \n                                <span>' + defendXSS$1(z) + "</span>\n                            </div>";
  return htmlString;
}
function calendarFormatter(params) {
  var color3 = params.color;
  var data3 = params.data;
  var name2 = params.name;
  var z = data3[2];
  var htmlDom = '<div style="margin-bottom:4px;">\n                                日历热力图\n                            </div>';
  htmlDom += '<div style="margin-bottom:4px;">\n                            <span style="display:inline-block;width:10px;\n                            height:10px;margin-right:8px;border-style: solid;\n                            border-width:1px;border-color:' + defendXSS$1(changeRgbaOpacity(color3, 1)) + ";background-color:" + defendXSS$1(color3) + ';"></span>\n                            <span>' + defendXSS$1(name2) + "</span>\n                        </div>";
  htmlDom += '\n                            <div>\n                                <span style="display:inline-block;margin-right:8px;\n                                min-width:60px;">Value</span> \n                                <span>' + defendXSS$1(z) + "</span>\n                            </div>";
  return htmlDom;
}
function hexagonFormatter(params) {
  var color3 = params.color;
  var data3 = params.data;
  var x = data3[0], y = data3[1], z = data3[2], name2 = data3[3];
  var html = '<div style="margin-bottom:4px;">\n                            蜂窝热力图\n                            </div>';
  html += '<div style="margin-bottom:4px;">\n                            <span style="display:inline-block;width:10px;\n                            height:10px;margin-right:8px;border-style: solid;\n                            border-width:1px;border-color:' + defendXSS$1(changeRgbaOpacity(color3, 1)) + ";background-color:" + defendXSS$1(color3) + ';"></span>\n                            <span>' + defendXSS$1(name2) + "</span>\n                        </div>";
  html += '\n                            <div>\n                                <span style="display:inline-block;margin-right:8px;min-width:60px;">x维度</span> \n                                <span>' + defendXSS$1(x) + "</span>\n                            </div>";
  html += '\n                            <div>\n                                <span style="display:inline-block;margin-right:8px;min-width:60px;">y维度</span> \n                                <span>' + defendXSS$1(y) + "</span>\n                            </div>";
  html += '\n                            <div>\n                                <span style="display:inline-block;margin-right:8px;min-width:60px;">颜色维度</span> \n                                <span>' + defendXSS$1(z) + "</span>\n                            </div>";
  return html;
}
function handleRectangularXaxis(xAxis2) {
  xAxis2.type = "value";
  xAxis2.axisLine.show = false;
}
function handleCalendarXaxis(xAxis2, data3) {
  xAxis2.data = data3[0];
  xAxis2.axisTick.show = false;
  xAxis2.axisLabel.padding = [0, 0, 0, 10 * data3[0][0].length / 2];
}
function handleHexagonXaxis(xAxis2, data3) {
  xAxis2.type = "value";
  xAxis2.axisLine.show = false;
  xAxis2.axisTick.show = false;
  xAxis2.axisLabel.show = false;
  xAxis2.min = 0;
  xAxis2.max = data3[1];
}
var xAxisHandler = {
  RectangularHeatMapChart: handleRectangularXaxis,
  CalendarHeatMapChart: handleCalendarXaxis,
  HexagonHeatMapChart: handleHexagonXaxis
};
function handleXaxis$1(baseOpt, type, data3, iChartOpt, initIchartOpt) {
  var basicXaxis = xAxis(iChartOpt);
  xAxisHandler[type](basicXaxis[0], data3);
  baseOpt.xAxis = basicXaxis;
  if (initIchartOpt.xAxis) {
    baseOpt.xAxis.forEach(function(item, index) {
      merge(item, isArray(initIchartOpt.xAxis) ? initIchartOpt.xAxis[index] : initIchartOpt.xAxis);
    });
  }
}
function handleCalendarYaxis(yAxis2, data3) {
  yAxis2.type = "category";
  yAxis2.data = data3[1];
  yAxis2.splitLine.show = false;
  yAxis2.axisLabel.margin = 20;
  yAxis2.axisLine = {
    show: true,
    lineStyle: {
      width: 2,
      color: chartToken$h.axisLineColor
    }
  };
}
function handleHexagonYaxis(yAxis2, data3) {
  yAxis2.axisLine.show = false;
  yAxis2.splitLine.show = false;
  yAxis2.axisLabel.show = false;
  yAxis2.min = 0;
  yAxis2.max = data3[2];
}
var yAxisHandler = {
  CalendarHeatMapChart: handleCalendarYaxis,
  HexagonHeatMapChart: handleHexagonYaxis
};
function handleYaxis$1(baseOpt, type, data3, iChartOpt, initIchartOpt) {
  var basicYaxis = yAxis(baseOpt, iChartOpt);
  if (type !== CHARTTYPE[0]) {
    yAxisHandler[type](basicYaxis[0], data3, iChartOpt);
  }
  baseOpt.yAxis = basicYaxis;
  if (initIchartOpt.yAxis) {
    baseOpt.yAxis.forEach(function(item, index) {
      merge(item, isArray(initIchartOpt.yAxis) ? initIchartOpt.yAxis[index] : initIchartOpt.yAxis);
    });
  }
}
function handleColor(baseOpt, iChartOpt) {
  baseOpt.color = iChartOpt.color;
}
function handleGrid$2(baseOpt, iChartOpt) {
  var basicGrid = grid(iChartOpt);
  baseOpt.grid = basicGrid;
}
var heatMapTooltipFormatter = {
  RectangularHeatMapChart: rectangularFormatter,
  CalendarHeatMapChart: calendarFormatter,
  HexagonHeatMapChart: hexagonFormatter
};
function handleTooltip$2(baseOpt, iChartOpt, type) {
  var _iChartOpt$tooltip;
  var basicTooltip = tooltip(iChartOpt);
  if (!iChartOpt.tipHtml && !(iChartOpt != null && (_iChartOpt$tooltip = iChartOpt.tooltip) != null && _iChartOpt$tooltip.formatter)) {
    basicTooltip.formatter = heatMapTooltipFormatter[type];
  }
  basicTooltip.trigger = "item";
  baseOpt.tooltip = basicTooltip;
}
var HeatMapChart = /* @__PURE__ */ function() {
  function HeatMapChart2(iChartOption, chartInstance) {
    this.baseOption = {};
    this.iChartOption = {};
    this.initIchartOption = cloneDeep(iChartOption);
    this.baseOption = cloneDeep(BaseOption$3);
    setHeatMapDeaultIchartOption(iChartOption);
    this.iChartOption = init(iChartOption);
    this.chartInstance = chartInstance;
    this.updateOption();
  }
  var _proto14 = HeatMapChart2.prototype;
  _proto14.updateOption = function updateOption() {
    var iChartOption = this.iChartOption;
    var type = iChartOption.type;
    if (!type) {
      throw new Error("HeatMapChart must have a name");
    }
    var data3 = getData(type, iChartOption, this.chartInstance);
    if (!data3)
      return;
    handleColor(this.baseOption, iChartOption);
    handleXaxis$1(this.baseOption, type, data3, iChartOption, this.initIchartOption);
    handleYaxis$1(this.baseOption, type, data3, iChartOption, this.initIchartOption);
    handleGrid$2(this.baseOption, iChartOption);
    handleTooltip$2(this.baseOption, iChartOption, type);
    handleSeries$2(this.baseOption, iChartOption, data3, type);
    setVisualMap(this.baseOption, type, data3, iChartOption);
    event(this.chartInstance, iChartOption.event);
  };
  _proto14.resize = function resize2() {
    if (this.iChartOption.type === "HexagonHeatMapChart") {
      var _this$chartInstance;
      this.updateOption(this.iChartOption, this.chartInstance);
      (_this$chartInstance = this.chartInstance) == null ? void 0 : _this$chartInstance.setOption(this.baseOption);
    }
  };
  _proto14.getOption = function getOption() {
    return this.baseOption;
  };
  _proto14.setOption = function setOption2() {
  };
  return HeatMapChart2;
}();
var HeatMapChart$1 = HeatMapChart;
var BaseOption = {
  tooltip: {},
  series: [{
    type: "",
    data: []
  }]
};
var BaseOption$1 = BaseOption;
function setTooltip$1(iChartOpt) {
  var basicTip = tooltip(iChartOpt);
  basicTip.trigger = "item";
  return basicTip;
}
function setChartPadding(type, iChartOption) {
  var defaultPadding;
  var position2 = {
    left: void 0,
    right: void 0,
    top: void 0,
    bottom: void 0
  };
  switch (type) {
    case "LineTreeChart":
      if (!iChartOption.direction) {
        defaultPadding = [20, 150, 20, 150];
      } else if (iChartOption.direction === "top") {
        defaultPadding = [80, 20, 150, 20];
      } else if (iChartOption.direction === "bottom") {
        defaultPadding = [150, 20, 80, 20];
      } else if (iChartOption.direction === "right") {
        defaultPadding = [20, 150, 20, 150];
      } else {
        defaultPadding = [20, 150, 20, 150];
      }
      break;
    case "RingTreeChart":
      defaultPadding = [100, 150, 100, 150];
      break;
  }
  if (!iChartOption.padding) {
    position2.top = defaultPadding[0];
    position2.right = defaultPadding[1];
    position2.bottom = defaultPadding[2];
    position2.left = defaultPadding[3];
  } else if (iChartOption.padding.length === 1) {
    position2.top = iChartOption.padding[0];
    position2.right = iChartOption.padding[0];
    position2.bottom = iChartOption.padding[0];
    position2.left = iChartOption.padding[0];
  } else if (iChartOption.padding.length === 2) {
    position2.top = iChartOption.padding[0];
    position2.right = iChartOption.padding[1];
    position2.bottom = iChartOption.padding[0];
    position2.left = iChartOption.padding[1];
  } else if (iChartOption.padding.length === 3) {
    position2.top = iChartOption.padding[0];
    position2.right = iChartOption.padding[1];
    position2.bottom = iChartOption.padding[2];
    position2.left = iChartOption.padding[1];
  } else {
    position2.top = iChartOption.padding[0];
    position2.right = iChartOption.padding[1];
    position2.bottom = iChartOption.padding[2];
    position2.left = iChartOption.padding[3];
  }
  return position2;
}
function getChartToken$6() {
  var _Theme$1$config$TreeC = Theme$1.config.TreeChart, colorLabel = _Theme$1$config$TreeC.label.color, colorAxisLine = _Theme$1$config$TreeC.lineStyle.color;
  var colorState2 = Theme$1.config.colorState;
  return {
    colorInfo: colorState2.colorInfo,
    lineColor: colorAxisLine,
    labelColor: colorLabel
  };
}
var chartToken$e = proxy(getChartToken$6);
var chartToken$f = chartToken$e;
var label = {
  // 图元的距离
  distance: 10,
  fontSize: 12
};
var lineStyle = {
  width: 1,
  // 连线的曲度
  curveness: 0.5
};
function handleTypeSeries(type) {
  var seriesUnit = {};
  switch (type) {
    case "LineTreeChart":
      seriesUnit = {
        type: "tree",
        data: [],
        symbol: "circle",
        layout: "orthogonal",
        // 文本样式
        label,
        // 设置连线的样式
        lineStyle,
        // 图元设置
        itemStyle: {},
        leaves: {
          label: {}
        },
        // 初始动画的时长，
        animationDuration: 550,
        // 数据更新动画的时长。
        animationDurationUpdate: 750
      };
      break;
    case "RingTreeChart":
      seriesUnit = {
        type: "tree",
        data: [],
        symbol: "circle",
        layout: "radial",
        // 文本样式
        label: {
          // 图元的距离
          distance: 10,
          fontSize: 12
        },
        // 设置连线的样式
        lineStyle: {
          width: 1,
          // 连线的曲度
          curveness: 0.5
        },
        // 图元的设置
        itemStyle: {},
        // 初始动画的时长，
        animationDuration: 550,
        // 数据更新动画的时长。
        animationDurationUpdate: 750
      };
      break;
  }
  return seriesUnit;
}
function setSeries$4(type, iChartOption) {
  var data3 = iChartOption.data;
  if (!data3)
    return;
  if (data3 && data3.length !== 0) {
    var series = [];
    data3.forEach(function(dataItem) {
      var seriesItem = handleTypeSeries(type);
      var position2 = setChartPadding(type, iChartOption);
      Object.assign(seriesItem, position2);
      seriesItem.name = dataItem.name;
      seriesItem.data = dataItem.data;
      seriesItem.symbolSize = iChartOption.symbolSize ? iChartOption.symbolSize : 10;
      seriesItem.initialTreeDepth = iChartOption.initialTreeDepth ? iChartOption.initialTreeDepth : 1;
      seriesItem.label.color = chartToken$f.labelColor;
      seriesItem.lineStyle.color = chartToken$f.lineColor;
      seriesItem.itemStyle.color = chartToken$f.colorInfo;
      switch (type) {
        case "LineTreeChart":
          seriesItem.edgeShape = iChartOption.lineType ? iChartOption.lineType : "curve";
          if (!iChartOption.direction) {
            seriesItem.label.position = "left";
            seriesItem.leaves.label.position = "right";
            seriesItem.orient = "LR";
          } else if (iChartOption.direction === "top") {
            seriesItem.label.position = "top";
            seriesItem.label.rotate = -90;
            seriesItem.label.align = "right";
            seriesItem.label.verticalAlign = "middle";
            seriesItem.leaves.label.position = "bottom";
            seriesItem.leaves.label.align = "left";
            seriesItem.orient = "TB";
          } else if (iChartOption.direction === "right") {
            seriesItem.label.position = "right";
            seriesItem.leaves.label.position = "left";
            seriesItem.orient = "RL";
          } else if (iChartOption.direction === "bottom") {
            seriesItem.label.position = "bottom";
            seriesItem.label.rotate = 90;
            seriesItem.label.align = "right";
            seriesItem.label.verticalAlign = "middle";
            seriesItem.leaves.label.position = "top";
            seriesItem.leaves.label.align = "left";
            seriesItem.orient = "BT";
          } else {
            seriesItem.label.position = "left";
            seriesItem.leaves.label.position = "right";
            seriesItem.orient = "LR";
          }
          break;
      }
      series.push(seriesItem);
    });
    return series;
  }
}
var TreeChart = /* @__PURE__ */ function() {
  function TreeChart2(iChartOption) {
    this.baseOption = {};
    this.iChartOption = {};
    this.baseOption = cloneDeep(BaseOption$1);
    this.iChartOption = iChartOption;
    this.updateOption();
  }
  var _proto15 = TreeChart2.prototype;
  _proto15.updateOption = function updateOption() {
    var iChartOption = this.iChartOption;
    var type = iChartOption.type;
    if (!type) {
      throw new Error("TreeChart must have a name");
    }
    this.baseOption.series = setSeries$4(type, iChartOption);
    this.baseOption.tooltip = setTooltip$1(iChartOption);
    mergeSeries(iChartOption, this.baseOption);
  };
  _proto15.getOption = function getOption() {
    return this.baseOption;
  };
  _proto15.setOption = function setOption2() {
  };
  return TreeChart2;
}();
var TreeChart$1 = TreeChart;
function getChartToken$5() {
  var _Theme$1$config$Sunbu = Theme$1.config.SunburstChart, colorBorder = _Theme$1$config$Sunbu.itemStyle.borderColor, colorLabel = _Theme$1$config$Sunbu.label.color;
  return {
    itemBorderColor: colorBorder,
    labelColor: colorLabel
  };
}
var chartToken$c = proxy(getChartToken$5);
var chartToken$d = chartToken$c;
var seriesInit$3 = {
  center: ["50%", "50%"],
  radius: ["12%", "70%"],
  type: "sunburst",
  sort: void 0,
  emphasis: {
    focus: "descendant"
  },
  itemStyle: {
    borderRadius: 4,
    borderWidth: 2,
    borderColor: ""
  },
  data: [],
  label: {
    rotate: 0,
    color: ""
  },
  levels: []
};
function setSeries$3(iChartOption) {
  var data3 = iChartOption.data;
  var series = cloneDeep(seriesInit$3);
  series.data = data3;
  series.itemStyle.borderColor = chartToken$d.itemBorderColor;
  series.label.color = chartToken$d.labelColor;
  return series;
}
var CHART_NAME$3 = "SunburstChart";
var SunburstChart = /* @__PURE__ */ function() {
  function SunburstChart2(iChartOption, chartInstance) {
    this.baseOption = {};
    this.iChartOption = {};
    this.iChartOption = init(iChartOption);
    this.updateOption(chartInstance);
  }
  var _proto16 = SunburstChart2.prototype;
  _proto16.updateOption = function updateOption(chartInstance) {
    var iChartOption = this.iChartOption;
    PolarCoordSys(this.baseOption, iChartOption, CHART_NAME$3);
    this.baseOption.color = [""].concat(iChartOption.color);
    this.baseOption.series = setSeries$3(iChartOption);
    if (iChartOption.event) {
      event(chartInstance, iChartOption.event);
    }
    merge(this.baseOption.series, iChartOption.series);
  };
  _proto16.getOption = function getOption() {
    return this.baseOption;
  };
  return SunburstChart2;
}();
function setLegend(baseOption2) {
  var dataUnit = cloneDeep(baseOption2.series[0].data);
  var data3 = [];
  var sort = [];
  if (dataUnit !== void 0) {
    data3 = dataUnit;
    sort = baseOption2.series[0].sort;
  }
  var legendData = sortData(sort, data3);
  return legendData;
}
function sortData(sort, data3) {
  var legendName = [];
  if (sort === "ascending") {
    var sortedData = [].concat(data3).sort(function(a, b) {
      return a.value - b.value;
    });
    sortedData.forEach(function(item) {
      legendName.push(item.name);
    });
  } else {
    var _sortedData = [].concat(data3).sort(function(a, b) {
      return b.value - a.value;
    });
    _sortedData.forEach(function(item) {
      legendName.push(item.name);
    });
  }
  return legendName;
}
function getChartToken$4() {
  var _Theme$1$config$Funne = Theme$1.config.FunnelChart, colorBorder = _Theme$1$config$Funne.itemStyle.borderColor, colorLabel = _Theme$1$config$Funne.label.color;
  return {
    labelColor: colorLabel,
    borderColor: colorBorder
  };
}
var chartToken$a = proxy(getChartToken$4);
var chartToken$b = chartToken$a;
var seriesInit$2 = {
  type: "funnel",
  width: "80%",
  min: 0,
  max: 100,
  minSize: "0%",
  maxSize: "100%",
  left: "center",
  top: 60,
  bottom: 60,
  funnelAlign: "center",
  orient: "vertical",
  sort: "descending",
  gap: 10,
  itemStyle: {
    borderColor: "",
    borderWidth: 1
  },
  label: {},
  data: []
};
var SIZE_NAME = ["width", "height", "min", "max", "minSize", "maxSize"];
var POSITION_NAME = ["left", "right", "top", "bottom", "funnelAlign", "orient"];
function setSeries$2(iChartOption) {
  var data3 = iChartOption.data, sort = iChartOption.sort, size3 = iChartOption.size, position2 = iChartOption.position, gap = iChartOption.gap;
  var series = [];
  var selfSeries = iChartOption.series;
  if (selfSeries !== void 0 && selfSeries.length !== 0) {
    selfSeries.forEach(function(seriesItem) {
      var seriesUnit2 = seriesItem;
      for (var index = 0; index < SIZE_NAME.length; index++) {
        var _name9 = SIZE_NAME[index];
        if (seriesUnit2[_name9] === void 0) {
          if (iChartOption.size && iChartOption.size[_name9]) {
            seriesUnit2[_name9] = iChartOption.size[_name9];
          } else {
            seriesUnit2[_name9] = seriesInit$2[_name9];
          }
        }
      }
      for (var _index = 0; _index < POSITION_NAME.length; _index++) {
        var _name10 = POSITION_NAME[_index];
        if (seriesUnit2[_name10] === void 0) {
          if (iChartOption.position && iChartOption.position[_name10]) {
            seriesUnit2[_name10] = iChartOption.position[_name10];
          } else {
            seriesUnit2[_name10] = seriesInit$2[_name10];
          }
        }
      }
      var defaultLabel = {
        show: true,
        color: chartToken$b.labelColor
      };
      seriesUnit2.label = Object.assign(defaultLabel, seriesUnit2.label);
      var config2 = ["gap", "sort"];
      for (var _index2 = 0; _index2 < config2.length; _index2++) {
        var _name11 = config2[_index2];
        if (seriesUnit2[_name11] === void 0) {
          if (iChartOption && iChartOption[_name11]) {
            seriesUnit2[_name11] = iChartOption[_name11];
          } else {
            seriesUnit2[_name11] = seriesInit$2[_name11];
          }
        }
      }
      var defaultItemStyle = {
        borderColor: chartToken$b.borderColor,
        borderWidth: 1
      };
      seriesUnit2.itemStyle = Object.assign(defaultItemStyle, seriesUnit2.itemStyle);
    });
    series = selfSeries;
  } else {
    var seriesUnit = cloneDeep(seriesInit$2);
    data3 && (seriesUnit.data = data3);
    sort && (seriesUnit.sort = sort);
    gap && (seriesUnit.gap = gap);
    setLabel$1(seriesUnit, iChartOption);
    setSize(size3, seriesUnit);
    setPosition(position2, seriesUnit);
    seriesUnit.itemStyle.borderColor = chartToken$b.borderColor;
    series.push(seriesUnit);
  }
  return series;
}
function setSize(size3, seriesUnit) {
  for (var index = 0; index < SIZE_NAME.length; index++) {
    var _name12 = SIZE_NAME[index];
    if (size3 !== void 0 && size3[_name12] !== void 0) {
      seriesUnit[_name12] = size3[_name12];
    }
  }
}
function setPosition(position2, seriesUnit) {
  for (var index = 0; index < POSITION_NAME.length; index++) {
    var _name13 = POSITION_NAME[index];
    if (position2 !== void 0 && position2[_name13] !== void 0) {
      seriesUnit[_name13] = position2[_name13];
    }
  }
}
function setLabel$1(seriesUnit, iChartOption) {
  seriesUnit.label.color = chartToken$b.labelColor;
  seriesUnit.label.position = "inside";
  seriesUnit.label.show = true;
  Object.assign(seriesUnit.label, iChartOption.label);
}
var CHART_NAME$2 = "FunnelChart";
var FunnelChart = /* @__PURE__ */ function() {
  function FunnelChart2(iChartOption, chartInstance) {
    this.baseOption = {};
    this.iChartOption = {};
    this.iChartOption = init(iChartOption);
    this.updateOption(chartInstance);
  }
  var _proto17 = FunnelChart2.prototype;
  _proto17.updateOption = function updateOption(chartInstance) {
    var iChartOption = this.iChartOption;
    PolarCoordSys(this.baseOption, iChartOption, CHART_NAME$2);
    this.baseOption.series = setSeries$2(iChartOption);
    this.baseOption.legend.data ? this.baseOption.legend.data : setLegend(this.baseOption);
    if (iChartOption.event) {
      event(chartInstance, iChartOption.event);
    }
  };
  _proto17.getOption = function getOption() {
    return this.baseOption;
  };
  return FunnelChart2;
}();
function getChartToken$3() {
  var _Theme$1$config$Liqui = Theme$1.config.LiquidfillChart, colorLabel = _Theme$1$config$Liqui.label.color, colorBgPrimary = _Theme$1$config$Liqui.backgroundStyle.color;
  var colorGroup2 = Theme$1.config.colorGroup;
  return {
    labelColor: colorLabel,
    colorGroup: colorGroup2,
    backgroundColor: colorBgPrimary
  };
}
var chartToken$8 = proxy(getChartToken$3);
var chartToken$9 = chartToken$8;
var seriesInit$1 = {
  type: "liquidFill",
  center: ["50%", "50%"],
  color: "",
  backgroundStyle: {
    color: ""
  },
  outline: {
    itemStyle: {
      borderColor: "",
      shadowBlur: 0
    }
  },
  itemStyle: {
    opacity: 1,
    shadowBlur: 5,
    shadowColor: "rgba(0, 0, 0, 0.4)"
  },
  label: {},
  data: []
};
function setSeries$1(iChartOption) {
  var data3 = iChartOption.data, shape = iChartOption.shape, color3 = iChartOption.color, name2 = iChartOption.name, label2 = iChartOption.label, outline = iChartOption.outline, backgroundStyle = iChartOption.backgroundStyle;
  var series = [];
  var selfSeries = iChartOption.series;
  if (selfSeries !== void 0 && selfSeries.length !== 0) {
    selfSeries.forEach(function(item) {
      var seriesUnit2 = cloneDeep(seriesInit$1);
      item.data && (seriesUnit2.data = item.data);
      item.center && (seriesUnit2.center = item.center);
      item.shape && (seriesUnit2.shape = item.shape);
      setColor(seriesUnit2, item, color3);
      setBackgroundStyle(seriesUnit2, item, backgroundStyle);
      setOutline(seriesUnit2, item, outline);
      setLabel(seriesUnit2, item, label2);
      merge(seriesUnit2, item);
      series.push(seriesUnit2);
    });
  } else {
    var seriesUnit = cloneDeep(seriesInit$1);
    data3 && (seriesUnit.data = data3);
    name2 && (seriesUnit.name = name2);
    shape && (seriesUnit.shape = shape);
    setColor(seriesUnit, iChartOption);
    setBackgroundStyle(seriesUnit, iChartOption);
    setOutline(seriesUnit, iChartOption);
    setLabel(seriesUnit, iChartOption);
    series.push(seriesUnit);
  }
  return series;
}
function setLabel(seriesTarget, seriesSource, label2) {
  var labelColor = chartToken$9.labelColor;
  if (seriesSource.label !== void 0) {
    seriesTarget.label.color = labelColor;
    seriesTarget.label.position = "inside";
    seriesTarget.label.show = true;
    merge(seriesTarget.label, seriesSource.label);
  } else if (seriesSource.label === void 0 && label2) {
    seriesTarget.label.color = labelColor;
    seriesTarget.label.position = "inside";
    seriesTarget.label.show = true;
    merge(seriesTarget.label, label2);
  } else {
    seriesTarget.label.color = labelColor;
    seriesTarget.label.position = "inside";
    seriesTarget.label.show = true;
  }
}
function setOutline(seriesTarget, seriesSource, outline) {
  var colorGroup2 = chartToken$9.colorGroup;
  var itemStyle2 = seriesTarget.outline.itemStyle;
  if (seriesSource.outline !== void 0) {
    itemStyle2.borderColor = colorGroup2[0];
    merge(seriesTarget.outline, seriesSource.outline);
  } else if (seriesSource.outline === void 0 && outline) {
    itemStyle2.borderColor = colorGroup2[0];
    merge(seriesTarget.outline, outline);
  } else {
    itemStyle2.borderColor = colorGroup2[0];
  }
}
function setBackgroundStyle(seriesTarget, seriesSource, backgroundStyle) {
  var backgroundColor = chartToken$9.backgroundColor;
  if (seriesSource.backgroundStyle !== void 0) {
    seriesTarget.backgroundStyle.color = backgroundColor;
    merge(seriesTarget.backgroundStyle, seriesSource.backgroundStyle);
  } else if (seriesSource.backgroundStyle === void 0 && backgroundStyle) {
    seriesTarget.backgroundStyle.color = backgroundColor;
    merge(seriesTarget.backgroundStyle, backgroundStyle);
  } else {
    seriesTarget.backgroundStyle.color = backgroundColor;
  }
}
function setColor(seriesTarget, seriesSource, color3) {
  var colorGroup2 = chartToken$9.colorGroup;
  if (seriesSource.color !== void 0) {
    seriesTarget.color = [].concat(colorGroup2);
    merge(seriesTarget.color, seriesSource.color);
  } else if (seriesSource.color === void 0 && color3) {
    seriesTarget.color = [].concat(colorGroup2);
    merge(seriesTarget.color, color3);
  } else {
    seriesTarget.color = [].concat(colorGroup2);
  }
}
var CHART_NAME$1 = "LiquidfillChart";
var LiquidfillChart = /* @__PURE__ */ function() {
  function LiquidfillChart2(iChartOption, chartInstance) {
    this.baseOption = {};
    this.iChartOption = {};
    this.iChartOption = init(iChartOption);
    this.updateOption(chartInstance);
  }
  var _proto18 = LiquidfillChart2.prototype;
  _proto18.updateOption = function updateOption(chartInstance) {
    var iChartOption = this.iChartOption;
    PolarCoordSys(this.baseOption, iChartOption, CHART_NAME$1);
    this.baseOption.series = setSeries$1(iChartOption);
    if (iChartOption.event) {
      event(chartInstance, iChartOption.event);
    }
  };
  _proto18.getOption = function getOption() {
    return this.baseOption;
  };
  return LiquidfillChart2;
}();
function getChartToken$2() {
  var colorBgPrimary = Theme$1.config.BoxplotChart.itemStyle.color;
  return {
    itemColor: colorBgPrimary
  };
}
var chartToken$6 = proxy(getChartToken$2);
var chartToken$7 = chartToken$6;
var datasetInit = [{
  source: []
}, {
  transform: {
    type: "boxplot"
  }
}, {
  fromDatasetIndex: 1,
  fromTransformResult: 1
}];
var seriesInit = [{
  name: "boxplot",
  type: "boxplot",
  datasetIndex: 1,
  itemStyle: {
    color: ""
  }
}, {
  name: "outlier",
  type: "scatter",
  datasetIndex: 2
}];
function setDataset(data3) {
  var dataset = cloneDeep(datasetInit);
  dataset[0].source = data3;
  return dataset;
}
function setSeries() {
  var series = cloneDeep(seriesInit);
  series[0].itemStyle.color = chartToken$7.itemColor;
  return series;
}
function setDirection(baseOption2, direction) {
  if (direction && direction === "horizontal") {
    var temp = baseOption2.xAxis;
    baseOption2.xAxis = baseOption2.yAxis;
    baseOption2.yAxis = temp;
  }
}
function tooltipFormatter(params) {
  var data3 = params.data, color3 = params.color, seriesType = params.seriesType;
  var labels = ["下限", "下四分位数", "中位数", "上四分位数", "上限"];
  var htmlString = "";
  if (seriesType === "boxplot") {
    var arr = [];
    labels.forEach(function(item, index) {
      htmlString = '<div>\n                            <span style="display:inline-block;width:10px;height:10px;\n                            margin-right:4px;border-radius:5px;border-style: solid;border-width:1px;\n                            border-color:' + defendXSS$1(color3) + ";background-color:" + defendXSS$1(color3) + ';"></span>\n                            <span style="display:inline-block;width:90px">' + defendXSS$1(item) + ":</span><span>" + defendXSS$1(data3[index + 1]) + "</span>\n                       </div>";
      arr.push(htmlString);
    });
    htmlString = arr.join("<br/>");
  } else {
    htmlString = '<div>\n                            <span style="display:inline-block;width:10px;height:10px;\n                            margin-right:4px;border-radius:5px;border-style: solid;border-width:1px;\n                            border-color:' + defendXSS$1(color3) + ";background-color:" + defendXSS$1(color3) + ';"></span>\n                            <span style="display:inline-block;width:90px">离散点:</span><span>' + defendXSS$1(data3[1]) + "</span>\n                       </div>";
  }
  return htmlString;
}
function setTooltip(baseOpt) {
  if (!baseOpt.tooltip.formatter) {
    baseOpt.tooltip.formatter = tooltipFormatter;
  }
}
var CHART_NAME = "BoxplotChart";
var BoxplotChart = /* @__PURE__ */ function() {
  function BoxplotChart2(iChartOption, chartInstance) {
    this.baseOption = {};
    this.iChartOption = {};
    this.iChartOption = init(iChartOption);
    this.updateOption(chartInstance);
  }
  var _proto19 = BoxplotChart2.prototype;
  _proto19.updateOption = function updateOption(chartInstance) {
    var iChartOption = this.iChartOption;
    RectCoordSys(this.baseOption, this.iChartOption, CHART_NAME);
    this.baseOption.xAxis[0].data = void 0;
    this.baseOption.tooltip.trigger = "item";
    if (iChartOption.data && !iChartOption.dataset) {
      this.baseOption.dataset = setDataset(iChartOption.data);
      this.baseOption.series = setSeries();
    }
    if (iChartOption.dataset && iChartOption.series) {
      this.baseOption.dataset = iChartOption.dataset;
      this.baseOption.series = iChartOption.series;
      this.baseOption.series.forEach(function(item) {
        item.itemStyle = {};
        item.itemStyle.color = chartToken$7.itemColor;
      });
    }
    setDirection(this.baseOption, iChartOption.direction);
    setTooltip(this.baseOption);
    if (iChartOption.event) {
      event(chartInstance, iChartOption.event);
    }
  };
  _proto19.getOption = function getOption() {
    return this.baseOption;
  };
  return BoxplotChart2;
}();
function getChartToken$1() {
  var colorTextPrimary = Theme$1.config.RegionChart.visualMap.textStyle.color;
  return {
    visualMapTextColor: colorTextPrimary
  };
}
var chartToken$4 = proxy(getChartToken$1);
var chartToken$5 = chartToken$4;
function setOption(iChartOption) {
  var visualMap = iChartOption.visualMap;
  var defaultVisualMap = {
    textStyle: {
      color: chartToken$5.visualMapTextColor
    }
  };
  visualMap && merge(visualMap, defaultVisualMap);
}
var RegionChart = /* @__PURE__ */ function() {
  function RegionChart2(iChartOption, chartInstance) {
    this.baseOption = {};
    this.iChartOption = {};
    this.iChartOption = init(iChartOption);
    this.updateOption(chartInstance);
  }
  var _proto20 = RegionChart2.prototype;
  _proto20.updateOption = function updateOption(chartInstance) {
    var iChartOption = this.iChartOption;
    setOption(this.iChartOption);
    this.baseOption.tooltip = tooltip(iChartOption);
    merge(this.baseOption, iChartOption);
    if (iChartOption.event) {
      event(chartInstance, iChartOption.event);
    }
    delete this.baseOption.legend;
    delete this.baseOption.dataZoom;
    delete this.baseOption.xAxis;
  };
  _proto20.getOption = function getOption() {
    return this.baseOption;
  };
  return RegionChart2;
}();
var VOLUMEGRID = [{
  left: "5%",
  right: "5%",
  height: "50%",
  top: "2%",
  containLabel: false
}, {
  left: "5%",
  right: "5%",
  top: "63%",
  height: "25%",
  containLabel: false
}];
var BASICSERIES$1 = [{
  name: "日K",
  type: "candlestick",
  data: void 0,
  itemStyle: {
    color: void 0,
    color0: void 0,
    borderColor: void 0,
    borderColor0: void 0
  }
}];
function getChartToken() {
  var colorTextSecondary = Theme$1.config.CandlestickChart.axisPointer.label.color;
  var colorState2 = Theme$1.config.colorState;
  return {
    axisPointerLabelColor: colorTextSecondary,
    colorState: colorState2
  };
}
var chartToken$2 = proxy(getChartToken);
var chartToken$3 = chartToken$2;
function handleData$1(iChartOpt) {
  var data3 = iChartOpt.data;
  var xAxisDataName = xkey(iChartOpt);
  if (data3 && data3.length !== 0) {
    var time = [];
    var total = [];
    data3.forEach(function(item) {
      time.push(item[xAxisDataName]);
      var totalItem = [item.open, item.close, item.lowest, item.highest];
      if (item.volume) {
        totalItem.push(item.volume);
      }
      total.push(totalItem);
    });
    return {
      time,
      total
    };
  }
  return null;
}
function handleAxis(baseOpt, data3, volume) {
  var xAxis2 = baseOpt.xAxis;
  if (isArray(xAxis2)) {
    var len = xAxis2.length;
    if (volume && len === 1) {
      var secXaxis = cloneDeep(xAxis2[0]);
      xAxis2.push(secXaxis);
    }
    xAxis2.forEach(function(x, xIndex) {
      x.data = data3.time;
      x.boundaryGap = false;
      x.axisLine.onZero = false;
      if (xIndex === 1) {
        x.axisLabel.show = false;
        x.axisTick.show = false;
        x.gridIndex = 1;
      }
    });
  } else {
    xAxis2.data = data3.time;
    xAxis2.boundaryGap = false;
    xAxis2.axisLine.onZero = false;
  }
  var yAxis2 = baseOpt.yAxis;
  var lenY = yAxis2.length;
  if (volume && lenY === 1) {
    var secYaxis = cloneDeep(yAxis2[0]);
    yAxis2.push(secYaxis);
  }
  yAxis2.forEach(function(y, yIndex) {
    y.scale = true;
    if (yIndex === 1) {
      y.axisLabel.show = false;
      y.splitLine.show = false;
      y.gridIndex = 1;
    }
  });
}
function handleDataZoom$1(baseOpt, iChartOpt) {
  var dataZoom = iChartOpt.dataZoom;
  baseOpt.dataZoom[0].show = true;
  baseOpt.dataZoom[0].xAxisIndex = [0, 1];
  baseOpt.dataZoom[0].bottom = "6%";
  if (dataZoom) {
    merge(baseOpt.dataZoom[0], dataZoom);
  }
}
function handleLegend$1(baseOpt, iChartOpt) {
  var legend2 = iChartOpt.legend;
  if (legend2) {
    merge(baseOpt.legend, legend2);
  }
}
function handleTooltip$1(baseOpt, iChartOpt) {
  var inerTooltip = _extends({}, baseOpt.tooltip);
  delete inerTooltip.axisPointer;
  inerTooltip.axisPointer = {
    type: "cross"
  };
  baseOpt.tooltip = inerTooltip;
  if (iChartOpt.tooltip) {
    merge(baseOpt.tooltip, iChartOpt.tooltip);
  }
}
function handleGrid$1(baseOpt, iChartOpt) {
  var volume = iChartOpt.volume, grid2 = iChartOpt.grid;
  if (!grid2 && volume) {
    baseOpt.grid = cloneDeep(VOLUMEGRID);
  }
}
function handleAxisPointer(baseOpt) {
  var axisPointer2 = {
    link: [{
      xAxisIndex: "all"
    }],
    label: {
      color: chartToken$3.axisPointerLabelColor
    }
  };
  baseOpt.axisPointer = axisPointer2;
}
function handleSeries$1(baseOpt, iChartOpt, data3, chartInstance) {
  var upColor = iChartOpt.upColor, downColor = iChartOpt.downColor;
  var colorState2 = chartToken$3.colorState;
  var upStateColor = upColor || colorState2.colorError;
  var downStateColor = downColor || colorState2.colorSuccess;
  var baseSeries = cloneDeep(BASICSERIES$1);
  baseSeries[0].data = data3.total;
  baseSeries[0].itemStyle.color = upStateColor;
  baseSeries[0].itemStyle.color0 = downStateColor;
  baseSeries[0].itemStyle.borderColor = upStateColor;
  baseSeries[0].itemStyle.borderColor0 = downStateColor;
  baseOpt.series = baseSeries;
  handleMaAndVolSeries(baseOpt, iChartOpt, data3, {
    upStateColor,
    downStateColor
  }, chartInstance);
}
function calculateMA(dayCount, data3) {
  var result = [];
  for (var i = 0, len = data3.length; i < len; i++) {
    if (i < dayCount) {
      result.push("");
      continue;
    }
    var sum = 0;
    for (var j = 0; j < dayCount; j++) {
      sum += +data3[i - j][1];
    }
    result.push(Number((sum / dayCount).toFixed(2)));
  }
  return result;
}
function getLineChartData(data3, total, ma, xAxisKey) {
  var maData = {};
  ma.forEach(function(item) {
    var data22 = calculateMA(item, total);
    maData["MA" + item] = data22;
  });
  var lineData = data3.map(function(obj2, index) {
    var _newObj;
    var newObj = (_newObj = {}, _newObj[xAxisKey] = obj2[xAxisKey], _newObj);
    for (var i in maData) {
      newObj[i] = maData[i][index];
    }
    return newObj;
  });
  return lineData;
}
function getBarChartData(data3, xAxisKey) {
  var barData = data3.map(function(obj2) {
    var _newObj2;
    var newObj = (_newObj2 = {}, _newObj2[xAxisKey] = obj2[xAxisKey], _newObj2.volume = obj2.volume, _newObj2);
    return newObj;
  });
  return barData;
}
function handleMaSeries(baseOpt, iChartOpt, data3, total, inerMa, xAxisKey, chartInstance) {
  var lineChartData = getLineChartData(data3, total, inerMa, xAxisKey);
  var newIchartOption = _extends({}, iChartOpt, {
    data: lineChartData
  });
  var lineChart = new LineChart$1(newIchartOption, {}, chartInstance);
  var lineBaseOption = lineChart.getOption();
  var lineSeries = lineBaseOption.series;
  for (var i = 0; i < lineSeries.length; i++) {
    baseOpt.series.push(lineSeries[i]);
  }
}
function handleVol(baseOpt, iChartOpt, data3, xAxisKey, _ref10, total, chartInstance) {
  var upStateColor = _ref10.upStateColor, downStateColor = _ref10.downStateColor;
  var barChartData = getBarChartData(data3, xAxisKey);
  var newIchartOption = _extends({}, iChartOpt, {
    data: barChartData
  });
  var barChart = new BarChart$1(newIchartOption, {}, chartInstance);
  var barBaseOption = barChart.getOption();
  var barSeries = barBaseOption.series[0];
  barSeries.itemStyle.color = function(params) {
    var dataIndex = params.dataIndex;
    var curTimeData = total[dataIndex];
    return curTimeData[0] > curTimeData[1] ? downStateColor : upStateColor;
  };
  barSeries.xAxisIndex = 1;
  barSeries.yAxisIndex = 1;
  baseOpt.series.push(barSeries);
}
function handleMaAndVolSeries(baseOpt, iChartOpt, inerData, _ref11, chartInstance) {
  var upStateColor = _ref11.upStateColor, downStateColor = _ref11.downStateColor;
  var MA = iChartOpt.MA, volume = iChartOpt.volume, data3 = iChartOpt.data;
  var total = inerData.total;
  var xAxisKey = xkey(iChartOpt);
  if (MA && MA.length !== 0) {
    handleMaSeries(baseOpt, iChartOpt, data3, total, MA, xAxisKey, chartInstance);
  }
  if (volume) {
    handleVol(baseOpt, iChartOpt, data3, xAxisKey, {
      upStateColor,
      downStateColor
    }, total, chartInstance);
  }
}
var CandlestickChart = /* @__PURE__ */ function() {
  function CandlestickChart2(iChartOption, chartInstance) {
    this.baseOption = {};
    this.iChartOption = {};
    this.chartInstance = chartInstance;
    this.iChartOption = init(iChartOption);
    this.updateOption();
  }
  var _proto21 = CandlestickChart2.prototype;
  _proto21.updateOption = function updateOption() {
    var iChartOption = this.iChartOption;
    var volume = this.iChartOption.volume;
    var data3 = handleData$1(iChartOption);
    if (!data3)
      return;
    handleSeries$1(this.baseOption, iChartOption, data3, this.chartInstance);
    RectCoordSys(this.baseOption, iChartOption);
    handleGrid$1(this.baseOption, iChartOption);
    handleAxis(this.baseOption, data3, volume);
    handleTooltip$1(this.baseOption, iChartOption);
    handleDataZoom$1(this.baseOption, iChartOption);
    handleLegend$1(this.baseOption, iChartOption);
    handleAxisPointer(this.baseOption);
    event(this.chartInstance, iChartOption.event);
    mergeSeries(iChartOption, this.baseOption);
  };
  _proto21.getOption = function getOption() {
    return this.baseOption;
  };
  _proto21.setOption = function setOption2(option) {
    this.baseOption = option;
  };
  return CandlestickChart2;
}();
var CandlestickChart$1 = CandlestickChart;
var GraphChart = /* @__PURE__ */ function() {
  function GraphChart2(iChartOption) {
    this.rootData = {};
    this.baseOption = {};
    this.updateOption(iChartOption);
  }
  var _proto22 = GraphChart2.prototype;
  _proto22.updateOption = function updateOption(iChartOption) {
    merge(this.baseOption, iChartOption);
  };
  _proto22.getOption = function getOption() {
    return this.baseOption;
  };
  _proto22.setOption = function setOption2() {
  };
  return GraphChart2;
}();
var GraphChart$1 = GraphChart;
var CHARTTYPENAME = {
  ProcessBarChart: "ProcessBarChart",
  StackProcessBarChart: "StackProcessBarChart"
};
var PROCESSBARTYPE = "double-sides";
var BASICUNIT = "%";
var BASICBARWIDTH = {
  ProcessBarChart: 8,
  StackProcessBarChart: 20
};
var BASICSERIES = [{
  // 用来做前面的文本显示
  name: "seriesName",
  type: "bar",
  barWidth: 8,
  barGap: "-100%",
  // 这条series不响应鼠标事件
  silent: true,
  label: {
    show: true,
    color: void 0,
    position: [0, -20],
    fontSize: 14,
    formatter: void 0
  },
  data: void 0
}, {
  // 底色 +右侧label文本显示
  name: "background",
  type: "bar",
  barWidth: 8,
  barGap: "-100%",
  itemStyle: {
    color: void 0,
    borderRadius: 4
  },
  emphasis: {
    disabled: true
  },
  label: {
    show: true,
    color: void 0,
    offset: [0, -24],
    position: "insideTopRight",
    fontSize: 14,
    formatter: void 0
  },
  data: void 0
}];
var BASICDATASERIES = {
  name: void 0,
  type: "bar",
  zlevel: 2,
  barWidth: 8,
  cursor: "pointer",
  itemStyle: {
    borderRadius: 4,
    color: void 0
  },
  data: void 0,
  label: {
    show: false,
    color: void 0,
    formatter: void 0
  }
};
var DOUBLEBASICOPTION = {
  grid: [
    // 左边的坐标系
    {
      left: "4%",
      width: "46%",
      top: 0,
      bottom: 0,
      containLabel: false
    },
    // 右边的坐标系
    {
      right: "4%",
      width: "46%",
      top: 0,
      bottom: 0,
      containLabel: false
    }
  ],
  xAxis: [
    // 左侧的x轴
    {
      show: true,
      type: "value",
      gridIndex: 0,
      inverse: true,
      axisLabel: {
        show: false
      },
      splitLine: {
        lineStyle: {
          type: [8, 4]
        }
      },
      max: "dataMax"
    },
    // 右侧的x轴
    {
      show: true,
      type: "value",
      gridIndex: 1,
      splitLine: {
        lineStyle: {
          type: [8, 4]
        }
      },
      axisLabel: {
        show: false
      },
      max: "dataMax"
    }
  ],
  yAxis: [{
    // 左侧的y轴
    type: "category",
    gridIndex: 0,
    show: true,
    inverse: true,
    axisLabel: {
      show: false
    },
    splitLine: {
      show: false
    },
    axisTick: {
      show: false
    },
    axisLine: {
      show: true,
      lineStyle: {
        color: void 0
      }
    },
    position: "right",
    data: void 0
  }, {
    // 右侧的y轴
    type: "category",
    gridIndex: 1,
    inverse: true,
    show: false,
    data: void 0
  }],
  series: [{
    // 实际数据 + 左侧数值
    name: "",
    xAxisIndex: 0,
    yAxisIndex: 0,
    type: "bar",
    zlevel: 2,
    barWidth: 8,
    itemStyle: {
      borderRadius: [4, 0, 0, 4],
      color: void 0
    },
    data: void 0,
    emphasis: {
      disabled: true
    },
    label: {
      show: false
    }
  }, {
    // 左侧底色
    name: "backgroundLeft",
    type: "bar",
    xAxisIndex: 0,
    yAxisIndex: 0,
    barWidth: 8,
    barGap: "-100%",
    itemStyle: {
      color: void 0,
      borderRadius: [4, 0, 0, 4]
    },
    emphasis: {
      disabled: true
    },
    label: {
      show: true,
      offset: [0, 0],
      position: "insideBottomLeft",
      formatter: void 0,
      rich: {
        nameLeft: {
          fontSize: 14,
          color: void 0,
          lineHeight: 14,
          padding: [0, 0, 20, 0]
        },
        valueLeft: {
          fontSize: 14,
          color: void 0,
          lineHeight: 14,
          fontWeight: "bold"
        }
      }
    },
    data: void 0
  }, {
    // 实际数据 + 右侧数值
    name: "",
    xAxisIndex: 1,
    yAxisIndex: 1,
    type: "bar",
    zlevel: 2,
    barWidth: 8,
    itemStyle: {
      borderRadius: [0, 4, 4, 0],
      color: void 0
    },
    emphasis: {
      disabled: true
    },
    label: {
      show: false
    },
    data: void 0
  }, {
    // 右侧底色
    name: "backgroundRight",
    xAxisIndex: 1,
    yAxisIndex: 1,
    type: "bar",
    barWidth: 8,
    barGap: "-100%",
    itemStyle: {
      color: void 0,
      borderRadius: [0, 4, 4, 0]
    },
    emphasis: {
      disabled: true
    },
    label: {
      show: true,
      offset: [0, 0],
      position: "insideBottomRight",
      formatter: void 0,
      rich: {
        nameRight: {
          fontSize: 14,
          color: "",
          lineHeight: 14,
          padding: [0, 0, 20, 0],
          align: "right"
        },
        valueRight: {
          fontSize: 14,
          color: "",
          lineHeight: 14,
          align: "right",
          fontWeight: "bold"
        }
      }
    },
    data: void 0
  }]
};
function handleLimitVal(data3, iChartOpt, demarcatedValue) {
  var dataItem = _extends({}, data3, {
    _initValue: void 0
  });
  var minWidth = iChartOpt.minWidth;
  if (minWidth) {
    var limitValue = demarcatedValue * (parseInt(minWidth) / 100);
    if (data3.value && data3.value < limitValue) {
      dataItem.value = limitValue;
      dataItem._initValue = data3.value;
    }
  }
  return dataItem;
}
function handleDoubleSideData(dataSet, data3, iChartOpt, demarcatedValue) {
  data3.forEach(function(item) {
    dataSet.seriesName.push(item.name);
    var childBarName = [];
    var childBarData = [];
    if (item.children && item.children.length !== 0) {
      item.children.forEach(function(el) {
        childBarName.push(el.name);
        var innerDataItem = handleLimitVal(el, iChartOpt, demarcatedValue);
        childBarData.push(innerDataItem);
      });
      dataSet.barName.push(childBarName);
      dataSet.barData.push(childBarData);
    }
  });
}
function handleBasicProcessData(iChartOpt, dataSet, data3, doubleSide, dataMax) {
  var demarcatedValue = dataMax || 100;
  dataSet.maxValue = demarcatedValue;
  if (doubleSide) {
    handleDoubleSideData(dataSet, data3, iChartOpt, demarcatedValue);
    return;
  }
  data3.forEach(function(dataItem) {
    dataSet.barName.push(dataItem.name);
    var innerDataItem = handleLimitVal(dataItem, iChartOpt, demarcatedValue);
    dataSet.barData.push(innerDataItem);
  });
}
function getSerirsDataMax(dataSet, data3, dataMax) {
  var sumValueMax;
  var sumValue = [];
  data3.forEach(function(el) {
    var _sumValue = 0;
    el.children.forEach(function(child) {
      if (child.value) {
        _sumValue += child.value;
      }
    });
    sumValue.push(_sumValue);
  });
  sumValueMax = max(sumValue);
  if (dataMax && dataMax > sumValueMax) {
    sumValueMax = dataMax;
  }
  dataSet.maxValue = sumValueMax;
  dataSet.sumValue = sumValue;
}
function setMaxValueAgain(dataSet, dataMax) {
  var sum = [];
  var len = dataSet.seriesName.length;
  var _loop2 = function _loop22(i2) {
    var sumValue = 0;
    dataSet.barData.forEach(function(item) {
      if (item[i2].value) {
        sumValue += item[i2].value;
      }
    });
    sum.push(sumValue);
  };
  for (var i = 0; i < len; i++) {
    _loop2(i);
  }
  var maxValue = max(sum);
  if (dataMax && dataMax > maxValue) {
    maxValue = dataMax;
  }
  dataSet.maxValue = maxValue;
}
function handleStackProcessData(iChartOpt, dataSet, data3, dataMax) {
  data3.forEach(function(element) {
    dataSet.seriesName.push(element.name);
  });
  data3[0].children.forEach(function(el) {
    dataSet.barName.push(el.type);
  });
  getSerirsDataMax(dataSet, data3, dataMax);
  dataSet.barName.forEach(function(type) {
    var seriesData = [];
    data3.forEach(function(child) {
      var childItem = child.children.find(function(el) {
        return el.type === type;
      });
      var innerChidItem = handleLimitVal(childItem, iChartOpt, dataSet.maxValue);
      seriesData.push(innerChidItem);
    });
    dataSet.barData.push(seriesData);
  });
  if (iChartOpt.minWidth) {
    setMaxValueAgain(dataSet, dataMax);
  }
}
function handleData(iChartOpt, doubleSide) {
  var data3 = iChartOpt.data, name2 = iChartOpt.name;
  if (!data3)
    return null;
  if (data3 && data3.length > 0) {
    var dataSet = {
      // 图表子项数据
      barData: [],
      // 图表的标题数据
      barName: [],
      // 图表的最大值
      maxValue: void 0,
      // 图表的系列名称
      seriesName: []
    };
    var dataMax = iChartOpt.calibrationValue || iChartOpt.max;
    if (name2 === CHARTTYPENAME.ProcessBarChart) {
      handleBasicProcessData(iChartOpt, dataSet, data3, doubleSide, dataMax);
    } else {
      handleStackProcessData(iChartOpt, dataSet, data3, dataMax);
    }
    return dataSet;
  }
}
var chartToken = Theme$1.getTokenByName("ProcessChart");
var chartToken$1 = chartToken;
function setStateBarColor(data3, stateColorGroup, successColor, stateList) {
  var min2 = stateList[0];
  var max2 = stateList[stateList.length - 1];
  if (min2.value === max2.value) {
    var resState = min2.state;
    return data3 < min2.value ? successColor : stateColorGroup[resState];
  } else {
    if (data3 < min2.value) {
      return successColor;
    }
    if (data3 > max2.value) {
      var _resState = max2.state;
      return stateColorGroup[_resState];
    }
    var len = stateList.length;
    var _color2;
    for (var i = 0; i < len; i++) {
      if (stateList[i].value >= data3) {
        var index = i > 0 ? i - 1 : 0;
        var _resState2 = stateList[index].state;
        _color2 = stateColorGroup[_resState2];
        break;
      }
    }
    return _color2;
  }
}
function handleBarColor(params, iChartOpt, dataSet, doubleSide, isTip) {
  if (isTip === void 0) {
    isTip = false;
  }
  var state = iChartOpt.state, color3 = iChartOpt.color;
  if (state) {
    var _colorState = Theme$1.config.colorState;
    var stateColorGroup = {
      error: _colorState.colorError,
      warning: _colorState.colorAlert,
      subwarning: _colorState.colorWarning,
      success: _colorState.colorSuccess
    };
    var successColor = stateColorGroup.success;
    var stateList = [];
    for (var k in state) {
      if (Object.hasOwnProperty.call(state, k)) {
        var stateItem = {
          state: k,
          value: state[k]
        };
        stateList.push(stateItem);
      }
    }
    stateList.sort(function(a, b) {
      return a.value - b.value;
    });
    return setStateBarColor(isTip ? dataSet.barData[params.dataIndex].value : params.data.value, stateColorGroup, successColor, stateList);
  } else {
    return getColor(color3, doubleSide ? Math.floor(params.seriesIndex / 2) : params.dataIndex);
  }
}
function handleBasicProcessSeries(baseOpt, iChartOpt, dataSet, doubleSide) {
  baseOpt.series = doubleSide ? cloneDeep(DOUBLEBASICOPTION.series) : cloneDeep(BASICSERIES);
  if (doubleSide) {
    baseOpt.series[0].data = dataSet.barData[0];
    baseOpt.series[2].data = dataSet.barData[1];
    baseOpt.series[0].name = dataSet.seriesName[0];
    baseOpt.series[2].name = dataSet.seriesName[1];
    baseOpt.series[0].itemStyle.color = getColor(iChartOpt.color, 0);
    baseOpt.series[2].itemStyle.color = getColor(iChartOpt.color, 1);
    baseOpt.series[1].data = new Array(dataSet.barData[0].length).fill(dataSet.maxValue);
    baseOpt.series[3].data = new Array(dataSet.barData[1].length).fill(dataSet.maxValue);
  } else {
    baseOpt.series[0].data = new Array(dataSet.barData.length).fill(0);
    baseOpt.series[1].data = new Array(dataSet.barData.length).fill(dataSet.maxValue);
    var dataSreies = cloneDeep(BASICDATASERIES);
    dataSreies.name = "data";
    dataSreies.data = dataSet.barData;
    dataSreies.itemStyle.color = function(params) {
      return handleBarColor(params, iChartOpt, dataSet, doubleSide);
    };
    baseOpt.series.push(dataSreies);
  }
}
function setBarBordRadius(barData, seriesName) {
  var total = [];
  var _loop3 = function _loop32(rowIndex2) {
    var rowData = [];
    barData.forEach(function(item, columnIndex) {
      if (item[rowIndex2].value) {
        var dataInfo = {
          columnIndex,
          rowIndex: rowIndex2,
          value: item[rowIndex2].value
        };
        rowData.push(dataInfo);
      }
    });
    total.push(rowData);
  };
  for (var rowIndex = 0; rowIndex < seriesName.length; rowIndex++) {
    _loop3(rowIndex);
  }
  total.forEach(function(to) {
    var tolen = to.length;
    if (tolen !== 0) {
      if (tolen === 1) {
        barData[to[0].columnIndex][to[0].rowIndex] = _extends({}, barData[to[0].columnIndex][to[0].rowIndex], {
          value: barData[to[0].columnIndex][to[0].rowIndex].value,
          itemStyle: {
            borderRadius: [4, 4, 4, 4]
          }
        });
      } else {
        barData[to[0].columnIndex][to[0].rowIndex] = _extends({}, barData[to[0].columnIndex][to[0].rowIndex], {
          value: barData[to[0].columnIndex][to[0].rowIndex].value,
          itemStyle: {
            borderRadius: [4, 0, 0, 4]
          }
        });
        barData[to[to.length - 1].columnIndex][to[to.length - 1].rowIndex] = _extends({}, barData[to[to.length - 1].columnIndex][to[to.length - 1].rowIndex], {
          value: barData[to[to.length - 1].columnIndex][to[to.length - 1].rowIndex].value,
          itemStyle: {
            borderRadius: [0, 4, 4, 0]
          }
        });
      }
    }
  });
}
function handleStackProcessSeries(baseOpt, iChartOpt, dataSet) {
  setBarBordRadius(dataSet.barData, dataSet.seriesName);
  baseOpt.series = cloneDeep(BASICSERIES);
  baseOpt.series[0].data = new Array(dataSet.seriesName.length).fill(0);
  baseOpt.series[1].data = new Array(dataSet.seriesName.length).fill(dataSet.maxValue);
  dataSet.barData.forEach(function(item, index) {
    var unitSeries = cloneDeep(BASICDATASERIES);
    unitSeries.data = item;
    unitSeries.itemStyle.borderRadius = void 0;
    unitSeries.name = dataSet.barName[index];
    unitSeries.stack = "total";
    baseOpt.series.push(unitSeries);
  });
}
function handleBasicProcessTheme(baseOpt, doubleSide) {
  var itemBgEmpty = chartToken$1.itemBgEmpty, axisLabelColor = chartToken$1.axisLabelColor;
  if (doubleSide) {
    baseOpt.series.forEach(function(ser, serIndex) {
      if (serIndex % 2 !== 0) {
        ser.itemStyle.color = itemBgEmpty;
        ser.label.color = axisLabelColor;
      }
    });
  } else {
    baseOpt.series[0].label.color = axisLabelColor;
    baseOpt.series[1].label.color = axisLabelColor;
    baseOpt.series[1].itemStyle.color = itemBgEmpty;
  }
}
function handleStackProcessTheme(baseOpt, iChartOpt) {
  var itemBgEmpty = chartToken$1.itemBgEmpty, axisLabelColor = chartToken$1.axisLabelColor, labeColor = chartToken$1.labeColor;
  baseOpt.series[1].itemStyle.color = itemBgEmpty;
  baseOpt.series[1].label.color = axisLabelColor;
  baseOpt.series[0].label.color = axisLabelColor;
  baseOpt.series.forEach(function(serie, index) {
    if (index > 1) {
      serie.itemStyle.color = function(params) {
        return getColor(iChartOpt.color, params.seriesIndex - 2);
      };
      serie.label.show = true;
      serie.label.color = labeColor;
    }
  });
}
function handleDoubleLabel(params, iChartOpt, dataSet, position2, index) {
  if (index === void 0) {
    index = 0;
  }
  var name2 = params.name, dataIndex = params.dataIndex;
  var innerVal = dataSet.barData[index][dataIndex]._initValue || dataSet.barData[index][dataIndex].value;
  if (innerVal === null || innerVal === void 0)
    return "";
  var innerUnit = iChartOpt.unit || iChartOpt.unit === "" ? iChartOpt.unit : BASICUNIT;
  var val = "" + innerVal + innerUnit;
  return "{name" + position2 + "|" + name2 + "}\n{value" + position2 + "|" + val + "}";
}
function getMaxValLength(dataSet, iChartOpt, index) {
  var maxLength = 0;
  var innerUnit = iChartOpt.unit || iChartOpt.unit === "" ? iChartOpt.unit : BASICUNIT;
  dataSet.barData[index].forEach(function(item) {
    var val = "" + (item._initValue || item.value) + innerUnit;
    var len = getTextWidth(val, 14);
    if (len >= maxLength)
      maxLength = len;
  });
  return maxLength;
}
function setTitle(baseOpt, iChartOpt) {
  if (iChartOpt.title)
    merge(baseOpt.series[0].label, iChartOpt.title);
}
function setText(baseOpt, iChartOpt, dataSet) {
  if (iChartOpt.text) {
    merge(baseOpt.series[1].label, iChartOpt.text);
    var _formatter = iChartOpt.text.formatter;
    if (_formatter) {
      baseOpt.series[1].label.formatter = function(params) {
        var dataIndex = params.dataIndex;
        var value = dataSet.barData[dataIndex]._initValue || dataSet.barData[dataIndex].value;
        var inerParams = _extends({}, params, {
          value,
          data: value
        });
        return _formatter(inerParams);
      };
    }
  }
}
function setBarLabel(baseOpt, iChartOpt, dataSet) {
  baseOpt.series[0].label.formatter = function(params) {
    return params.name === "null" || params.name === "undefined" ? "" : params.name;
  };
  baseOpt.series[1].label.formatter = function(params) {
    var innerVal = dataSet.barData[params.dataIndex]._initValue || dataSet.barData[params.dataIndex].value;
    if (innerVal === null || innerVal === void 0)
      return "";
    var innerUnit = iChartOpt.unit || iChartOpt.unit === "" ? iChartOpt.unit : BASICUNIT;
    return "" + innerVal + innerUnit;
  };
}
function handleBasicProcessLabel(baseOpt, iChartOpt, dataSet, doubleSide) {
  if (doubleSide) {
    var labeColor = chartToken$1.labeColor, disabledColor = chartToken$1.disabledColor;
    baseOpt.series[1].label.formatter = function(params) {
      return handleDoubleLabel(params, iChartOpt, dataSet, "Left");
    };
    baseOpt.series[3].label.formatter = function(params) {
      return handleDoubleLabel(params, iChartOpt, dataSet, "Right", 1);
    };
    var valWidthL = getMaxValLength(dataSet, iChartOpt, 0);
    var valWidthR = getMaxValLength(dataSet, iChartOpt, 1);
    baseOpt.series[1].label.rich.nameLeft.color = disabledColor;
    baseOpt.series[1].label.rich.valueLeft.color = labeColor;
    baseOpt.series[1].label.offset = [-valWidthL - 10, 9];
    baseOpt.series[3].label.rich.nameRight.color = disabledColor;
    baseOpt.series[3].label.rich.valueRight.color = labeColor;
    baseOpt.series[3].label.offset = [valWidthR + 10, 9];
  } else {
    setBarLabel(baseOpt, iChartOpt, dataSet);
    setTitle(baseOpt, iChartOpt);
    setText(baseOpt, iChartOpt, dataSet);
  }
}
function handleStackProcessLabel(baseOpt, iChartOpt, dataSet) {
  baseOpt.series[0].label.formatter = function(params) {
    return params.name === "null" || params.name === "undefined" ? "" : params.name;
  };
  if (iChartOpt.title) {
    merge(baseOpt.series[0].label, iChartOpt.title);
  }
  baseOpt.series[1].label.formatter = function(params) {
    var name2 = dataSet.seriesName[params.dataIndex];
    if (name2 === null || name2 === void 0)
      return "";
    if (iChartOpt.text && iChartOpt.text.labelText)
      return iChartOpt.text.labelText[params.dataIndex];
    if (iChartOpt.unit)
      return "" + dataSet.sumValue[params.dataIndex] + iChartOpt.unit;
    return "" + dataSet.sumValue[params.dataIndex];
  };
  if (iChartOpt.text) {
    merge(baseOpt.series[1].label, iChartOpt.text);
  }
  baseOpt.series.forEach(function(serie, index) {
    if (index > 1)
      serie.label.formatter = function(params) {
        var value = params.data._initValue || params.data.value;
        return value || "";
      };
  });
  if (iChartOpt.label) {
    baseOpt.series.forEach(function(serie, serieIndex) {
      if (serieIndex > 1)
        merge(serie.label, iChartOpt.label);
    });
  }
}
function handleLabel(baseOpt, iChartOpt, dataSet, doubleSide) {
  if (iChartOpt.name === CHARTTYPENAME.ProcessBarChart) {
    handleBasicProcessLabel(baseOpt, iChartOpt, dataSet, doubleSide);
  } else {
    handleStackProcessLabel(baseOpt, iChartOpt, dataSet);
  }
}
function handleTheme(baseOpt, iChartOpt, doubleSide) {
  if (iChartOpt.name === CHARTTYPENAME.ProcessBarChart) {
    handleBasicProcessTheme(baseOpt, doubleSide);
  } else {
    handleStackProcessTheme(baseOpt, iChartOpt);
  }
}
function handleBarWidth(baseOpt, iChartOpt) {
  var name2 = iChartOpt.name;
  var barWidth = iChartOpt.barWidth || BASICBARWIDTH[name2];
  baseOpt.series.forEach(function(serie) {
    serie.barWidth = barWidth;
  });
}
function handleSeries(baseOpt, iChartOpt, dataSet, doubleSide) {
  if (iChartOpt.name === CHARTTYPENAME.ProcessBarChart) {
    handleBasicProcessSeries(baseOpt, iChartOpt, dataSet, doubleSide);
  } else {
    handleStackProcessSeries(baseOpt, iChartOpt, dataSet);
  }
  handleTheme(baseOpt, iChartOpt, doubleSide);
  handleLabel(baseOpt, iChartOpt, dataSet, doubleSide);
  handleBarWidth(baseOpt, iChartOpt);
}
function handleGridWidth(baseOpt, padding, chartInstance) {
  var right2 = padding[1];
  var left2 = padding[3];
  var containerWidth = chartInstance.getWidth();
  var isStrR = isString(right2);
  var isStrL = isString(left2);
  var isPtR = isStrR && right2.includes("%");
  var isPtL = isStrL && left2.includes("%");
  baseOpt.grid[0].left = left2;
  baseOpt.grid[1].right = right2;
  if (isPtR && isPtL) {
    var width = (100 - parseInt(left2) - parseInt(right2)) / 2;
    baseOpt.grid[0].width = width + "%";
    baseOpt.grid[1].width = width + "%";
    return;
  }
  var leftPadding = isPtL ? containerWidth * parseInt(left2) / 100 : parseInt(left2);
  var rightPadding = isPtR ? containerWidth * parseInt(right2) / 100 : parseInt(right2);
  var horizontalPadding = leftPadding + rightPadding;
  var gridWidth = (containerWidth - horizontalPadding) / 2;
  baseOpt.grid[0].width = gridWidth;
  baseOpt.grid[1].width = gridWidth;
}
function handleDoubleGrid(baseOpt, iChartOpt, chartInstance) {
  var padding = iChartOpt.padding;
  baseOpt.grid[0].top = padding[0];
  baseOpt.grid[0].bottom = padding[2];
  baseOpt.grid[1].top = padding[0];
  baseOpt.grid[1].bottom = padding[2];
  handleGridWidth(baseOpt, padding, chartInstance);
}
function handleMergeOption(target, source) {
  target.forEach(function(item, index) {
    merge(item, isArray(source) ? source[index] : source);
  });
}
function handleGrid(baseOpt, iChartOpt, doubleSide, chartInstance) {
  if (doubleSide) {
    baseOpt.grid = cloneDeep(DOUBLEBASICOPTION.grid);
    handleDoubleGrid(baseOpt, iChartOpt, chartInstance);
  } else {
    baseOpt.grid[0].containLabel = false;
  }
  if (iChartOpt.grid) {
    handleMergeOption(baseOpt.grid, iChartOpt.grid);
  }
}
function handleYaxis(baseOpt, iChartOpt, dataSet, doubleSide) {
  if (doubleSide) {
    baseOpt.yAxis = cloneDeep(DOUBLEBASICOPTION.yAxis);
    baseOpt.yAxis[0].show = true;
    baseOpt.yAxis[0].axisLine.lineStyle.color = chartToken$1.axisLineColor;
    baseOpt.yAxis[0].data = dataSet.barName[0];
    baseOpt.yAxis[1].data = dataSet.barName[1];
  } else {
    baseOpt.yAxis[0].inverse = true;
    baseOpt.yAxis[0].show = false;
    baseOpt.yAxis[0].data = iChartOpt.name === CHARTTYPENAME.ProcessBarChart ? dataSet.barName : dataSet.seriesName;
    baseOpt.yAxis[0].type = "category";
  }
  if (iChartOpt.yAxis) {
    handleMergeOption(baseOpt.yAxis, iChartOpt.yAxis);
  }
}
function handleXaxis(baseOpt, doubleSide, iChartOpt) {
  if (doubleSide) {
    baseOpt.xAxis = cloneDeep(DOUBLEBASICOPTION.xAxis);
  } else {
    baseOpt.xAxis[0].show = false;
    baseOpt.xAxis[0].type = "value";
    baseOpt.xAxis[0].max = "dataMax";
  }
  if (iChartOpt.xAxis) {
    handleMergeOption(baseOpt.xAxis, iChartOpt.xAxis);
  }
}
function handleDataZoom(baseOpt, initIchartOption) {
  if (initIchartOption.dataZoom) {
    handleMergeOption(baseOpt.dataZoom, initIchartOption.dataZoom);
  }
}
function handleLegend(baseOpt, dataSet, doubleSide, initIchartOption) {
  if (doubleSide) {
    baseOpt.legend.data = dataSet.seriesName.map(function(item) {
      return {
        name: item
      };
    });
  } else {
    baseOpt.legend.show = false;
  }
  if (initIchartOption.legend) {
    merge(baseOpt.legend, initIchartOption.legend);
  }
}
function handleTipValue(params, dataSet, doubleSide) {
  var value;
  if (doubleSide) {
    value = dataSet.barData[Math.floor(params.seriesIndex / 2)][params.dataIndex]._initValue || dataSet.barData[Math.floor(params.seriesIndex / 2)][params.dataIndex].value;
  } else {
    value = dataSet.barData[params.dataIndex]._initValue || dataSet.barData[params.dataIndex].value;
  }
  return value;
}
function handleTipFormatter(baseOpt, iChartOpt, dataSet, doubleSide) {
  var _iChartOpt$tooltip2;
  var unit = iChartOpt.unit, tipHtml = iChartOpt.tipHtml;
  if (tipHtml) {
    baseOpt.tooltip.formatter = tipHtml;
    return;
  }
  var innerUnit = unit || unit === "" ? unit : BASICUNIT;
  var isItemTooltip = baseOpt.tooltip.trigger === "item";
  var ichartTooltipFormatter = iChartOpt == null ? void 0 : (_iChartOpt$tooltip2 = iChartOpt.tooltip) == null ? void 0 : _iChartOpt$tooltip2.formatter;
  baseOpt.tooltip.formatter = function(echartsParams) {
    var params = isItemTooltip ? echartsParams : echartsParams[0];
    var name2 = params.name;
    var seriesName = params.seriesName;
    var value = handleTipValue(params, dataSet, doubleSide);
    var color3 = seriesName === "background" || seriesName === "backgroundLeft" || seriesName === "backgroundRight" ? handleBarColor(params, iChartOpt, dataSet, doubleSide, true) : params.color;
    var validData = value === null || value === void 0;
    if (ichartTooltipFormatter) {
      var customParams = _extends({}, params, {
        value,
        color: color3,
        data: value,
        unit: innerUnit
      });
      return ichartTooltipFormatter(customParams);
    }
    if (name2 === "null")
      return;
    var htmlString = '\n                          <div>\n                              <span style="display:inline-block;width:10px;height:10px;\n                              border-radius:5px;background-color:' + defendXSS$1(color3) + ';">\n                              </span>\n                              <span style="margin-left:5px;">\n                                  <span style="display:inline-block;margin-right:8px;min-width:80px;">' + defendXSS$1(name2) + '</span> \n                                  <span style="font-weight:bold">' + (validData ? "--" : defendXSS$1(value)) + defendXSS$1(innerUnit) + "</span>\n                              </span>\n                          </div>\n                      ";
    return htmlString;
  };
}
function handleStackTipFormatter(baseOpt, iChartOpt) {
  baseOpt.tooltip.trigger = "axis";
  var tipHtml = iChartOpt.tipHtml;
  if (tipHtml) {
    baseOpt.tooltip.formatter = tipHtml;
    return;
  }
  baseOpt.tooltip.formatter = function(params) {
    var name2 = params[0].name;
    if (name2 === "null")
      return;
    var htmlString = '<div style="margin-bottom:4px;">' + defendXSS$1(name2) + "</div>";
    params.forEach(function(param, index) {
      if (index > 1) {
        var value = param.data._initValue || param.data.value;
        htmlString += '<div>\n      <span style="display:inline-block;width:10px;height:10px;\n      border-radius:5px;background-color:' + defendXSS$1(param.color) + ';">\n      </span>\n      <span style="margin-left:5px;">\n          <span style="display:inline-block;margin-right:8px;min-width:80px;">' + defendXSS$1(param.seriesName) + '</span>\n          <span style="font-weight:bold">' + (defendXSS$1(value) || (defendXSS$1(value) === 0 ? defendXSS$1(value) : "--")) + (defendXSS$1(iChartOpt.unit) || "") + "</span>\n      </span>\n  </div>\n";
      }
    });
    return htmlString;
  };
}
function handleTooltip(baseOpt, iChartOpt, dataSet, doubleSide) {
  baseOpt.tooltip.axisPointer.type = "none";
  baseOpt.tooltip.trigger = "item";
  if (iChartOpt.tooltip) {
    merge(baseOpt.tooltip, iChartOpt.tooltip);
    if (iChartOpt.tooltip.show === false) {
      baseOpt.series.forEach(function(item) {
        item.cursor = "auto";
      });
    }
  }
  if (iChartOpt.name === CHARTTYPENAME.ProcessBarChart) {
    handleTipFormatter(baseOpt, iChartOpt, dataSet, doubleSide);
  } else {
    handleStackTipFormatter(baseOpt, iChartOpt);
  }
}
var ProcessChart = /* @__PURE__ */ function() {
  function ProcessChart2(iChartOption, chartInstance) {
    this.initIchartOption = cloneDeep(iChartOption);
    this.baseOption = {};
    this.iChartOption = {};
    this.chartInstance = chartInstance;
    this.iChartOption = init(iChartOption);
    this.updateOption();
  }
  var _proto23 = ProcessChart2.prototype;
  _proto23.updateOption = function updateOption() {
    var iChartOption = this.iChartOption;
    if (!iChartOption.name) {
      throw new Error("ProcessChart must have a name");
    }
    RectCoordSys(this.baseOption, iChartOption, iChartOption.name);
    var doubleSide = iChartOption.type && iChartOption.type === PROCESSBARTYPE;
    var dataSet = handleData(iChartOption, doubleSide);
    if (!dataSet)
      return;
    handleGrid(this.baseOption, iChartOption, doubleSide, this.chartInstance);
    handleYaxis(this.baseOption, iChartOption, dataSet, doubleSide);
    handleXaxis(this.baseOption, doubleSide, iChartOption);
    handleDataZoom(this.baseOption, this.initIchartOption);
    handleLegend(this.baseOption, dataSet, doubleSide, this.initIchartOption);
    handleSeries(this.baseOption, iChartOption, dataSet, doubleSide);
    handleTooltip(this.baseOption, iChartOption, dataSet, doubleSide);
    event(this.chartInstance, iChartOption.event);
  };
  _proto23.getOption = function getOption() {
    return this.baseOption;
  };
  _proto23.setOption = function setOption2(option) {
    this.baseOption = option;
  };
  return ProcessChart2;
}();
var ProcessChart$1 = ProcessChart;
function Register() {
  this.registeredComp = {};
}
function registerComp(options2) {
  this.registeredComp[options2.name] = options2.component;
}
function getRegisteredComp(name2) {
  if (name2 in this.registeredComp) {
    return this.registeredComp[name2];
  }
  return null;
}
Register.prototype.registerComp = registerComp;
Register.prototype.getRegisteredComp = getRegisteredComp;
var register = new Register();
var components = [{
  name: "AreaChart",
  component: LineChart$1
}, {
  name: "LineChart",
  component: LineChart$1
}, {
  name: "BarChart",
  component: BarChart$1
}, {
  name: "PieChart",
  component: PieChart$1
}, {
  name: "GaugeChart",
  component: GaugeChart$1
}, {
  name: "BubbleChart",
  component: BubbleChart$1
}, {
  name: "RadarChart",
  component: RadarChart$1
}, {
  name: "WordCloudChart",
  component: WordCloudChart$1
}, {
  name: "HeatMapChart",
  component: HeatMapChart$1
}, {
  name: "SankeyChart",
  component: SankeyChart$1
}, {
  name: "TreeChart",
  component: TreeChart$1
}, {
  name: "SunburstChart",
  component: SunburstChart
}, {
  name: "FunnelChart",
  component: FunnelChart
}, {
  name: "LiquidfillChart",
  component: LiquidfillChart
}, {
  name: "BoxplotChart",
  component: BoxplotChart
}, {
  name: "RegionChart",
  component: RegionChart
}, {
  name: "CandlestickChart",
  component: CandlestickChart$1
}, {
  name: "GraphChart",
  component: GraphChart$1
}, {
  name: "ProcessChart",
  component: ProcessChart$1
}];
components.forEach(function(comp) {
  register.registerComp(comp);
});
var Register$1 = register;
var HuiCharts = /* @__PURE__ */ function(_CoreChart) {
  function HuiCharts2() {
    var _this7;
    _this7 = _CoreChart.call(this) || this;
    _this7.chartName;
    return _this7;
  }
  _inheritsLoose(HuiCharts2, _CoreChart);
  var _proto24 = HuiCharts2.prototype;
  _proto24.setSimpleOption = function setSimpleOption(chartName2, iChartOption, plugins, isInit) {
    if (plugins === void 0) {
      plugins = {};
    }
    if (isInit === void 0) {
      isInit = true;
    }
    if (isInit) {
      Theme$1.setDefaultTheme(iChartOption.theme);
      this.mediaScreenObserver && this.mediaScreenObserver.setInitOption(iChartOption);
    }
    if (iChartOption.readScreen) {
      readScreen(this.dom, iChartOption.readScreen);
    }
    if (isFunction(chartName2)) {
      this.redirectSelfChart(chartName2, iChartOption, plugins);
      return;
    }
    this.plugins = plugins;
    this.chartName = chartName2;
    this.iChartOption = iChartOption;
    var ChartClass = this.getChartClass(chartName2);
    this.ichartsIns = new ChartClass(iChartOption, this.echartsIns, this.plugins);
    this.eChartOption = this.ichartsIns.getOption();
    this.iChartOption.axistip && axistip(this.dom, this.echartsIns, this.eChartOption);
    mergeExtend(this.iChartOption, this.eChartOption);
  };
  _proto24.getChartClass = function getChartClass(name2) {
    return Register$1.getRegisteredComp(name2);
  };
  _proto24.mediaScreen = function mediaScreen2(dom, screenOption) {
    var _this8 = this;
    this.mediaScreenObserver = new mediaScreen$1(dom, screenOption, function(option) {
      _this8.setSimpleOption(_this8.chartName, option, _this8.plugins, false);
      _this8.render();
    });
  };
  _proto24.refresh = function refresh(iChartOption) {
    this.iChartOption = iChartOption;
    this.setSimpleOption(this.chartName, iChartOption, this.plugins);
    this.render();
    this.mediaScreenObserver && this.mediaScreenObserver.refresh();
  };
  return HuiCharts2;
}(CoreChart);
var BaiduMapChart = /* @__PURE__ */ function(_BaseChart2) {
  function BaiduMapChart2() {
    var _this9;
    _this9 = _BaseChart2.call(this) || this;
    _this9.echartsIns = null;
    _this9.dom = null;
    _this9.option = null;
    _this9.data = null;
    _this9.resizeObserver = null;
    return _this9;
  }
  _inheritsLoose(BaiduMapChart2, _BaseChart2);
  var _proto25 = BaiduMapChart2.prototype;
  _proto25.init = function init2(dom) {
    this.uninstall();
    this.dom = dom;
  };
  _proto25.setSimpleOption = function setSimpleOption(chartName2, option) {
    this.option = option;
  };
  _proto25.isScriptExist = function isScriptExist(src) {
    var scripts = document.getElementsByTagName("script");
    for (var i = 0; i < scripts.length; i++) {
      if (scripts[i].src && scripts[i].src === src) {
        return true;
      }
    }
    return false;
  };
  _proto25.loadMap = function loadMap(_ref12) {
    var key = _ref12.key, version = _ref12.version, url = _ref12.url;
    return new Promise(function(resolve) {
      var cbName = "bmap" + Date.now();
      var script = document.createElement("script");
      var ver = version || "2.0";
      window[cbName] = resolve;
      script.src = [url + "?v=" + ver, "ak=" + key, "callback=" + cbName].join("&");
      document.body.appendChild(script);
    });
  };
  _proto25.render = function render() {
    var _this10 = this;
    var url = this.option.url;
    var ver = this.option.v || "2.0";
    var key = this.option.key;
    var src = [url + "?" + ver, "ak=" + key].join("&");
    this.option.bmap;
    var scriptExists = this.isScriptExist(src);
    if (scriptExists) {
      this.renderInit();
    } else {
      this.loadMap({
        key,
        version: ver,
        url
      }).then(function() {
        _this10.renderInit();
      });
    }
  };
  _proto25.renderInit = function renderInit() {
    this.echartsIns = echarts.init(this.dom);
    this.setOption(this.option);
    this.setResizeObserver();
    this.renderCallBack && this.renderCallBack(this.echartsIns);
  };
  _proto25.setOption = function setOption2(option) {
    this.echartsIns.setOption(option);
  };
  _proto25.onRenderReady = function onRenderReady(callback) {
    this.renderCallBack = callback;
  };
  _proto25.setResizeObserver = function setResizeObserver() {
    var _this11 = this;
    this.resizeObserver = new ResizeObserver(function(entries) {
      _this11.resizeDom();
    });
    this.resizeObserver.observe(this.dom);
  };
  _proto25.resizeDom = function resizeDom() {
    this.echartsIns && this.echartsIns.resize && this.echartsIns.resize();
  };
  _proto25.refresh = function refresh(iChartOption) {
    this.iChartOption = iChartOption;
    this.setSimpleOption(this.chartName, iChartOption);
    this.render();
  };
  _proto25.refreshData = function refreshData(data3) {
    this.iChartOption.series[0].data = data3;
    this.refresh(this.iChartOption);
  };
  _proto25.setResize = function setResize() {
    this.resizeDom();
  };
  _proto25.uninstall = function uninstall() {
    window.removeEventListener("resize", this.throttleResize);
    if (this.resizeObserver) {
      this.resizeObserver.disconnect();
      this.resizeObserver = null;
    }
    if (this.echartsIns && !this.echartsIns.isDisposed()) {
      this.echartsIns.dispose();
    }
    this.echartsIns = null;
    this.dom = null;
  };
  return BaiduMapChart2;
}(BaseChart);
var amapPromise = null;
var AutonaviMapChart = /* @__PURE__ */ function(_BaseChart3) {
  function AutonaviMapChart2() {
    var _this12;
    _this12 = _BaseChart3.call(this) || this;
    _this12.echartsIns = null;
    _this12.ichartsIns = null;
    _this12.eChartOption = null;
    _this12.iChartOption = null;
    _this12.dom = null;
    _this12.option = null;
    return _this12;
  }
  _inheritsLoose(AutonaviMapChart2, _BaseChart3);
  var _proto26 = AutonaviMapChart2.prototype;
  _proto26.getAmap = function getAmap(option) {
    if (!amapPromise) {
      var key = option.key;
      var url = option.url;
      var version = option.version || option.ver || option.v;
      amapPromise = new Promise(function(resolve) {
        var cbName = "amap" + Date.now();
        var script = document.createElement("script");
        window[cbName] = resolve;
        var src = url + "?v=" + version + "&key=" + key;
        if (option.plugin) {
          src += "&plugin=" + option.plugin;
        }
        script.src = src + "&callback=" + cbName;
        script.onload = function() {
          return resolve();
        };
        document.body.appendChild(script);
      });
    }
    return amapPromise;
  };
  _proto26.init = function init2(dom) {
    this.uninstall();
    this.dom = dom;
    this.echartsIns = echarts$1.init(this.dom);
  };
  _proto26.setSimpleOption = function setSimpleOption(chartName2, option) {
    var _this13 = this;
    this.option = option;
    this.getAmap(this.option).then(function() {
      _this13.echartsIns.setOption(_this13.option);
      _this13.setResizeObserver();
    });
  };
  _proto26.render = function render() {
    this.initDom();
    this.renderCallBack && this.renderCallBack(this);
  };
  _proto26.onRenderReady = function onRenderReady(callback) {
    this.renderCallBack = callback;
  };
  _proto26.initDom = function initDom() {
  };
  _proto26.setResizeObserver = function setResizeObserver() {
    var _this14 = this;
    if (this.resizeObserver) {
      this.resizeObserver.disconnect();
      this.resizeObserver = null;
    }
    this.resizeObserver = new ResizeObserver(function(entries) {
      _this14.resizeDom();
    });
    this.resizeObserver.observe(this.dom);
  };
  _proto26.resizeDom = function resizeDom() {
    this.echartsIns && this.echartsIns.resize && this.echartsIns.resize();
  };
  _proto26.refresh = function refresh(option) {
    this.iChartOption = option;
    this.setSimpleOption("AutonaviMapChart", this.iChartOption);
    this.resizeDom();
  };
  _proto26.refreshData = function refreshData(data3) {
    this.iChartOption.series[0].data = data3;
    this.refresh(this.iChartOption);
  };
  _proto26.setResize = function setResize() {
    this.resizeDom();
  };
  _proto26.uninstall = function uninstall() {
    if (this.resizeObserver) {
      this.resizeObserver.disconnect();
      this.resizeObserver = null;
    }
    if (this.echartsIns && !this.echartsIns.isDisposed()) {
      this.echartsIns.dispose();
    }
    this.echartsIns = null;
    this.dom = null;
  };
  _proto26.getEchartsInstance = function getEchartsInstance() {
    return this.echartsIns;
  };
  _proto26.getEchartsOption = function getEchartsOption() {
    return this.echartsIns.getOption();
  };
  _proto26.getAmapComponent = function getAmapComponent() {
    return this.echartsIns.getModel().getComponent("amap");
  };
  _proto26.getAmapInstance = function getAmapInstance() {
    return this.getAmapComponent().getAMap();
  };
  return AutonaviMapChart2;
}(BaseChart);
var Core = {
  name: $prefix + "ChartCore",
  emits: ["ready", "readyOnce", "handle-color"],
  props: {
    data: {
      type: Object,
      default: function _default() {
        return {};
      }
    },
    settings: {
      type: Object,
      default: function _default2() {
        return {};
      }
    },
    width: {
      type: String,
      default: "auto"
    },
    height: {
      type: String,
      default: "400px"
    },
    events: {
      type: Object,
      default: function _default3() {
      }
    },
    initOptions: {
      type: Object,
      default: function _default4() {
        return {};
      }
    },
    tooltipVisible: {
      type: Boolean,
      default: true
    },
    legendVisible: {
      type: Boolean,
      default: true
    },
    legendPosition: {
      type: String
    },
    theme: Object,
    themeName: [Object, String],
    judgeWidth: {
      type: Boolean,
      default: false
    },
    widthChangeDelay: {
      type: Number,
      default: 200
    },
    resizeable: {
      type: Boolean,
      default: true
    },
    changeDelay: {
      type: Number,
      default: 0
    },
    dataEmpty: Boolean,
    beforeConfig: {
      type: Function
    },
    afterConfig: {
      type: Function
    },
    afterSetOption: {
      type: Function
    },
    afterSetOptionOnce: {
      type: Function
    },
    loading: {
      type: Boolean,
      default: false
    },
    extend: {
      type: Object,
      default: function _default5() {
      }
    },
    tooltipFormatter: {
      type: Function
    },
    markArea: {
      type: Object
    },
    markLine: {
      type: Object
    },
    markPoint: {
      type: Object
    },
    grid: {
      type: [Object, Array]
    },
    colors: {
      type: Array
    },
    visualMap: [Object, Array],
    dataZoom: [Object, Array],
    toolbox: [Object, Array],
    title: Object,
    legend: [Object, Array],
    xAxis: [Object, Array],
    yAxis: [Object, Array],
    radar: Object,
    tooltip: Object,
    axisPointer: Object,
    brush: [Object, Array],
    geo: Object,
    timeline: [Object, Array],
    graphic: [Object, Array],
    series: [Object, Array],
    backgroundColor: [Object, String],
    textStyle: Object,
    animation: Object,
    options: {
      type: Object,
      default: function _default6() {
        return {};
      }
    },
    cancelResizeCheck: {
      type: Boolean,
      default: false
    },
    setOptionOpts: {
      type: Object,
      default: function _default7() {
      }
    },
    colorMode: {
      type: String,
      default: "default"
    }
  },
  data: function data2() {
    return {
      option: {},
      renderOption: {},
      initOpts: {},
      watchToPropsEchartOptions: [],
      selfChart: ["BaiduMapChart", "AutonaviMapChart"],
      isSelfChart: false,
      chartList: [],
      once: {},
      store: {}
    };
  },
  computed: {
    // 图表延时的集合
    delay: function delay() {
      return {
        widthChangeDelay: this.widthChangeDelay,
        resizeDelay: this.resizeDelay
      };
    },
    size: function size2() {
      return {
        width: this.width,
        height: this.height
      };
    },
    // 图表参数的集合
    setting: function setting() {
      return {
        data: this.data,
        settings: this.settings,
        extend: this.extend,
        tooltipVisible: this.tooltipVisible,
        legendVisible: this.legendVisible
      };
    }
  },
  watch: {
    options: {
      handler: function handler() {
        this.refreshChart();
      },
      deep: true
    },
    setting: {
      handler: function handler2() {
        this.refreshChart();
      },
      deep: true
    },
    events: {
      handler: function handler3(val, oldVal) {
        this.addEvents(val);
        this.removeEvents(oldVal);
      },
      deep: true
    },
    initOptions: {
      handler: function handler4(val) {
        this.initOpts = _extends({}, this.initOpts, val);
        this.renderChart(this.option);
      },
      deep: true
    },
    judgeWidth: {
      handler: function handler5(val) {
        this.initOpts.domResize = val;
        this.renderChart(this.option);
      }
    },
    delay: {
      handler: function handler6(val) {
        this.initOpts.resizeThrottle = val;
        this.renderChart(this.option);
      },
      deep: true
    },
    resizeable: {
      handler: function handler7(val) {
        this.initOpts.windowResize = val;
        this.renderChart(this.option);
      }
    },
    setOptionOpts: {
      handler: function handler8(val) {
        this.renderOption = val;
      },
      deep: true
    },
    loading: function loading(val) {
      var _this15 = this;
      this.$nextTick(function() {
        if (val) {
          _this15.integrateChart.showLoading();
        } else {
          _this15.integrateChart.closeLoading();
        }
      });
    },
    dataEmpty: function dataEmpty(val) {
      var _this16 = this;
      this.$nextTick(function() {
        if (val) {
          _this16.integrateChart.showEmpty();
        } else {
          _this16.integrateChart.closeEmpty();
        }
      });
    },
    size: {
      handler: function handler9(val) {
        var _this17 = this;
        this.$nextTick(function() {
          _this17.integrateChart && _this17.integrateChart.echartsIns && _this17.integrateChart.echartsIns.resize();
        });
      }
    }
  },
  methods: {
    selfSetting: function selfSetting(options2) {
      var _this18 = this;
      var echartsSettings = ["grid", "dataZoom", "visualMap", "toolbox", "title", "legend", "xAxis", "yAxis", "radar", "tooltip", "axisPointer", "brush", "geo", "timeline", "graphic", "series", "backgroundColor", "textStyle"];
      echartsSettings.forEach(function(setting2, index) {
        var unwatch = _this18.watchToPropsEchartOptions[index];
        if (_this18[setting2]) {
          if (!options2.extend) {
            options2.extend = {};
          }
          options2.extend[setting2] = _this18[setting2];
          !unwatch && _this18.$watch(setting2, function() {
            _this18.refreshChart();
          }, {
            deep: true
          });
        } else {
          unwatch && unwatch();
        }
      });
    },
    setAnimation: function setAnimation(options2) {
      var _this19 = this;
      if (this.animation) {
        Object.keys(this.animation).forEach(function(key) {
          options2.extend[key] = _this19.animation[key];
        });
      }
    },
    applyMarks: function applyMarks(options2) {
      if (this.markArea || this.markLine || this.markPoint) {
        var marks = {
          markArea: this.markArea,
          markLine: this.markLine,
          markPoint: this.markPoint
        };
        var series = options2.series;
        var setMark = function setMark2(seriesItem, marks2) {
          Object.keys(marks2).forEach(function(key) {
            if (marks2[key]) {
              seriesItem[key] = marks2[key];
            }
          });
        };
        if (Array.isArray(series)) {
          series.forEach(function(item) {
            setMark(item, marks);
          });
        } else if (isObject$1(series)) {
          setMark(series, marks);
        }
      }
    },
    applyExtend: function applyExtend(option) {
      if (this.extend) {
        return setExtend({
          option,
          extend: this.extend
        });
      }
    },
    refreshChart: function refreshChart() {
      var _this20 = this;
      var data3 = this.data;
      if (Object.keys(this.options).length === 0) {
        this.updateChart(data3);
      } else {
        this.option = JSON.parse(JSON.stringify(this.options));
      }
      var option = this.option;
      clearTimeout(this.timer);
      this.timer = null;
      this.timer = setTimeout(function() {
        if (_this20.afterConfig) {
          option = _this20.afterConfig(option);
        }
        _this20.selfSetting(option);
        _this20.setAnimation(option);
        _this20.applyMarks(_this20.integrateChart.eChartOption);
        _this20.integrateChart.refresh(option);
        option.extend = _this20.applyExtend(_this20.integrateChart.eChartOption);
        if (_this20.colorMode !== "default") {
          option.color = _this20.computedChartColor();
        }
        _this20.integrateChart.refresh(option);
        _this20.$emit("handle-color", option.color);
        if (_this20.afterSetOption) {
          _this20.afterSetOption(_this20.integrateChart.echartsIns);
        }
        _this20.$emit("ready", _this20.integrateChart.echartsIns, option);
      }, this.changeDelay);
    },
    renderChart: function renderChart(option) {
      var plugins = this.plugins || {};
      if (this.isSelfChart) {
        this.integrateChart.init(this.$refs.chartRef);
        if (this.colorMode !== "default") {
          option.color = this.computedChartColor();
        }
        this.integrateChart.setSimpleOption(this.chartList[this.iChartName], option, plugins);
        this.$emit("handle-color", option.color);
        this.integrateChart.render();
      } else {
        this.selfSetting(option);
        this.setAnimation(option);
        var themeName = this.themeName || this.theme || DEFAULT_THEME;
        this.integrateChart.init(this.$refs.chartRef, themeName, this.initOpts);
        if (this.colorMode !== "default") {
          option.color = this.computedChartColor();
        }
        this.integrateChart.setSimpleOption(this.iChartName, option, plugins);
        this.$emit("handle-color", option.color);
        this.applyMarks(this.integrateChart.eChartOption);
        option.extend = this.applyExtend(this.integrateChart.eChartOption);
        this.integrateChart.render(this.renderOption);
      }
      this.$emit("ready", this.integrateChart.echartsIns);
      if (!this.once["ready-once"]) {
        this.once["ready-once"] = true;
        this.$emit("ready", this.integrateChart.echartsIns);
      }
    },
    addEvents: function addEvents(val) {
      var _this21 = this;
      if (typeof val === "object" && val !== null && Object.keys(val).length > 0) {
        var events = Object.keys(val);
        this.$nextTick(function() {
          events.forEach(function(item) {
            _this21.integrateChart.on(item, val[item]);
          });
        });
      }
    },
    removeEvents: function removeEvents(oldVal) {
      var _this22 = this;
      if (typeof oldVal === "object" && oldVal !== null && Object.keys(oldVal).length > 0) {
        var events = Object.keys(oldVal);
        this.$nextTick(function() {
          events.forEach(function(item) {
            _this22.integrateChart.on(item, oldVal[item]);
          });
        });
      }
    },
    resize: function resize() {
      if (!this.cancelResizeCheck) {
        this.integrateChart.echartsIns.resize();
      }
    },
    afterConfigFn: function afterConfigFn(option) {
      if (this.afterConfig) {
        option = this.afterConfig(option);
        this.option = option;
      }
      return option;
    },
    beforeConfigFn: function beforeConfigFn(data3) {
      if (this.beforeConfig) {
        data3 = this.beforeConfig(data3);
      }
      return data3;
    },
    isStack: function isStack() {
      var stack = this.settings.stack, columns = this.data.columns;
      var flag = false;
      if (typeof stack !== "object" || !Array.isArray(columns))
        return flag;
      Object.keys(stack).forEach(function(key) {
        stack[key].forEach(function(stackItem) {
          var isExist = columns.includes(stackItem);
          if (isExist) {
            flag = true;
          }
        });
      });
      return flag;
    },
    calcColors: function calcColors(_ref13) {
      var len = _ref13.len, type = _ref13.type, isStack2 = _ref13.isStack;
      var SAAS_COLOR = SAAS_DEFAULT_COLORS;
      var lastColor = "#1B3F86";
      if (isStack2 && type === "") {
        return len && len > 6 ? [lastColor].concat(SAAS_COLOR.slice(0, len - 1)) : SAAS_COLOR.slice(0, [len || 8]);
      }
      if (!isStack2 && type === "") {
        type = "default";
      }
      if (type === "blue" || type === "green") {
        SAAS_COLOR = SAAS_DEFAULT_SAME_COLORS[type].slice(0, len).sort(function(a, b) {
          return a.idx - b.idx;
        }).map(function(item) {
          return item.color;
        });
      }
      return len && len > 6 ? SAAS_COLOR.slice(0, len - 1).concat([lastColor]) : SAAS_COLOR.slice(0, [len || 8]);
    },
    computedChartColor: function computedChartColor() {
      var defaultColors = DEFAULT_COLORS;
      var flag = this.isStack();
      if (this.data && (Array.isArray(this.data.rows) || Array.isArray(this.data.columns))) {
        var _this$data = this.data, columns = _this$data.columns, rows = _this$data.rows;
        var len = Math.max(columns ? columns.length : 0, rows ? rows.length : 0);
        defaultColors = this.calcColors({
          len,
          type: this.colorMode,
          isStack: flag
        });
      } else if (Array.isArray(this.data)) {
        defaultColors = this.calcColors({
          len: this.data.length,
          type: this.colorMode,
          isStack: flag
        });
      } else if (this.extend && this.extend.series && Array.isArray(this.extend.series.data)) {
        defaultColors = this.calcColors({
          len: this.extend.series.data.length,
          type: this.colorMode,
          isStack: flag
        });
      } else if (this.extend && Array.isArray(this.extend.series)) {
        defaultColors = this.calcColors({
          len: this.extend.series.length,
          type: this.colorMode,
          isStack: flag
        });
      }
      return this.colors || this.theme && this.theme.color || defaultColors;
    }
  },
  created: function created() {
    this.option = {};
    if (!this.selfChart.includes(this.iChartName)) {
      this.isSelfChart = false;
      this.integrateChart = new HuiCharts();
    } else {
      this.isSelfChart = true;
      this.chartList = {
        BaiduMapChart,
        AutonaviMapChart
      };
      this.integrateChart = new this.chartList[this.iChartName]();
    }
  },
  mounted: function mounted() {
    var _this23 = this;
    this.$nextTick(function() {
      _this23.addEvents(_this23.events);
      _this23.loading && _this23.integrateChart.showLoading();
      _this23.dataEmpty && _this23.integrateChart.showEmpty();
    });
    this.initOpts = _extends({}, this.initOptions, {
      domResize: this.judgeWidth,
      resizeThrottle: this.widthChangeDelay
    });
    var data3 = this.data;
    data3 = this.beforeConfigFn(data3);
    if (Object.keys(this.options).length === 0) {
      this.updateChart(data3);
    } else {
      this.option = _extends({}, this.options);
    }
    var option = this.option;
    option = this.afterConfigFn(option);
    this.renderChart(option);
    this.afterSetOption && this.afterSetOption(this.integrateChart.echartsIns);
    this.afterSetOptionOnce && this.afterSetOptionOnce(this.integrateChart.echartsIns);
  },
  beforeUnmount: function beforeUnmount() {
    this.watchToPropsEchartOptions.forEach(function(unwatch) {
      unwatch && unwatch();
    });
  }
};
function typeOf(obj2) {
  var map = {
    "[object Object]": "object",
    "[object Null]": "null",
    "[object Date]": "date",
    "[object Undefined]": "undefined",
    "[object RegExp]": "regExp",
    "[object Array]": "array",
    "[object Function]": "function",
    "[object String]": "string",
    "[object Number]": "number",
    "[object Boolean]": "boolean",
    "[object BigInt]": "bigint"
  };
  var toString2 = Object.prototype.toString;
  return map[toString2.call(obj2)];
}
var isDefined = function isDefined2(val) {
  return val !== void 0 && val !== null;
};
function deepCopy(val) {
  var o;
  var t = typeOf(val);
  if (t === "array") {
    o = [];
  } else if (t === "object") {
    o = {};
  } else {
    return val;
  }
  if (t === "array") {
    for (var i = 0; i < val.length; i++) {
      o.push(deepCopy(val[i]));
    }
  } else if (t === "object") {
    Object.keys(val).forEach(function(i2) {
      o[i2] = deepCopy(val[i2]);
    });
  }
  return o;
}
var getRows = function getRows2(args) {
  var columns = args.columns, metrics = args.metrics, labelMap = args.labelMap, rows = args.rows, _args$dimension = args.dimension, dimension = _args$dimension === void 0 ? columns[0] : _args$dimension;
  var rowData = [];
  var data3 = labelMap ? metrics.map(function(item) {
    return !labelMap[item] ? item : labelMap[item];
  }) : metrics;
  dimension.forEach(function(item) {
    data3.unshift(item);
  });
  rows.forEach(function(item) {
    var obj2 = {};
    for (var i = 0; i < data3.length; i++) {
      obj2[data3[i]] = item[data3[i]];
    }
    rowData.push(obj2);
  });
  return rowData;
};
var getYAxis = function getYAxis2(args) {
  var yAxisType = args.yAxisType, yAxisName = args.yAxisName, _args$scale = args.scale, scale = _args$scale === void 0 ? [false, false] : _args$scale, axisVisible = args.axisVisible, max2 = args.max, min2 = args.min, metrics = args.metrics, axisSite = args.axisSite, _args$digit = args.digit, digit = _args$digit === void 0 ? 2 : _args$digit;
  var yAxis2 = [];
  var yAxisBase = {
    scale
  };
  var _loop4 = function _loop42(k2) {
    yAxis2[k2] = _extends({}, yAxisBase);
    if (yAxisType[k2]) {
      yAxis2[k2] = _extends({}, yAxisBase, {
        axisLabel: {
          formatter: function formatter4(val) {
            return getFormatted(val, yAxisType[k2], digit);
          }
        }
      });
    } else {
      yAxis2[k2] = _extends({}, yAxisBase);
    }
    yAxis2[k2].name = yAxisName[k2];
    yAxis2[k2].min = min2[k2] || null;
    yAxis2[k2].max = max2[k2] || null;
  };
  for (var k = 0; k < 2; k++) {
    _loop4(k);
  }
  metrics.forEach(function(item) {
    if (axisSite.right && axisSite.right.includes(item)) {
      yAxis2[1].dataName = [].concat(axisSite.right);
    } else {
      yAxis2[0].dataName = item;
    }
  });
  return yAxis2;
};
var getTooltip = function getTooltip2(args) {
  var axisSite = args.axisSite, yAxisType = args.yAxisType, labelMap = args.labelMap, _args$digit2 = args.digit, digit = _args$digit2 === void 0 ? 2 : _args$digit2;
  var rightItemsArr = (axisSite == null ? void 0 : axisSite.right) || [];
  var rightListArr = labelMap ? rightItemsArr.map(function(item) {
    return labelMap[item] === void 0 ? item : labelMap[item];
  }) : rightItemsArr;
  var formatter4 = function formatter5(items) {
    var template = [];
    var _items$ = items[0], name2 = _items$.name, axisValueLabel = _items$.axisValueLabel;
    var title2 = name2 || axisValueLabel;
    template.push(title2 + "<br>");
    items.forEach(function(_ref14) {
      var seriesName = _ref14.seriesName, data3 = _ref14.data, color3 = _ref14.color;
      if (color3 === "transparent" && items.length === 1) {
        color3 = "#6d8ff0";
      }
      var showData = null;
      var type = ~rightListArr.indexOf(seriesName) ? yAxisType[1] : yAxisType[0];
      var itemData = Array.isArray(data3) ? data3[1] : data3;
      showData = getFormatted(itemData, type, digit);
      template.push(itemPoint(color3));
      template.push("" + itemLabel(seriesName) + itemContent(showData));
      template.push("<br>");
    });
    return template.join("");
  };
  return {
    trigger: "axis",
    formatter: formatter4
  };
};
Core.install = function(Vue) {
  Vue.component(Core.name, Core);
};
export {
  HEAT_MAP_COLOR,
  cloneDeep$1 as cloneDeep,
  deepCopy,
  Core as default,
  getObj as get,
  getFormatted,
  getMapJSON,
  getRows,
  getStackMap,
  getTooltip,
  getYAxis,
  htmlHandler,
  isDefined,
  isNull,
  isObject$1 as isObject,
  itemContent,
  itemLabel,
  itemPoint,
  merge$1 as merge,
  setObj as set
};
