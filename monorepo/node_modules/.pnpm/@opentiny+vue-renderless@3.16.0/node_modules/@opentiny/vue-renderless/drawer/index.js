import "../chunk-G2ADBYYC.js";
import debounce from "../common/deps/debounce";
import { addClass, removeClass } from "../common/deps/dom";
const computedWidth = ({
  state,
  designConfig,
  props,
  constants
}) => () => {
  var _a;
  if (state.width) {
    return state.width + "px";
  }
  return props.width || ((_a = designConfig == null ? void 0 : designConfig.constants) == null ? void 0 : _a.DEFAULT_WIDTH) || constants.DEFAULT_WIDTH;
};
const close = ({ api }) => (force = false) => {
  api.handleClose("close", force);
};
const watchVisible = ({ state }) => (bool) => {
  setTimeout(() => {
    state.toggle = bool;
  }, 0);
};
const watchToggle = ({ emit }) => (bool) => {
  setTimeout(() => {
    emit("update:visible", bool);
  }, 0);
};
const confirm = ({ api }) => () => {
  api.handleClose("confirm");
};
const handleClose = ({ emit, props, state }) => (type, force) => {
  const isMaskNotClosable = type === "mask" && !props.maskClosable;
  const isBlockClose = !force && typeof props.beforeClose === "function" && props.beforeClose(type) === false;
  if (isMaskNotClosable || isBlockClose) {
    return;
  }
  if (type !== "confirm") {
    state.toggle = false;
  }
  emit(["close", "confirm"].includes(type) ? type : "close");
};
const mousedown = ({ state, vm }) => (event2) => {
  event2.preventDefault();
  const touch = event2.touches ? event2.touches[0] : event2;
  const drawerBox = vm.$refs.drawerBox;
  state.dragEvent.isDrag = true;
  state.dragEvent.x = touch.clientX;
  state.dragEvent.y = touch.clientY;
  state.dragEvent.offsetWidth = drawerBox.offsetWidth;
  state.dragEvent.offsetHeight = drawerBox.offsetHeight;
};
const mousemove = ({ state, props }) => debounce(1, (event2) => {
  if (!state.dragEvent.isDrag) {
    return;
  }
  event2.preventDefault();
  const { placement } = props;
  const {
    dragEvent: { x, y, offsetWidth, offsetHeight }
  } = state;
  const { touches, targetTouches, changedTouches } = event2;
  const touch = touches && touches[0] || targetTouches && targetTouches[0] || changedTouches && changedTouches[0];
  const { clientX, clientY } = touch || event2;
  const offsetX = clientX - x;
  const offsetY = clientY - y;
  if (placement === "left") {
    state.width = offsetWidth + offsetX;
  } else if (placement === "right") {
    state.width = offsetWidth - offsetX;
  } else if (placement === "top") {
    const height = offsetHeight + offsetY;
    state.height = height > 10 ? height : 10;
  } else if (placement === "bottom") {
    const height = offsetHeight - offsetY;
    state.height = height > 10 ? height : 10;
  }
});
const mouseup = ({ state }) => () => {
  if (!state.dragEvent.isDrag) {
    return;
  }
  ;
  event.preventDefault();
  state.dragEvent.isDrag = false;
};
const addDragEvent = ({ api, vm }) => () => {
  const el = vm.$refs.dragBar;
  el.addEventListener("mousedown", api.mousedown);
  document.addEventListener("mousemove", api.mousemove);
  document.addEventListener("mouseup", api.mouseup);
  el.addEventListener("touchstart", api.mousedown);
  el.addEventListener("touchmove", api.mousemove);
  el.addEventListener("touchend", api.mouseup);
};
const removeDragEvent = ({ api, vm }) => () => {
  const el = vm.$refs.dragBar;
  el.removeEventListener("mousedown", api.mousedown);
  document.removeEventListener("mousemove", api.mousemove);
  document.removeEventListener("mouseup", api.mouseup);
  el.removeEventListener("touchstart", api.mousedown);
  el.removeEventListener("touchmove", api.mousemove);
  el.removeEventListener("touchend", api.mouseup);
};
const showScrollbar = (lockScrollClass) => () => {
  addClass(document.body, lockScrollClass);
};
const hideScrollbar = (lockScrollClass) => () => {
  removeClass(document.body, lockScrollClass);
};
const watchVisibleNotImmediate = ({ api, props }) => (visible) => {
  if (props.lockScroll) {
    visible ? api.showScrollbar() : api.hideScrollbar();
  }
};
export {
  addDragEvent,
  close,
  computedWidth,
  confirm,
  handleClose,
  hideScrollbar,
  mousedown,
  mousemove,
  mouseup,
  removeDragEvent,
  showScrollbar,
  watchToggle,
  watchVisible,
  watchVisibleNotImmediate
};
