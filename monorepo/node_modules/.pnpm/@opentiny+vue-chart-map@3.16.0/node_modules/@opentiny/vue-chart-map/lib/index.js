import Core, { getMapJSON, isNull, itemLabel, itemPoint, itemContent, getFormatted } from '@opentiny/vue-chart-core';
import * as echarts from 'echarts';
import { $prefix } from '@opentiny/vue-common';
import { openBlock, createElementBlock, createElementVNode, normalizeStyle, renderSlot } from 'vue';

function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it)
    return (it = it.call(o)).next.bind(it);
  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it)
      o = it;
    var i = 0;
    return function() {
      if (i >= o.length)
        return { done: true };
      return { done: false, value: o[i++] };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
var _export_sfc = function _export_sfc2(sfc, props) {
  var target = sfc.__vccOpts || sfc;
  for (var _iterator = _createForOfIteratorHelperLoose(props), _step; !(_step = _iterator()).done; ) {
    var _step$value = _step.value, key = _step$value[0], val = _step$value[1];
    target[key] = val;
  }
  return target;
};

function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
var getLegendMap = function getLegendMap2(args, legendItemStyle) {
  var metrics = args.metrics, legendName = args.legendName, labelMap = args.labelMap;
  if (!labelMap && !legendName) {
    return {
      data: metrics
    };
  }
  var data2 = labelMap ? metrics.map(function(item) {
    return isNull(labelMap[item]) ? item : labelMap[item];
  }) : metrics;
  return _extends({}, legendItemStyle, {
    data: data2,
    formatter: function formatter(name) {
      return isNull(legendName[name]) ? name : legendName[name];
    }
  });
};
var getTooltip = function getTooltip2(_ref) {
  var dataType = _ref.dataType, digit = _ref.digit, dataStore = _ref.dataStore, metrics = _ref.metrics, color = _ref.color, labelMap = _ref.labelMap;
  function formatter(item) {
    var tplt = [];
    if (!item.name) {
      return "";
    }
    tplt.push(itemLabel(item.name) + "<br>");
    metrics.forEach(function(label, index) {
      var title = isNull(labelMap[label]) ? label : labelMap[label];
      tplt.push("" + itemPoint(color[index]) + itemLabel(title));
      if (dataStore[item.name]) {
        tplt.push(itemContent(getFormatted(dataStore[item.name][label], dataType[label], digit)));
      } else {
        tplt.push(itemContent("-"));
      }
      tplt.push("<br>");
    });
    return tplt.join("");
  }
  return {
    trigger: "item",
    formatter
  };
};
var setGeoLabel = function setGeoLabel2(value, target, label) {
  if (typeof value === "object") {
    target[label] = value;
  } else if (value) {
    target[label] = {
      show: true
    };
  }
};
var getSeries = function getSeries2(args) {
  var position = args.position, selectData = args.selectData, dimension = args.dimension, metrics = args.metrics, rows = args.rows, label = args.label, selectedMode = args.selectedMode, roam = args.roam, center = args.center, aspectScale = args.aspectScale, zoom = args.zoom;
  var boundingCoords = args.boundingCoords, labelMap = args.labelMap, scaleLimit = args.scaleLimit, mapGrid = args.mapGrid, _args$itemStyle = args.itemStyle, itemStyle = _args$itemStyle === void 0 ? {
    areaColor: "rgba(25,25,25,0.05)"
  } : _args$itemStyle;
  var _ref2 = {}, _ref2$result = _ref2.result, result = _ref2$result === void 0 ? [] : _ref2$result, _ref2$mapBase = _ref2.mapBase, mapBase = _ref2$mapBase === void 0 ? {
    type: "map",
    map: position
  } : _ref2$mapBase;
  var _ref3 = {}, _ref3$emphasis = _ref3.emphasis, emphasis = _ref3$emphasis === void 0 ? {
    itemStyle: {
      areaColor: "rgba(25,25,25,0.2)"
    },
    label: {
      color: "#191919"
    }
  } : _ref3$emphasis;
  metrics.forEach(function(itemName) {
    var name = !isNull(labelMap[itemName]) ? labelMap[itemName] : itemName;
    var data2 = [];
    var itemResult = _extends({
      name,
      data: data2,
      selectedMode,
      roam,
      center,
      aspectScale,
      boundingCoords,
      zoom,
      scaleLimit
    }, mapBase);
    if (mapGrid) {
      Object.keys(mapGrid).forEach(function(key) {
        return itemResult[key] = mapGrid[key];
      });
    }
    setGeoLabel(itemStyle, itemResult, "itemStyle");
    setGeoLabel(label, itemResult, "label");
    rows.forEach(function(row) {
      return itemResult.data.push({
        name: row[dimension],
        value: row[itemName],
        selected: selectData
      });
    });
    itemResult.emphasis = emphasis;
    itemResult.label = _extends({
      color: "#191919"
    }, itemResult.label);
    result.push(itemResult);
  });
  return result;
};
var registerMap = function registerMap2(args, mapOrigin, echarts2) {
  var _once = args._once, registerSign = args.registerSign, beforeRegisterMap = args.beforeRegisterMap, beforeRegisterMapOnce = args.beforeRegisterMapOnce;
  var registerSignOnce = args.registerSignOnce, position = args.position, specialAreas = args.specialAreas;
  if (!_once[registerSign] && beforeRegisterMap) {
    mapOrigin = beforeRegisterMap(mapOrigin);
  }
  if (!_once[registerSign] && beforeRegisterMapOnce && !_once[registerSignOnce]) {
    _once[registerSignOnce] = true;
    mapOrigin = beforeRegisterMapOnce(mapOrigin);
  }
  if (!_once[registerSign]) {
    _once[registerSign] = true;
    echarts2.registerMap(position, mapOrigin, specialAreas);
  }
};
var map = function map2(columns, rows, settings, extra) {
  var _settings$position = settings.position, position = _settings$position === void 0 ? "" : _settings$position, _settings$selectData = settings.selectData, selectData = _settings$selectData === void 0 ? false : _settings$selectData, selectedMode = settings.selectedMode, _settings$label = settings.label, label = _settings$label === void 0 ? true : _settings$label, _settings$dataType = settings.dataType, dataType = _settings$dataType === void 0 ? {} : _settings$dataType, _settings$digit = settings.digit, digit = _settings$digit === void 0 ? 2 : _settings$digit;
  var _settings$dimension = settings.dimension, dimension = _settings$dimension === void 0 ? columns[0] : _settings$dimension, roam = settings.roam, center = settings.center, aspectScale = settings.aspectScale, boundingCoords = settings.boundingCoords, zoom = settings.zoom;
  var scaleLimit = settings.scaleLimit, _settings$legendName = settings.legendName, legendName = _settings$legendName === void 0 ? {} : _settings$legendName, _settings$labelMap = settings.labelMap, labelMap = _settings$labelMap === void 0 ? {} : _settings$labelMap, mapGrid = settings.mapGrid, itemStyle = settings.itemStyle, positionJsonLink = settings.positionJsonLink, emphasis = settings.emphasis;
  var beforeRegisterMap = settings.beforeRegisterMap, beforeRegisterMapOnce = settings.beforeRegisterMapOnce, _settings$mapURLProfi = settings.mapURLProfix, mapURLProfix = _settings$mapURLProfi === void 0 ? extra.baseUrl || "" : _settings$mapURLProfi, _settings$specialArea = settings.specialAreas, specialAreas = _settings$specialArea === void 0 ? {} : _settings$specialArea;
  var mapOrigin = settings.mapOrigin;
  var metrics = columns.slice(0);
  if (!settings.metrics) {
    metrics.splice(columns.indexOf(dimension), 1);
  } else {
    metrics = settings.metrics;
  }
  var tooltipVisible = extra.tooltipVisible, legendVisible = extra.legendVisible, color = extra.color, _once = extra._once, echarts2 = extra.echarts;
  var dataStore = {};
  rows.forEach(function(row) {
    return dataStore[row[dimension]] = row;
  });
  var tooltip = tooltipVisible ? getTooltip({
    dataType,
    digit,
    dataStore,
    metrics,
    color,
    labelMap
  }) : {
    show: false
  };
  var legend = legendVisible ? _extends({
    show: true
  }, getLegendMap({
    metrics,
    legendName,
    labelMap
  })) : {
    show: false
  };
  var seriesParams = {
    position,
    selectData,
    label,
    itemStyle,
    dimension,
    metrics,
    rows,
    selectedMode,
    roam
  };
  Object.assign(seriesParams, {
    center,
    aspectScale,
    boundingCoords,
    zoom,
    labelMap,
    scaleLimit,
    mapGrid,
    emphasis
  });
  var series = getSeries(seriesParams);
  var registerSign = "MAP_REGISTER_" + position;
  var registerSignOnce = "ONCE_MAP_REGISTER_" + position;
  var registerOptions = {
    _once,
    beforeRegisterMap,
    beforeRegisterMapOnce,
    position
  };
  Object.assign(registerOptions, {
    specialAreas,
    registerSign,
    registerSignOnce
  });
  if (mapOrigin) {
    registerMap(registerOptions, mapOrigin, echarts2);
    return {
      series,
      tooltip,
      legend,
      tipHtml: tooltip.formatter
    };
  }
  var param = {
    position,
    positionJsonLink,
    beforeRegisterMapOnce,
    mapURLProfix
  };
  return getMapJSON(param).then(function(json) {
    registerMap(registerOptions, json, echarts2);
    return {
      series,
      tooltip,
      legend,
      tipHtml: tooltip.formatter
    };
  });
};
var _sfc_main = {
  name: $prefix + "ChartMap",
  mixins: [Core],
  data: function data() {
    return {
      iChartName: "RegionChart"
    };
  },
  methods: {
    updateChart: function updateChart() {
      var _this$data = this.data, _this$data$columns = _this$data.columns, columns = _this$data$columns === void 0 ? [] : _this$data$columns, _this$data$rows = _this$data.rows, rows = _this$data$rows === void 0 ? [] : _this$data$rows;
      var extra = {
        tooltipVisible: this.tooltipVisible,
        legendVisible: this.legendVisible,
        extend: this.extend,
        echarts,
        color: ["#2070F3", "#55CCD9", "#715AF8", "#8AC8F3"],
        _once: {
          onresize: true
        }
      };
      var option = map(columns, rows, this.settings, extra);
      this.option = _extends({}, option);
    }
  }
};
var _hoisted_1 = {
  class: "hui-chart chart-box"
};
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1, [createElementVNode(
    "div",
    {
      ref: "chartRef",
      style: normalizeStyle({
        width: _ctx.width,
        height: _ctx.height
      })
    },
    null,
    4
    /* STYLE */
  ), renderSlot(_ctx.$slots, "default")]);
}
var ChartMap = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
ChartMap.install = function(Vue) {
  Vue.component(ChartMap.name, ChartMap);
};

export { ChartMap, ChartMap as default };
